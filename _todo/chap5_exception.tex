\input{../../common/livre_begin.tex}%
\firstpassagedo{\input{python_cours_titre.tex}}
\input{../../common/livre_table_begin.tex}%
%\firstpassagedo{\input{python_cours_chapter.tex}}






%-------------------------------------------------------------------------------------------------------------
\chapter{Exceptions}
%-------------------------------------------------------------------------------------------------------------
\label{chap_exception}
\indexfr{exception}

Le petit programme suivant déclenche une erreur parce qu'il effectue une division par zéro.
\vspaceneg
%
\begin{verbatimx}
x = 0
y = 1.0 / x
\end{verbatimx}
\vspaceneg
%
Il déclenche une erreur ou ce qu'on appelle une \emph{exception}.
%
\vspaceneg
\begin{verbatimx}
Traceback (most recent call last):
  File "cours.py", line 2, in ?
    y = 1.0 / x
ZeroDivisionError: float division
\end{verbatimx}
\vspaceneg
%
Le mécanisme des exceptions permet au programme de "rattraper" les erreurs, de détecter qu'une erreur s'est produite et d'agir en conséquence afin que le programme ne s'arrête pas.

\section{Principe des exceptions}

\subsection{Attraper toutes les erreurs}

			\begin{xdefinition}{exception}
			Une exception est un objet qui indique que le programme ne peut continuer son exécution.
			\end{xdefinition}



On décide par exemple qu'on veut rattraper toutes les erreurs du programme et afficher un message d'erreur. Le programme suivant appelle la fonction \codes{inverse} qui retourne l'inverse d'un nombre. 
%
\vspaceneg
\begin{verbatimx}
def inverse (x):
    y = 1.0 / x
    return y
    
a = inverse (2)
print a
b = inverse (0)
print b
\end{verbatimx}
\vspaceneg
%
Lorsque le paramètre \codes{x = 0}, le programme effectue une division par zéro et déclenche une erreur qui paraît différente de la première d'après la longueur du message. C'est pourtant la même erreur~: cette liste correspond en fait à ce qu'on appelle la pile d'appels\footnote{\textit{call stack} en anglais}.\indexfr{pile d'appels}\indexfr{call stack} Si l'erreur se produit dans une fonction elle-même appelée par une autre... la pile d'appel permet d'obtenir la liste de toutes les fonctions pour remonter jusqu'à celle où l'erreur s'est produite.
%
\vspaceneg
\begin{verbatimx}
Traceback (most recent call last):
  File "cours.py", line 8, in ?
    b = inverse (0)
  File "cours.py", line 3, in inverse
    y = 1.0 / x
ZeroDivisionError: float division
\end{verbatimx}
%
\vspaceneg
Afin de rattraper l'erreur, on insère le code susceptible de produire une erreur entre les mots clés \codes{try} et \codes{except}.
\indexfr{exception}\indexkeyword{try}\indexkeyword{except}
\vspaceneg\indexexemples{exception}{}
%
\begin{verbatimx}
def inverse (x):
    y = 1.0 / x
    return y
    
try :
    a = inverse (2)
    print a
    b = inverse (0)  # déclenche une exception
    print b
except :
    print "le programme a déclenché une erreur"
\end{verbatimx}
% 
\vspaceneg
Le programme essaye d'exécuter les quatre instructions incluses entre les instructions \codes{try} et \codes{except}. Si une erreur se produit, le programme exécute alors les lignes qui suivent l'instruction \codes{except}. L'erreur se produit en fait à l'intérieur de la fonction \codes{inverse} mais celle-ci est appelée à l'intérieur d'un code "protégé" contre les erreurs. Le programme précédent affiche les deux lignes suivantes.
%
\vspaceneg
\begin{verbatimx}
0.5
le programme a déclenché une erreur
\end{verbatimx}
\vspaceneg
%
\indexkeyword{else}
Il est aussi possible d'ajouter une clause \codes{else} qui sert de préfixe à une liste d'instructions qui ne sera exécutée que si aucune exception n'est déclenchée.
%
\vspaceneg
\begin{verbatimx}
def inverse (x):
    y = 1.0 / x
    return y
    
try :
    print inverse (2)  # pas d'erreur
    print inverse (1)  # pas d'erreur non plus
except :
    print "le programme a déclenché une erreur"
else :
    print "tout s'est bien passé"
\end{verbatimx}
\vspaceneg
Ce dernier programme ne déclenche aucune exception et affiche les lignes suivantes.
\vspaceneg
%
\begin{verbatimx}
0.5
1.0
tout s'est bien passé
\end{verbatimx}
%
\vspaceneg
Pour résumer, la syntaxe suivante permet d'attraper toutes les erreurs qui se produisent pendant l'exécution d'une partie du programme. Cette syntaxe permet en quelque sorte de protéger cette partie du programme contre les erreurs.

\begin{xsyntax}{exception}
\begin{verbatimno}
try : 
    # ... instructions à protéger
except :
    # ... que faire en cas d'erreur 
else : 
    # ... que faire lorsque aucune erreur n'est apparue
\end{verbatimno}
\negvspace
Toute erreur déclenchée alors que le programme exécute les instructions qui suivent le mot-clé \codes{try} déclenche immédiatement l'exécution des lignes qui suivent le mot-clé \codes{except}. Dans le cas contraire, le programme se poursuit avec l'exécution des lignes qui suivent le mot-clé \codes{else}. Cette dernière partie est facultative, la clause \codes{else} peut ou non être présente. Dans tous les cas, l'exécution du programme ne s'arrête pas. \indexsyntaxenoc{exception} \indexsymbol{:}\indexkeyword{try}\indexkeyword{except}\indexkeyword{else}
\end{xsyntax}


\begin{xremark}{plusieurs erreurs}
Lorsqu'une section de code est protégée contre les exceptions, si elle contient plusieurs erreurs, son exécution s'arrête à la première des erreurs découvertes. Par exemple, dès la première erreur qui correspond au calcul d'une puissance non entière d'un nombre négatif, l'exécution du programme suivant est dirigée vers l'instruction qui suit le mot-clé \codes{except}. 
%
\vspaceneg
\begin{verbatimx}
def inverse (x):
    y = 1.0 / x
    return y
    
try :
    print (-2.1) ** 3.1  # première erreur
    print inverse (2)
    print inverse (0)    # seconde erreur
except :
    print "le programme a déclenché une erreur"
\end{verbatimx}
\end{xremark}



\subsection{Obtenir le type d'erreur, attraper un type d'exception}
\indextype{Exception}

Parfois, plusieurs types d'erreurs peuvent être déclenchés à l'intérieur d'une portion de code protégée. Pour avoir une information sur ce type, 
il est possible de récupérer une variable de type \codes{Exception}.
%
\vspaceneg\indexexemples{exception}{}
\begin{verbatimx}
def inverse (x):
    y = 1.0 / x
    return y
    
try :
    print inverse (2)
    print inverse (0)
except Exception, exc:
    print "exception de type ", exc.__class__  
         # affiche exception de type  exceptions.ZeroDivisionError
    print "message ", exc
         # affiche le message associé à l'exception
\end{verbatimx}
\vspaceneg
%
Le programme précédent récupère une exception sous la forme d'une variable appelée \codes{exc}. Cette variable est en fait une instance 
d'une classe d'erreur, \codes{exc.\_\_class\_\_} correspond au nom de cette classe. A l'aide de la fonction \codes{isinstance}, 
il est possible d'exécuter des traitements différents selon le type d'erreur.
%
\vspaceneg
\indexfonction{isinstance}
\begin{verbatimx}
def inverse (x):
    y = 1.0 / x
    return y
    
try :
    print (-2.1) ** 3.1  # première erreur
    print inverse (2)
    print inverse (0)    # seconde erreur
except Exception, exc:
    if isinstance (exc, ZeroDivisionError) :
        print "division par zéro"
    else :
        print "erreur insoupçonnée : ", exc.__class__
        print "message ", exc
\end{verbatimx}
\vspaceneg
%
L'exemple précédent affiche le message qui suit parce que la première erreur intervient lors du calcul de \codes{(-2.1) ** 3.1}.
%
\vspaceneg
\begin{verbatimx}
erreur insoupçonnée :  exceptions.ValueError
\end{verbatimx}
\vspaceneg
%
Une autre syntaxe plus simple permet d'attraper un type d'exception donné en accolant au mot-clé \codes{except} le type de l'exception qu'on désire attraper. 
L'exemple précédent est équivalent au suivant mais syntaxiquement différent.
%
\vspaceneg\indexexemples{exception}{}
\begin{verbatimx}
def inverse (x):
    y = 1.0 / x
    return y
    
try :
    print (-2.1) ** 3.1
    print inverse (2)
    print inverse (0)
except ZeroDivisionError:
    print "division par zéro"
except Exception, exc:
    print "erreur insoupçonnée : ", exc.__class__
    print "message ", exc
\end{verbatimx}
\vspaceneg
%
Cette syntaxe obéit au schéma qui suit.

\begin{xsyntax}{exception d'un type donné}
\begin{verbatimno}

try :
    # ... instructions à protéger
except type_exception_1 :
    # ... que faire en cas d'erreur de type type_exception_1
except type_exception_i :
    # ... que faire en cas d'erreur de type type_exception_i
except type_exception_n :
    # ... que faire en cas d'erreur de type type_exception_n
except :
    # ... que faire en cas d'erreur d'un type différent de tous 
    #     les précédents types
else :
    # ... que faire lorsque une erreur aucune erreur n'est apparue
\end{verbatimno}
\negvspace   \label{syntax_exception_except}
Toute erreur déclenchée alors que le programme exécute les instructions qui suivent le mot-clé \codes{try} déclenche immédiatement l'exécution des lignes qui suivent un mot-clé \codes{except}. Le programme compare le type d'exception aux types \codes{type\_exception\_1} à \codes{type\_exception\_n}. S'il existe une correspondance alors ce sont les instructions de la clause \codes{except} associée qui seront exécutées et uniquement ces instructions. La dernière clause \codes{except} est facultative, elle est utile lorsque aucun type de ceux prévus ne correspond à l'exception générée. La clause \codes{else} est aussi facultative. Si la dernière clause \codes{except} n'est pas spécifiée et que l'exception déclenchée ne correspond à aucune de celle listée plus haut, le programme s'arrête sur cette erreur à moins que celle-ci ne soit attrapée plus tard.
\indexsymbole{:}\indexkeyword{try}\indexkeyword{except}\indexkeyword{else}\indexsyntaxenoc{exception d'un type donné}
\end{xsyntax}

Le langage \pythons propose une liste d'exceptions standards (voir table~\ref{exception_table_liste}, page~\pageref{exception_table_liste}). Lorsqu'une erreur ne correspond pas à l'une de ces exceptions, il est possible de créer une exception propre à un certain type d'erreur (voir paragraphe~\ref{exception_chap_define}). Lorsqu'une fonction ou une méthode déclenche une exception non standard, généralement, 
le commentaire qui lui est associé l'indique.



			\begin{table}[ht]
			\begin{center}\begin{tabularx}{\textwidth}{|l|X|} \hline
			\codes{Exception}	       		&  	%\begin{minipage}{12cm} 
																			\indexexception{Exception}
																			Elle n'est en principe jamais explicitement générée par les fonctions \pythons mais elle 
																			permet d'attraper toutes les exceptions car toutes dérivent de la classe \codes{Exception}.
																			%\end{minipage} 
																			\\ \hline
			\codes{AttributeError}			&  	%\begin{minipage}{12cm} 
																			\indexexception{AttributeError}
																			Une référence à un attribut inexistant ou une affectation a échoué. 
																			%\end{minipage} 
																			\\ \hline
			\codes{ArithmeticError}			&  	%\begin{minipage}{12cm} 
																			\indexexception{ArithmeticError}
																			Une opération arithmétique a échoué.
																			%\end{minipage} 
																			\\ \hline
			\codes{FloatingPointError}	&		%\begin{minipage}{12cm} 
																			\indexexception{FloatingPointError} 
																			Une opération avec des nombres réels a échoué.
																			%\end{minipage} 
																			\\ \hline
			\codes{IOError}							&		%\begin{minipage}{12cm}  
																			\indexexception{IOError}
																			Une opération concernant les entrées/sorties (Input/Output) a échoué.
																			Cette erreur survient par exemple lorsqu'on cherche à 
																			lire un fichier qui n'existe pas.
																			%\end{minipage} 
																			\\ \hline
			\codes{ImportError}					&		%\begin{minipage}{12cm}  
																			\indexexception{ImportError}
																			Cette erreur survient lorsqu'on cherche à importer un module qui n'existe pas 
																			(voir chapitre~\ref{chap_module}).
																			%\end{minipage} 
																			\\ \hline
			\codes{IndentationError}		&		%\begin{minipage}{12cm}  
																			\indexexception{IndentationError}
																			L'interpréteur ne peut interpréter une partie du programme à cause
																			d'un problème d'indentation.\ifnotellipse{\indexfr{indentation}} Il n'est pas possible
																			d'exécuter un programme mal indenté mais cette erreur peut se produire 
																			lors de l'utilisation de la fonction \codes{compile}\indexfonction{compile}
																			(voir le paragraphe~\ref{par_compilation_fonction}, page~\pageref{par_compilation_fonction}).
																			%\end{minipage} 
																			\\ \hline
			\codes{IndexError}					&		%\begin{minipage}{12cm}  
																			\indexexception{IndexError}
																			On utilise un index erroné pour accéder à un élément d'une liste,
																			d'un dictionnaire ou de tout autre tableau. 
																			%\end{minipage} 
																			\\ \hline
			\codes{KeyError}						&		%\begin{minipage}{12cm}  
																			\indexexception{KeyError}
																			Une clé est utilisée pour accéder à un élément d'un dictionnaire
																			dont elle ne fait pas partie.
																			%\end{minipage} 
																			\\ \hline
			\codes{NameError}						&		%\begin{minipage}{12cm}  
																			\indexexception{NameError}
																			On utilise une variable, une fonction, une classe qui n'existe pas.
																			%\end{minipage} 
																			\\ \hline
			\codes{OverflowError}				&		%\begin{minipage}{12cm}  
																			\indexexception{OverflowError}
																			Un calcul sur des entiers ou des réels dépasse les capacités de codage
																			des entiers ou des réels.
																			%\end{minipage} 
																			\\ \hline
			\codes{StopIteration}	  		&		%\begin{minipage}{12cm}  
																			\indexexception{StopIteration}
																			Cette exception est utilisée 
																			pour signifier qu'un itérateur atteint la fin d'un ensemble,
																			un tableau, un dictionnaire.
																			%\end{minipage} 
																			\\ \hline
			\codes{TypeError}						&		%\begin{minipage}{12cm}  
																			\indexexception{TypeError}
																			Erreur de type, une fonction est appliquée sur un objet qu'elle n'est 
																			pas censée manipuler.
																			%\end{minipage} 
																			\\ \hline
			\codes{UnicodeError}				&		%\begin{minipage}{12cm}  
																			\indexexception{UnicodeError}
 Il faut parfois convertir des chaînes de caractères de type \codes{unicode}
													  en chaînes de caractères de type \codes{str} et réciproquement. Cette exception intervient lorsque la conversion n'est pas possible (voir également le paragraphe~\ref{para_cosedescodes} page~\pageref{para_cosedescodes}).
																			%\end{minipage} 
																			\\ \hline
			\codes{ValueError}					&		%\begin{minipage}{12cm}  
																			\indexexception{ValueError}
																			Cette exception survient lorsqu'une valeur est inappropriée pour une certaine
																			opération, par exemple, l'obtention du logarithme d'un nombre négatif.
																			%\end{minipage} 
																			\\ \hline
			\codes{ZeroDivisionError}		&		%\begin{minipage}{12cm}  
																			\indexexception{ZeroDivisionError}
																			Cette exception survient pour une division par zéro.
																			%\end{minipage} 
																			\\ \hline
			\end{tabularx}\end{center}
			\caption{	Exceptions standard les plus couramment utilisées. Ces exceptions sont définies
								par le langage \python. Il n'est pas nécessaire d'inclure un module. La page 
								\httpstyle{http://docs.python.org/library/exceptions.html} recense
								toutes les exceptions prédéfinies.}
			\label{exception_table_liste}
			\end{table}


\subsection{Lancer une exception}
\indexfrr{exception}{message}\indexkeyword{raise}

Lorsqu'une fonction détecte une erreur, il lui est possible de déclencher une exception par l'intermédiaire du mot-clé 
\codes{raise}. La fonction \codes{inverse} compare \codes{x} à \codes{0} et déclenche l'exception 
\codes{ValueError} si \codes{x} est nul. Cette exception est attrapée plus bas.
%
\vspaceneg
\begin{verbatimx}
def inverse (x):
    if x == 0 :
        raise ValueError
    y = 1.0 / x
    return y
    
try :
    print inverse (0)  # erreur
except ValueError:
    print "erreur"
\end{verbatimx}
\vspaceneg
%
Il est parfois utile d'associer un message à une exception afin que l'utilisateur ne soit pas perdu. 
Le programme qui suit est identique au précédent à ceci près qu'il associe à l'exception \codes{ValueError} 
qui précise l'erreur et mentionne la fonction où elle s'est produite. Le message est ensuite intercepté plus bas.
\indexfrr{exception}{message}
%
\vspaceneg
\begin{verbatimx}
def inverse (x):
    if x == 0 :
        raise ValueError ("valeur nulle interdite, fonction inverse")
    y = 1.0 / x
    return y
    
try :
    print inverse (0)  # erreur
except ValueError, exc:
    print "erreur, message : ", exc
\end{verbatimx}
\vspaceneg
%
Le déclenchement d'une exception suit la syntaxe suivante.
\vspaceneg

\begin{xsyntax}{exception, \codes{raise}}
\begin{verbatimno}

raise exception_type (message) :
\end{verbatimno}
\negvspace
Cette instruction lance l'exception \codes{exception\_type} associée au message \codes{message}. 
Le message est facultatif, lorsqu'il n'y en a pas, la syntaxe se résume à \codes{raise \; exception\_type}. \indexkeyword{raise}\indexsyntaxenoc{exception, lancement}
\end{xsyntax}

Et pour attraper cette exception et le message qui lui est associé, il faut utiliser la syntaxe~\ref{syntax_exception_except} décrite au paragraphe précédent.





\subsection{Héritage et exception}  \label{exception_chap_heritage}
\indexfrr{exception}{héritage}

L'instruction \codes{help (ZeroDivisionError)} retourne l'aide associée à l'exception \codes{ZeroDivisionError}. 
Celle-ci indique que l'exception \codes{ZeroDivisionError} est en fait un cas particulier de l'exception \codes{ArithmeticError},
elle-même un cas particulier de \codes{StandardError}. 
%
\vspaceneg
\begin{verbatimx}
class ZeroDivisionError(ArithmeticError)
 |  Second argument to a division or modulo operation was zero.
 |  
 |  Method resolution order:
 |      ZeroDivisionError
 |      ArithmeticError
 |      StandardError
 |      Exception
\end{verbatimx}
\vspaceneg
%
Toutes les exceptions sont des cas particuliers de l'exception de type \codes{Exception}. C'est pourquoi l'instruction \codes{except \; Exception, e :} attrape toutes les exceptions. L'instruction \codes{except \; ArithmeticError :} attrape toutes les erreurs de type \codes{ArithmeticError}, ce qui inclut les erreurs de type \codes{ZeroDivisionError}. Autrement dit, toute exception de type \codes{ZeroDivisionError} est attrapée par les instructions suivantes~:

\begin{small}
			\begin{itemize}
			\item \codesmall{except \; ZeroDivisionError :}
			\item \codesmall{except \; ArithmeticError :}
			\item \codesmall{except \; StandardError :}
			\item \codesmall{except \; Exception :}
			\end{itemize}
\end{small}

%
Plus précisément, chaque exception est une classe qui dérive directement ou indirectement de la classe \codes{Exception}. L'instruction \codes{except \; ArithmeticError :} par exemple attrape toutes les exceptions de type \codes{ArithmeticError} et toutes celles qui en dérivent comme la classe \codes{ZeroDivisionError} (voir également le paragraphe~\ref{exception_chap_define}).





\subsection{Instructions \codes{try}, \codes{except} imbriquées}
\indexfrr{exception}{imbrication}

Comme pour les boucles, il est possible d'imbriquer les portions protégées de code les unes dans les autres. Dans l'exemple qui suit, la première erreur est l'appel à une fonction non définie, ce qui déclenche l'exception \codes{NameError}.
%
\vspaceneg
\begin{verbatimx}
def inverse (x):
    y = 1.0 / x
    return y
    
try :
    try :    
        print inverses (0)  # fonction inexistante --> exception NameError
        print inverse (0)   # division par zéro --> ZeroDivisionError
    except NameError:
        print "appel à une fonction non définie"
except ZeroDivisionError, exc:
    print "erreur ", exc
\end{verbatimx}
\vspaceneg
%
En revanche, dans le second exemple, les deux lignes \codes{print \; inverse (0)} et \codes{print \; inverses (0)} ont été permutées. La première exception déclenchée est la division par zéro. La première clause \codes{except} n'interceptera pas cette erreur puisqu'elle n'est pas du type recherché.
%
\vspaceneg
\begin{verbatimx}
def inverse (x):
    y = 1.0 / x
    return y
    
try :
    try :    
        print inverse (0)   # division par zéro --> ZeroDivisionError
        print inverses (0)  # fonction inexistante --> exception NameError
    except NameError:
        print "appel à une fonction non définie"
except ZeroDivisionError, exc:
    print "erreur ", exc
\end{verbatimx}
\vspaceneg
%
Une autre imbrication possible est l'appel à une fonction qui inclut déjà une partie de code protégée. L'exemple suivant appelle la fonction \codes{inverse} qui intercepte les exceptions de type \codes{ZeroDivisionError} pour retourner une grande valeur lorsque \codes{x=0}. La seconde exception générée survient lors de l'appel à la fonction \codes{inverses} qui déclenche l'exception \codes{NameError}, elle aussi interceptée.
%
\vspaceneg\indexexemples{exception}{}
\begin{verbatimx}
def inverse (x):
    try :
        y = 1.0 / x
    except ZeroDivisionError, exc:
        print "erreur ", exc
        if x > 0 : return 1000000000
        else : return -1000000000
    return y
    
try :    
    print inverse (0)   # division par zéro    --> la fonction inverse sait gérer
    print inverses (0)  # fonction inexistante --> exception NameError
except NameError:
    print "appel à une fonction non définie"
\end{verbatimx}





\section{Définir ses propres exceptions}
\label{exception_chap_define}


\subsection{Dériver une classe d'exception}

Pour définir sa propre exception, il faut créer une classe qui dérive d'une classe d'exception existante (voir paragraphe~\ref{exception_chap_heritage}), par exemple, la classe \codes{Exception}. L'exemple suivant crée une exception \codes{AucunChiffre} qui est lancée par la fonction \codes{conversion} lorsque la chaîne de caractères qu'elle doit convertir ne contient pas que des chiffres.
%
\vspaceneg\indexexemples{exception}{}
\begin{verbatimx}
class AucunChiffre (Exception) :
    """chaîne de caractères contenant aussi autre chose que des chiffres"""

def conversion (s) :
    """conversion d'une chaîne de caractères en entier"""
    if not s.isdigit () :
        raise AucunChiffre (s)
    return int (s)

try :
    s = "123a"
    print s, " = ", conversion (s)
except AucunChiffre, exc :
    # on affiche ici le commentaire associé à la classe d'exception
    # et le message associé
    print AucunChiffre.__doc__, " : ", exc
\end{verbatimx}
\vspaceneg

\begin{xremark}{exception et opérateur \codes{\_\_str\_\_}}
En redéfinissant l'opérateur \codes{\_\_str\_\_} d'une exception, il est possible d'afficher des messages plus explicites avec la seule instruction \codes{print}.\indexoperateur{\_\_str\_\_}
\vspaceneg
\begin{verbatimx}
class AucunChiffre (Exception) :
    """chaîne de caractères contenant aussi autre chose que des chiffres"""
    def __str__ (self) :
        return self.__doc__ + " " + Exception.__str__ (self)
\end{verbatimx}
\end{xremark}





\subsection{Personnalisation d'une classe d'exception}

Il est parfois utile qu'une exception contienne davantage d'informations qu'un simple message. L'exemple suivant reprend l'exemple du paragraphe précédent. L'exception \codes{AucunChiffre} inclut cette fois-ci un paramètre supplémentaire contenant le nom de la fonction où l'erreur a été déclenchée.

La classe \codes{AucunChiffre} possède dorénavant un constructeur qui doit recevoir deux paramètres~: une valeur et un nom de fonction. L'exception est levée à l'aide de l'instruction \codes{raise \; AucunChiffre \; (s, "conversion")} qui regroupe dans un T-uple les paramètres à envoyer à l'exception.

L'opérateur \codes{\_\_str\_\_} a été modifié de façon à ajouter ces deux informations dans le message associé à l'exception. Ainsi, l'instruction \codes{print \; exc} présente à l'avant dernière ligne de cet exemple affiche un message plus complet.
%
\vspaceneg\indexexemples{exception}{}
\begin{verbatimx}
class AucunChiffre (Exception) :
    """chaîne de caractères contenant aussi autre chose que des chiffres"""
    def __init__(self, s, f = "") :
        Exception.__init__(self, s)
        self.s = s
        self.f = f
    def __str__(self) :
        return """exception AucunChiffre, depuis la fonction """ + self.f + \
                  " avec le paramètre " + self.s

def conversion (s) :
    """conversion d'une chaîne de caractères en entier"""
    if not s.isdigit () :
        raise AucunChiffre (s, "conversion")
    return int (s)

try :
    s = "123a"
    i = conversion (s)
    print s, " = ", i
except AucunChiffre, exc :
    print exc
    print "fonction : ", exc.f
\end{verbatimx}
\vspaceneg

Etant donné que le programme déclenche une exception dans la section de code protégée, les deux derniers affichages sont les seuls exécutés correctement. Ils produisent les deux lignes qui suivent.
%
\vspaceneg
\begin{verbatimx}
exception AucunChiffre, depuis la fonction conversion avec le paramètre 123a
fonction :  conversion
\end{verbatimx}



\section{Exemples d'utilisation des exceptions}

\subsection{Les itérateurs}
\indexfr{itérateur}
\indexexception{StopIteration}

Les itérateurs sont des outils qui permettent de parcourir des objets qui sont des ensembles, comme une liste, un dictionnaire. Ils fonctionnent toujours de la même manière. L'exemple déjà présenté au paragraphe~\ref{chap_iterateur}, page~\pageref{chap_iterateur}) et repris en partie ici définit une classe contenant trois coordonnées, ainsi qu'un itérateur permettant de parcourir ces trois coordonnées. Arrivée à la troisième itération, l'exception \codes{StopIteration} est déclenchée. Cette exception indique à une boucle \codes{for} de s'arrêter. 
%
\vspaceneg\indexexemples{itérateur}{}
\begin{verbatimx}
class point_espace:
    
    #...
            
    class class_iter:
        def __init__ (self,ins):
            self._n   = 0
            self._ins = ins
        def __iter__ (self) : 
            return self
        def next (self):
            if self._n <= 2:
                v = self._ins [self._n]
                self._n += 1
                return v
            else :
                raise StopIteration
    
    def __iter__(self):
        return point_espace.class_iter (self)

# ...
\end{verbatimx}
\vspaceneg
%
Cet exemple montre seulement que les exceptions n'interviennent pas seulement lors d'erreurs mais font parfois partie intégrante d'un algorithme. 

\subsection{Exception ou valeur aberrante}

Sans exception, une solution pour indiquer un cas de mauvaise utilisation d'une fonction est de retourner une valeur aberrante. Retourner -1 pour une fonction dont le résultat est nécessairement positif est une valeur aberrante. Cette convention permet de signifier à celui qui appelle la fonction que son appel n'a pu être traité correctement. Dans l'exemple qui suit, la fonction \codes{racine\_carree} retourne un couple de résultats, \codes{True} ou \codes{False} pour savoir si le calcul est possible, suivi du résultat qui n'a un sens que si \codes{True} est retournée en première valeur.
%
\vspaceneg
\begin{verbatimx}
def racine_carree(x) :
    if x < 0 : return False, 0
    else : return True, x ** 0.5
print racine_carree (-1)  # (False, 0)
print racine_carree (1)   # (True, 1.0)
\end{verbatimx}
\vspaceneg
%
Plutôt que de compliquer le programme avec deux résultats ou une valeur aberrante, on préfère souvent déclencher une exception, ici, \codes{ValueError}. La plupart du temps, cette exception n'est pas déclenchée. Il est donc superflu de retourner un couple plutôt qu'une seule valeur.
%
\vspaceneg
\begin{verbatimx}
def racine_carree(x) :
    if x < 0 : raise ValueError ("valeur négative")
    return x ** 0.5
print racine_carree (-1)  # déclenche une exception
print racine_carree (1)
\end{verbatimx}

\subsection{Le piège des exceptions}
\indexfrr{exception}{piège}


Ce paragraphe évoque certains problèmes lorsqu'une exception est levée. L'exemple utilise les fichiers décrits au chapitre~\ref{chap_fichier}. Lorsqu'une exception est levée à l'intérieur d'une fonction, l'exécution de celle-ci s'interrompt. Si l'exception est attrapée, le programme continue sans problème~; les objets momentanément créés seront détruits par le garbage collector.\indexfr{garbage collector} Il faut pourtant faire attention dans le cas par exemple où l'exception est levée alors qu'un fichier est ouvert~: il ne sera pas fermé.

\vspaceneg
\inputcode{../python_cours/programme/fileex.py}{fichier ouvert et exception}
\vspaceneg
Les écritures dans le fichier se font en mode ajout (\codes{"a"}), le fichier \codes{"essai.txt"} contiendra tout ce qui aura été écrit.

\vspaceneg
\begin{center}\begin{tabular}{@{}lr@{}}
\begin{minipage}{6.7cm}
\begin{verbatimx}
-1/-2
0/-1
1/0
erreur avec i =  2 , float division
2/1
3/2
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{6.7cm}
\begin{verbatimx}
-1/-2= 0.5
0/-1= 0.0
2/1= 2.0
3/2= 1.5
1/0= 

\end{verbatimx}
\end{minipage}
\\ 
\textit{côté affichage} & \textit{côté fichier}
\end{tabular}
\end{center}
\vspaceneg

Il n'y pas de surprise du côté des affichages produit par l'instruction \codes{print}. \texttt{1/0} précède \texttt{2/1}. La différence vient de la dernière ligne du fichier qui intervient de façon surprenante en dernière position. Lorsque \texttt{y==0}, la fonction s'interrompt avant de fermer le fichier. C'est le garbage collector qui le fermera bien après l'appel suivant qui ouvre à nouveau le fichier pour écrire \texttt{2/1= 2.0}.






\firstpassagedo{
	\begin{thebibliography}{99}
	\input{python_cours_biblio.tex}
	\end{thebibliography}
}



\input{../../common/livre_table_end.tex}%
\input{../../common/livre_end.tex}%
