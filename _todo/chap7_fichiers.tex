

\section{Dates} \indexfr{dates}

Le module \codes{datetime}\footnote{Voir également la page~\httpstyle{http://docs.python.org/library/datetime.html}.}\indexmoduleint{datetime} fournit une classe \codes{datetime}\indexclass{datetime} qui permet de faire des opérations et des comparaisons sur les dates et les heures. L'exemple suivant calcule l'âge d'une personne née le 11~août~1975.
%
\vspaceneg
\indexexemples{dates}{}
\begin{verbatimx}
import datetime
naissance = datetime.datetime (1975,11,8,10,0,0)
jour = naissance.now () # obtient l'heure et la date actuelle
print jour              # affiche 2010-05-22 11:24:36.312000
age = jour - naissance  # calcule une différence
print age               # affiche 12614 days, 1:25:10.712000
\end{verbatimx}
\vspaceneg
%
L'objet \codes{datetime} autorise les soustractions et les comparaisons entre deux dates. Une soustraction retourne un objet de type \codes{timedelta} qui correspond à une durée.\indexclass{timedelta} qu'on peut multiplier par un réel ou ajouter à un objet de même type ou à un objet de type \codes{datetime}. L'utilisation de ce type d'objet évite de se pencher sur tous les problèmes de conversion.

Le module \codes{calendar}\indexmoduleint{calendar} est assez pratique pour construire des calendriers. Le programme ci-dessous affiche une liste de t-uples incluant le jour et le jour de la semaine du mois d'août 1975. Dans cette liste, on y trouve le t-uple \codes{(11,0)} qui signifie que le 11 août 1975 était un lundi. Cela permet de récupérer le jour de la semaine d'une date de naissance.\indexfr{date de naissance}
\vspaceneg
\indexexemples{date de naissance}{}
\begin{verbatimx}
import calendar
c = calendar.Calendar ()
for d in c.itermonthdays2 (1975,8) : print d
\end{verbatimx}

\section{Problème de jeux de caractères}\label{para_cosedescodes}
\indexfrr{chaîne de caractères}{encodage}\indexfr{jeu de caractères}

La langue anglaise est la langue dominante en ce qui concerne l'informatique mais cela n'empêche pas que des programmes anglais manipulent du japonais même si le nombre de caractères est beaucoup plus grand. Les jeux de caractères proposent une solution à ce problème~: un jeu de caractères définit la façon de décoder une suite d'octets\footnote{On confond souvent jeu de caractères et \textit{encodage}.\indexfr{encodage} Le jeu de caractère désigne l'ensemble de caractères dont le programme a besoin, l'encodage décrit la manière dont on passe d'une séquence de caractères français, japonais, anglais à une séquence d'octets qui est la seule information manipulée par un ordinateur.}. Les langues latines n'ont besoin que d'un octet pour coder un caractère, les langues asiatiques en ont besoin de plusieurs. Il n'existe pas qu'un seul jeu de caractères lorsqu'on programme. Ils interviennent à plusieurs endroits différents~:\indexfrr{jeu de caractères}{ascii}\indexfrr{jeu de caractères}{cp1252}\indexfrr{jeu de caractères}{utf-8}\indexfrr{jeu de caractères}{unicode}

\begin{small}
\begin{enumerate}
\item Le jeu de caractères utilisé par l'éditeur de texte pour afficher le programme.
\item Le jeu de caractères du programme, par défaut \codesmall{ascii} mais il peut être changé en insérant une première ligne de commentaire (voir paragraphe~\ref{par_intro_accent_code}, page~\pageref{par_intro_accent_code}). Les chaînes de caractères du programme sont codées avec ce jeu de caractères. Ce jeu devrait être identique à celui utilisé par l'éditeur de texte afin d'éviter les erreurs.\indexfr{ascii}\indexfrr{jeu de caractères}{ascii}
\item Le jeu de caractères de la sortie, utilisé pour chaque instruction \codesmall{print}, il est désigné par le code \codesmall{cp1252} sur un système \codesmall{Windows}.\indexfrr{jeu de caractères}{cp1252}
\item Le jeu de caractères dans lequel les chaînes de caractères sont manipulées. Un jeu standard qui permet de représenter toutes les langues est le jeu de caractères \codesmall{utf-8}. Il peut être différent pour chaque variable.\indexfr{utf-8}\indexfrr{jeu de caractères}{cp1252}
\item Le jeu de caractères d'un fichier texte. Il peut être différent pour chaque fichier.
\end{enumerate}
\end{small}

Le langage \pythons offre deux classes pour représenter les chaînes de caractères. La classe \codes{str} qui est adaptée aux langues latines, le jeu de caractères n'est pas précisé. La classe \codes{unicode} représente un caractère sur un à quatre octets avec un jeu de caractères désigné par l'appellation \codes{unicode}.\indexfr{unicode}\indexfrr{jeu de caractères}{unicode} Il est impératif de savoir quel jeu est utilisé à quel endroit et il faut faire des conversions de jeux de caractères pour passer l'information d'un endroit à un autre. Il existe deux méthodes pour cela présentées par la table~\ref{string_method2_encode_decode}.
\vspaceneg\indexfrr{jeu de caractères}{latin-1}\indexfrr{chaîne de caractères}{préfixe \codesindex{u}}\indexfr{accent}
\indexexemples{jeu de caractères}{}
\begin{verbatimx}
# coding: latin-1
st =  "eé"
su = u"eé"  # raccourci pour su = unicode ("eé", "latin-1")
            # ou encore      su = unicode ("eé".decode ("latin-1"))
            
print type (st)                                    # affiche <type 'str'>
print type (su)                                    # affiche <type 'unicode'>
print len (st),        ";", st                     # affiche  2 ; eé
print len (repr (st)), ";", repr (st)              # affiche  7 ; 'e\xe9'
print len (su),        ";", su.encode ("latin-1")  # affiche  2 ; eé
print len (repr (su)), ";", repr (su)              # affiche  8 ; u'e\xe9'
\end{verbatimx}
\vspaceneg
Lorsqu'on manipule plusieurs jeux de caractères, il est préférable de conserver un unique jeu de référence pour le programme par l'intermédiaire de la classe \codes{unicode}. Il "suffit" de gérer les conversions depuis ces chaînes de caractères vers les entrées sorties du programme comme les fichiers texte. Par défaut, ceux-ci sont écrits avec le jeu de caractères du système d'exploitation. Dans ce cas, la fonction \codes{open} suffit. En revanche, si le jeu de caractères est différent, il convient de le préciser lors de l'ouverture du fichier. On utilise la fonction \codes{open} du module \codes{codecs} qui prend comme paramètre supplémentaire le jeu de caractères du fichier. Toutes les chaînes de caractères seront lues et converties au format \codes{unicode}. \indexmoduleint{codecs}\indexfonction{open}
\vspaceneg
\indexexemples{jeu de caractères}{, fichier}
\begin{verbatimx}
import codecs
f = codecs.open ("essai.txt", "r", "cp1252")  # jeu Windows
s = "".join (f.readlines ())
f.close ()
print type (s)              # affiche <type 'unicode'>
print s.encode ("cp1252")   # pour l'afficher, 
                            # il faut convertir l'unicode en "cp1252"
\end{verbatimx}
\vspaceneg


        \begin{table}[ht]
        \begin{center}\begin{tabularx}
        				{\textwidth}{|lX|} \hline
        				%{|lp{10cm}|} \hline
        \begin{tabular}{@{}l} \codes{encode( } \\ \codes{	\; [enc[,err]])} \end{tabular} &  
        			Cette fonction permet de passer d'un jeu de caractères, celui de la variable, au jeu de caractères 
        			précisé par \codes{enc} à moins 
        			que ce ne soit le jeu de caractères par défaut. Le paramètre \codes{err} permet de préciser comment gérer 
        			les erreurs, doit-on interrompre le programme (valeur \codes{'strict'}) ou les ignorer (valeur \codes{'ignore'}). 
        			La documentation
        			\pythons recense toutes les valeurs possibles pour ces deux paramètres aux adresses 
        			\httpstyle{http://docs.python.org/library/codecs.html\#id3} et 
        			\httpstyle{http://docs.python.org/library/stdtypes.html\#id4}. Cette fonction retourne un résultat de type \codes{str}.
   																								\\ \hline
        \begin{tabular}{@{}l} \codes{decode(} \\ \codes{\;[enc[, err]])} \\ \end{tabular} &  
        		Cette fonction est la fonction inverse de la fonction \codes{encode}. 
        		Avec les mêmes paramètres, elle effectue la transformation inverse.
					%        				
   																								\\ \hline
        \end{tabularx}\end{center}
        \caption{ Conversion de jeux de caractères, ce sont deux méthodes qui fonctionnent de façons identiques
        					pour les deux classes de chaînes de caractères disponibles en \python~:  \codescaption{str} et \codescaption{unicode}.
        					\indexclass{str}\indexclass{unicode}\indexfonction{str}\indexfonction{unicode}
        					}
        \label{string_method2_encode_decode}
        \indexfonction{encode}\indexfonction{decode}
        \end{table}                            


Le programme suivant permet d'obtenir le jeu de caractères par défaut et celui du système d'exploitation.
\vspaceneg
\indexexemples{jeu de caractères}{}
\begin{verbatimx}
import sys
import locale
             # retourne le jeu de caractères par défaut
print sys.getdefaultencoding ()    # affiche ascii
             # retourne le jeu de caractères du système d'exploitation
print locale.getdefaultlocale()    # affiche ('fr_FR', 'cp1252')
\end{verbatimx}
\vspaceneg
Les problèmes de jeux de caractères peuvent devenir vite compliqués lorsqu'on manipule des informations provenant de plusieurs langues différentes. Il est rare d'avoir à s'en soucier tant que le programme gère les langues anglaise et française. Dans le cas contraire, il est préférable d'utiliser le type \codes{unicode} pour toutes les chaînes de caractères. Il est conseillé de n'utiliser qu'un seul jeu de caractères pour enregistrer les informations dans des fichiers et le jeu de caractères \codes{utf-8} est le plus indiqué.\indexfrr{jeu de caractères}{utf-8}





\firstpassagedo{
	\begin{thebibliography}{99}
	\input{python_cours_biblio.tex}
	\end{thebibliography}
}



\input{../../common/livre_table_end.tex}%
\input{../../common/livre_end.tex}%