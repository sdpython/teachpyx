\input{../../common/livre_begin.tex}%
\firstpassagedo{\input{python_cours_titre.tex}}
\input{../../common/livre_table_begin.tex}%
%\firstpassagedo{\input{python_cours_chapter.tex}}








%-------------------------------------------------------------------------------------------------------------
\chapter{Fichiers, expressions régulières, dates}
\label{chap_fichier}
%-------------------------------------------------------------------------------------------------------------
\indexfr{fichier}

Lorsqu'un programme termine son exécution, toutes les informations stockées dans des variables sont perdues. Un moyen de les conserver est de les enregistrer dans un fichier sur disque dur. A l'intérieur de celui-ci, ces informations peuvent apparaître sous un format texte qui est lisible par n'importe quel éditeur de texte, dans un format compressé, ou sous un autre format connu par le concepteur du programme. On appelle ce dernier type un format binaire, il est adéquat lorsque les données à conserver sont très nombreuses ou lorsqu'on désire que celles-ci ne puissent pas être lues par une autre application que le programme lui-même. En d'autres termes, le format binaire est illisible excepté pour celui qui l'a conçu. 

Ce chapitre abordera pour commencer les formats texte, binaire et compressé (\textit{zip}) directement manipulable depuis \python. Les manipulations de fichiers suivront pour terminer sur les expressions régulières qui sont très utilisées pour effectuer des recherches textuelles. A l'issue de ce chapitre, on peut envisager la recherche à l'intérieur de tous les documents textes présents sur l'ordinateur, de dates particulières, de tous les numéros de téléphones commençant par 06... En utilisant des modules tels que \codes{reportlab}\footnote{\httpstyle{http://www.reportlab.com/software/opensource/rl-toolkit/}}\indexmoduleext{reportlab} ou encore \codes{win32com}\footnote{\httpstyle{http://python.net/crew/mhammond/win32/Downloads.html}}, il serait possible d'étendre cette fonctionnalité aux fichiers de type \textit{pdf} et aux fichiers \textit{Microsoft Word, Excel}.  \indexmoduleext{win32com}

\vspaceneg

\section{Format texte} 
\indexfrr{format}{texte}

Les fichiers texte sont les plus simples~: ce sont des suites de caractères. Le format \textit{HTML} et \textit{XML} font partie de cette catégorie. Ils servent autant à conserver des informations qu'à en échanger comme par exemple transmettre une matrice à \textit{Microsoft Excel}. 

Ce format, même s'il est simple, implique une certaine organisation dans la façon de conserver les données afin de pouvoir les récupérer. Le cas le plus fréquent est l'enregistrement d'une matrice~: on choisira d'écrire les nombres les uns à la suite des autres en choisissant un séparateur de colonnes et un séparateur de lignes. Ce point sera abordé à la fin de cette section.

\subsection{Ecriture}

La première étape est l'écriture. Les informations sont toujours écrites sous forme de chaînes de caractères et toujours ajoutées à la fin du fichier qui s'allonge jusqu'à ce que toutes les informations y soient écrites. L'écriture s'effectue toujours selon le même schéma.

\indexfrr{fichier}{ouverture}\indexfrr{fichier}{fermeture}\indexfrr{fichier}{écriture}
\begin{small}
\begin{enumerate}
\item création ou ouverture du fichier,
\item écriture,
\item fermeture.
\end{enumerate}
\end{small}


Lors de l'ouverture, le fichier dans lequel seront écrites les informations est créé s'il n'existe pas ou nettoyé s'il existe déjà. La fermeture permet à d'autres programmes de lire ce que vous avez placé dans ce fichier. Sans cette dernière étape, il sera impossible d'y accéder à nouveau pour le lire ou y écrire à nouveau. A l'intérieur d'un programme informatique, écrire dans un fichier suit toujours le même schéma~:
\vspaceneg
\begin{verbatimx}
f = open ("nom-fichier", "w")    # ouverture

f.write ( s )    # écriture de la chaîne de caractères  s 
f.write ( s2 )   # écriture de la chaîne de caractères  s2
...

f.close ()  # fermeture
\end{verbatimx}
\vspaceneg
Les étapes d'ouverture et de fermeture sont toujours présentes en ce qui concerne les fichiers. Il s'agit d'indiquer au système d'exploitation que le programme souhaite accéder à un fichier et interdire à tout autre programme l'accès à ce fichier. Un autre programme qui souhaiterait créer un fichier du même nom ne le pourrait pas tant que l'étape de fermeture n'est pas exécutée. En revanche, il pourrait tout à fait le lire car la lecture ne perturbe pas l'écriture. 

\begin{xremark}{fichiers ouverts et non fermés}
Lorsque que le programme se termine, même s'il reste des fichiers "ouverts" pour lesquels la méthode \codes{close} n'a pas été appelée, ils seront automatiquement fermés.
\end{xremark}

\indexoutil{Excel}
Certains caractères sont fort utiles lors de l'écriture de fichiers texte afin d'organiser les données. Le symbole \codes{;} est très utilisé comme séparateur de colonnes pour une matrice, on utilise également le passage à la ligne ou la tabulation. Comme ce ne sont pas des caractères "visibles", ils ont des codes~:
\begin{center}
\begin{tabularx}{\textwidth}{lX@{}}
\begin{tabular}{l}\codes{\backslash n} \end{tabular} & passage à la ligne \\
\begin{tabular}{l}\codes{\backslash t} \\ ~ \end{tabular} & insertion d'une tabulation, indique un passage à la colonne suivante dans le logiciel \textit{Microsoft Excel}\indexoutil{Excel}
\end{tabularx}
\end{center}

Il existe peu de manières différentes de conserver une matrice dans un fichier, le programme ressemble dans presque tous les cas à celui qui suit~: \indexfrr{matrice}{écriture}\label{matrice_excel_iopeniffice}
\vspaceneg
\indexexemples{matrice}{, écriture}
\begin{verbatimx}
mat =  ... # matrice de type liste de listes
f = open ("mat.txt", "w")
for i in range (0,len (mat)) :                # la fonction join est aussi
    for j in range (0, len (mat [i])) :       # fréquemment utilisée
        f.write ( str (mat [i][j]) + "\t")    # pour assembler les chaînes
    f.write ("\n")                            # un une seule et réduire le
f.close ()                                    # nombre d'appels à f.write
\end{verbatimx}
\vspaceneg

\begin{xremark}{fonction \codes{open}}
La fonction \codes{open} accepte deux paramètres, le premier est le nom du fichier, le second définit le mode d'ouverture~: \codes{"w"} pour écrire (\textbf{w}rite), "a" pour écrire et ajouter (\textbf{a}ppend), "r" pour lire (\textbf{r}ead). Ceci signifie que la fonction \codes{open} sert à ouvrir un fichier quelque soit l'utilisation qu'on en fait. \indexfonction{open}
\end{xremark}

\begin{xremark}{autre syntaxe avec \codes{print}}
Il existe une autre syntaxe qui permet de remplacer la méthode \codes{write}. Elle utilise la même syntaxe que celle de l'instruction \codes{print} et fonctionne de la même manière à ceci près qu'elle ajoute \texttt{>}\texttt{> f,} entre le mot-clé \codes{print} et le texte à écrire dans le fichier~\codes{f}. Néanmoins, ce n'est pas cette syntaxe qui sera mise en avant dans les versions futures de \python. \indexfrr{fichier}{\codesindex{print}}\indexkeyword{print}\indexfrr{matrice}{écriture}
\vspaceneg
\indexexemples{matrice}{, écriture}\indexkeyword{print}
\begin{verbatimx}
mat = ... # matrice de type liste de listes
f = open ("mat.txt", "w")
for i in range (0,len (mat)) :
    for j in range (0, len (mat [i])) :
        print >> f, str (mat [i][j]), "\t",  # ligne changée
    print >> f                               # ligne changée
f.close ()
\end{verbatimx}
\end{xremark}

\begin{xremark}{écriture différée}
A la première écriture dans un fichier (premier appel à la fonction \codes{write}), la taille du fichier créée est souvent nulle. L'écriture dans un fichier n'est pas immédiate, le langage \pythons attend d'avoir reçu beaucoup d'informations avant de les écrire physiquement sur le disque dur.\indexfrr{fichier}{buffer}\indexfrr{fichier}{tampon} Les informations sont placées dans un tampon ou \textit{buffer}. Lorsque le tampon est plein, il est écrit sur disque dur. Pour éviter ce délai, il faut soit fermer puis réouvrir le fichier soit appeler la méthode \codes{flush} qui ne prend aucun paramètre. Ce mécanisme vise à réduire le nombre d'accès au disque dur, il n'est pas beaucoup plus long d'y écrire un caractère plutôt que 1000 en une fois.\indexfonction{flush}
\end{xremark}



\subsection{Ecriture en mode "ajout"}
\indexfrr{fichier}{écriture, ajout}

Lorsqu'on écrit des informations dans un fichier, deux cas se présentent. Le premier consiste à ne pas tenir compte du précédent contenu de ce fichier lors de son ouverture pour écriture et à l'écraser. C'est le cas traité par le précédent paragraphe. Le second cas consiste à ajouter toute nouvelle information à celles déjà présentes lors de l'ouverture du fichier. Ce second cas est presque identique au suivant hormis la première ligne qui change~:
%
\vspaceneg
\begin{verbatimx}
f = open ("nom-fichier", "a")    # ouverture en mode ajout, mode "a"
...
\end{verbatimx}
\vspaceneg
%
Pour comprendre la différence entre ces deux modes d'ouverture, voici deux programmes. Celui de gauche n'utilise pas le mode ajout tandis que celui de droite l'utilise lors de la seconde ouverture.
%
\indexexemples{fichier}{, écriture}
\vspaceneg
\begin{center}\begin{tabular}{@{}lr@{}}
\begin{minipage}{5.7cm}
\begin{verbatimx}
f = open ("essai.txt", "w")
f.write (" premiere fois ")
f.close ()
f = open ("essai.txt", "w")
f.write (" seconde fois ")
f.close ()

# essai.txt : seconde fois 
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{7.7cm}
\begin{verbatimx}
f = open ("essai.txt", "w")
f.write (" premiere fois ")
f.close ()
f = open ("essai.txt", "a")  ###
f.write (" seconde fois ")
f.close ()

# essai.txt : premiere fois  seconde fois 
\end{verbatimx}
\end{minipage}
\end{tabular}
\end{center}
\vspaceneg
%
Le premier programme crée un fichier \codes{"essai.txt"} qui ne contient que les informations écrites lors de la seconde phase d'écriture, soit \codes{seconde\;fois}. Le second utilise le mode ajout lors de la seconde ouverture. Le fichier \codes{"essai.txt"}, même s'il existait avant l'exécution de ce programme, est effacé puis rempli avec l'information \codes{premiere\;fois}. Lors de la seconde ouverture, en mode ajout, une seconde chaîne de caractères est ajoutée. le fichier \codes{"essai.txt"}, après l'exécution du programme contient donc le message~: \codes{premiere\;fois\;seconde\;fois}.

\begin{xremark}{fichier de traces}
Un des moyens pour comprendre ou suivre l'évolution d'un programme est d'écrire des informations dans un fichier ouvert en mode ajout qui est ouvert et fermé sans cesse.\indexfrr{fichier}{trace}\indexfr{traces} Ce sont des fichiers de \textit{traces} ou de \textit{log}.\indexfrr{fichier}{logs}\indexfr{logs} Ils sont souvent utilisés pour vérifier des calculs complexes. Ils permettent par exemple de comparer deux versions différentes d'un programme pour trouver à quel endroit ils commencent à diverger.
\end{xremark}

\subsection{Lecture}

La lecture d'un fichier permet de retrouver les informations stockées grâce à une étape préalable d'écriture. Elle se déroule selon le même principe, à savoir~:
%
\indexfrr{fichier}{ouverture}\indexfrr{fichier}{fermeture}\indexfrr{fichier}{lecture}
\begin{small}
\begin{enumerate}
\item ouverture du fichier en mode lecture,
\item lecture,
\item fermeture.
\end{enumerate}
\end{small}
%
Une différence apparaît cependant lors de la lecture d'un fichier~: celle-ci s'effectue ligne par ligne alors que l'écriture ne suit pas forcément un découpage en ligne. Les instructions à écrire pour lire un fichier diffèrent rarement du schéma qui suit où seule la ligne indiquée par \codes{(*)} change en fonction ce qu'il faut faire avec les informations lues.
%
\indexexemples{fichier}{, lecture}
\vspaceneg
\begin{verbatimx}
f = open ("essai.txt", "r")  # ouverture du fichier en mode lecture
for ligne in f :             # pour toutes les lignes du fichier
    print ligne              # on affiche la ligne (*)
f.close ()                   # on ferme le fichier
\end{verbatimx}
\vspaceneg
%
Pour des fichiers qui ne sont pas trop gros (< 100000 lignes), il est possible d'utiliser la méthode \codes{readlines} qui récupère toutes les lignes d'un fichier texte en une seule fois. Le programme suivant donne le même résultat que le précédent.
%
\vspaceneg
\indexexemples{fichier}{, lecture}
\begin{verbatimx}
f = open ("essai.txt", "r") # ouverture du fichier en mode lecture
l = f.readlines ()          # lecture de toutes les lignes, placées dans une liste
f.close ()                  # fermeture du fichier

for s in l : print s        # on affiche les lignes à l'écran (*)
\end{verbatimx}
\vspaceneg
%

\begin{xremark}{code de fin de ligne}
Lorsque le programme précédent lit une ligne dans un fichier, le résultat lu inclut le ou les caractères (\codes{\backslash n \; \backslash r}) qui marquent la fin d'une ligne. C'est pour cela que la lecture est parfois suivie d'une étape de nettoyage. \indexfrr{fichier}{fin de ligne}
%
\indexexemples{matrice}{, écriture}
\vspaceneg
\indexexemples{fichier}{, lecture}
\begin{verbatimx}
f = open ("essai.txt", "r") # ouverture du fichier en mode lecture
l = f.readlines ()          # lecture de toutes les lignes, placées dans une liste
f.close ()                  # fermeture du fichier

     # contiendra la liste des lignes nettoyées
l_net = [ s.strip ("\n\r") for s in l ] 
\end{verbatimx}
\end{xremark}
%
\vspaceneg
Les informations peuvent être structurées de façon plus élaborée dans un fichier texte, c'est le cas des formats \textit{HTML} ou \textit{XML}. Pour ce type de format plus complexe, il est déconseillé de concevoir soi-même un programme capable de les lire, il existe presque toujours un module qui permette de le faire. C'est le cas du module \codes{HTMLParser}\indexmoduleint{HTMLParser} pour le format~\textit{HTML} ou \codes{xml.sax}\indexmoduleint{xml.sax} pour le format~\textit{XML}. De plus, les modules sont régulièrement mis à jour et suivent l'évolution des formats qu'ils décryptent.

Un fichier texte est le moyen le plus simple d'échanger des matrices avec un tableur et il n'est pas besoin de modules dans ce cas. Lorsqu'on enregistre une feuille de calcul sous format texte, le fichier obtenu est organisé en colonnes~: sur une même ligne, les informations sont disposées en colonne délimitées par un séparateur qui est souvent une tabulation (\codes{\backslash t}) ou un point virgule comme dans l'exemple suivant~:
%
\indexexemples{matrice}{, lecture}
\vspaceneg
\begin{verbatimx}
nom  ; prénom ; livre
Hugo  ; Victor  ; Les misérables
Kessel ; Joseph  ; Le lion
Woolf ; Virginia  ; Mrs Dalloway
Calvino ; Italo  ; Le baron perché
\end{verbatimx}
\vspaceneg
%
Pour lire ce fichier, il est nécessaire de scinder chaque ligne en une liste de chaînes de caractères, on utilise pour cela la méthode \codes{split} des chaînes de caractères. \indexfrr{matrice}{lecture}
%
\vspaceneg
\begin{verbatimx}
mat = []                      # création d'une liste vide,
f = open ("essai.txt", "r")   # ouverture du fichier en mode lecture
for li in f :                 # pour toutes les lignes du fichier
    s = li.strip ("\n\r")     # on enlève les caractères de fin de ligne
    l = s.split (";")         # on découpe en colonnes
    mat.append (l)            # on ajoute la ligne à la matrice
f.close ()                    # fermeture du fichier
\end{verbatimx}
\vspaceneg
%
Ce format de fichier texte est appelé \textit{CSV}\footnote{Comma Separated Value},\indexfr{CSV}\indexfrr{format}{CSV} il peut être relu depuis un programme \pythons comme le montre l'exemple précédent ou être chargé depuis \textit{Microsoft Excel}\indexoutil{Excel} en précisant que le format du fichier est le format \textit{CSV}. Pour les valeurs numériques, il ne faut pas oublier de convertir en caractères lors de l'écriture et de convertir en nombres lors de la lecture.

\begin{xremark}{nombres français et anglais}
Les nombres réels s'écrivent en anglais avec un point pour séparer la partie entière de la partie décimale. En français, il s'agit d'une virgule. Il est possible que, lors de la conversion d'une matrice, il faille remplacer les points par des virgules et réciproquement pour éviter les problèmes de conversion.
\end{xremark}



\section{Fichiers zip}
\indexfrr{fichier}{zip}\indexoutil{WinZip}\indexclass{ZipFile}\indexext{zip}\indexfrr{format}{zip}

Les fichiers \textit{zip} sont très répandus de nos jours et constituent un standard de compression facile d'accès quelque soit l'ordinateur et son système d'exploitation. Le langage \pythons propose quelques fonctions pour compresser et décompresser ces fichiers par l'intermédiaire du module \codes{zipfile}. \indexmoduleint{zipfile} Le format de compression \textit{zip} est un des plus répandus bien qu'il ne soit pas le plus performant\footnote{D'autres formats proposent de meilleurs taux de compressions sur les fichiers textes existent, voir \httpstyle{http://www.7-zip.org/}.}. Ce format n'est pas seulement utilisé pour compresser mais aussi comme un moyen de regrouper plusieurs fichiers en un seul.

\subsection{Lecture}

L'exemple suivant permet par exemple d'obtenir la liste des fichiers inclus dans un fichier \textit{zip}~:

\indexexemples{fichier zip}{}
\vspaceneg
\begin{verbatimx}
import zipfile
file = zipfile.ZipFile ("exemplezip.zip", "r")
for info in file.infolist () :
    print info.filename, info.date_time, info.file_size
file.close ()
\end{verbatimx}
\vspaceneg
%
Les fichiers compressés ne sont pas forcément des fichiers textes mais de tout format. Le programme suivant extrait un fichier parmi ceux qui ont été compressés puis affiche son contenu (on suppose que le fichier lu est au format texte donc lisible).\indexmethod{read}
\vspaceneg
\indexexemples{fichier zip}{}
\begin{verbatimx}
import zipfile
file = zipfile.ZipFile ("exemplezip.zip", "r")
data = file.read ("informatique/testzip.py")
file.close ()
print data
\end{verbatimx}
\vspaceneg
%
On retrouve dans ce cas les étapes d'ouverture et de fermeture même si la première est implicitement inclus dans le constructeur de la classe \codes{ZipFile}.

\subsection{Ecriture}

Pour créer un fichier \textit{zip}, le procédé ressemble à la création de n'importe quel fichier. La seule différence provient du fait qu'il est possible de stocker le fichier à compresser sous un autre nom à l'intérieur du fichier \textit{zip}, ce qui explique les deux premiers arguments de la méthode \codes{write}. Le troisième paramètre indique si le fichier doit être compressé (\codes{zipfile.ZIP\_DEFLATED}) ou non (\codes{zipfile.ZIP\_STORED}). \indexmethod{write}\indexmethod{close}
%
\vspaceneg
\indexexemples{fichier zip}{}
\begin{verbatimx}
import zipfile
file = zipfile.ZipFile ("test.zip", "w")
file.write ("fichier.txt", "nom_fichier_dans_zip.txt", zipfile.ZIP_DEFLATED)
file.close ()
\end{verbatimx}
\vspaceneg
%
%On pourrait imaginer l'envoi de mail automatique
Une utilisation possible de ce procédé serait l'envoi automatique d'un mail contenant un fichier \codes{zip} en pièce jointe.\indexfr{mail}\indexfr{pièce jointe} Une requête comme \textit{python} précédant le nom de votre serveur de mail permettra, via un moteur de recherche, de trouver des exemples sur Internet.

\ifnotellipse{
\indexfrr{mail}{envoi automatique}
Selon les serveurs de mails, le programme permettant d'envoyer automatiquement un mail en \pythons peut varier. L'exemple suivant permet d'envoyer un email automatiquement via un serveur de mails, il montre aussi comment attacher des pièces jointes. Il faut bien sûr être autorisé à se connecter. De plus, il est possible que l'exécution de ce programme ne soit pas toujours couronnée de succès si le mail est envoyé plusieurs fois à répétition, ce comportement est en effet proche de celui d'un spammeur.\indexfr{spammeur}
\inputcode{../python_cours/programme/mail.py}{envoi d'un mail automatiquement}
}

\section{Manipulation de fichiers}
\indexfr{arborescence}\indexfrr{fichier}{arborescence}

Il arrive fréquemment de copier, recopier, déplacer, effacer des fichiers. Lorsqu'il s'agit de quelques fichiers, le faire manuellement ne pose pas de problème. Lorsqu'il s'agit de traiter plusieurs centaines de fichiers, il est préférable d'écrire un programme qui s'occupe de le faire automatiquement. Cela peut être la création automatique d'un fichier \codes{zip} incluant tous les fichiers modifiés durant la journée ou la réorganisation de fichiers musicaux au format \codes{mp3} à l'aide de modules complémentaires tel que \codes{mutagen}\footnote{\httpstyle{http://code.google.com/p/mutagen/}} ou \codes{pymedia}\footnote{\httpstyle{http://pymedia.org/}}. \indexmoduleext{mutagen}\ifnotellipse{\indexmoduleext{pymedia}}

\begin{xremark}{majuscules et minuscules}
Pour ceux qui ne sont pas familiers des systèmes d'exploitation, il faut noter que \textit{Windows} ne fait pas de différences entre les majuscules et les minuscules à l'intérieur d'un nom de fichier. Les systèmes \textit{Linux} et \textit{Mac~OS~X} font cette différence\footnote{Ceci explique que certains programmes aient des comportements différents selon le système d'exploitation sur lequel ils sont exécutés ou encore que certains liens Internet vers des fichiers ne débouchent sur rien car ils ont été saisis avec des différences au niveau des minuscules majuscules.}.
\end{xremark}

\subsection{Gestion des noms de chemins}

Le module \codes{os.path}\indexmoduleint{os.path} propose plusieurs fonctions très utiles qui permettent entre autres de tester l'existence d'un fichier, d'un répertoire, de récupérer diverses informations comme sa date de création, sa taille... Cette liste présentée par la table~\ref{fonctionnnalite_os_path_table} est loin d'être exhaustive mais elle donne une idée de ce qu'il est possible de faire. 

\begin{table}
\begin{center}\begin{tabularx}{\textwidth}{|l|X|} \hline
\codes{abspath(path)} 			& Retourne le chemin absolu d'un fichier ou d'un répertoire. \indexfrr{fichier}{chemin absolu}\indexfr{chemin relatif, absolu}\\ \hline
\codes{commonprefix(list)} 	& Retourne le plus grand préfixe commun à un ensemble de chemins. \\ \hline
\codes{dirname(path)}				& Retourne le nom du répertoire. \\ \hline
\codes{exists(path)}				& Dit si un chemin est valide ou non. \\ \hline
\begin{tabular}{@{}l}
\codes{getatime(path)} \\
\codes{getmtime(path)} \\
\codes{getctime(path)} 
\end{tabular}  							& Retourne diverses dates concernant un chemin, date du dernier accès (\codes{getatime}), date de la dernière modification (\codes{getmtime}), date de création (\codes{getctime}). \\ \hline
\codes{getsize(file)}				& Retourne la taille d'un fichier. \\ \hline
\codes{isabs(path)}					& Retourne \codes{True} si le chemin est un chemin absolu. \\ \hline
\codes{isfile(path)}				& Retourne \codes{True} si le chemin fait référence à un fichier. \\ \hline
\codes{isdir(path)}					& Retourne \codes{True} si le chemin fait référence à un répertoire. \\ \hline
\codes{join(p1, p2, ...)}		& Construit un nom de chemin étant donné une liste de répertoires. \\ \hline
\codes{split(path)}					& Découpe un chemin, isole le nom du fichier ou le dernier répertoire des autres répertoires. \\ \hline
\codes{splitext(path)}		  & Découpe un chemin en nom + extension. \\ \hline
\end{tabularx}\end{center}
\caption{Liste non exhaustive des fonctionnalités offertes par le module \codescaption{os.path}. La page \httpstyle{http://docs.python.org/library/os.path.html} référence toutes les fonctions de ce module.}
\indexfonction{getsize}\indexfonction{isabs}\indexfonction{abspath}\indexfonction{commonprefix}\indexfonction{dirname}\indexfonction{exists}\indexfonction{getatime}\indexfonction{getmtime}\indexfonction{getctime}\indexfonction{isfile}\indexfonction{isdir}\indexfonction{join}\indexfonction{split}\indexfonction{splitext}\indexmoduleint{os.path}
\label{fonctionnnalite_os_path_table}
\end{table}



\subsection{Copie, suppression}
\indexfrr{fichier}{copie}\indexfrr{fichier}{suppression}\indexfr{répertoire}
Le module \codes{shutil}\indexmoduleint{shutil} permet de copier des fichiers, le module \codes{os}\indexmoduleint{os} permet de les supprimer ou de les renommer, il permet également de créer ou de supprimer des répertoires. Ces opérations sont regroupées dans la table~\ref{fonctionnalite_modules_shutil_os_table}.
%
\begin{table}
\begin{center}\begin{tabularx}{\textwidth}{|l|X|} \hline
\codes{copy (f1,f2)} & (module \codes{shutil}) Copie le fichier \codes{f1} vers \codes{f2} \\ \hline
\codes{chdir (p)}			& (module \codes{os}) Change le répertoire courant, cette fonction peut être importante lorsqu'on utilise la fonction \codes{system} du module \codes{os} pour lancer une instruction en ligne de commande ou lorsqu'on écrit un fichier sans préciser le nom du répertoire, le fichier sera écrit dans ce répertoire courant qui est par défaut le répertoire où est situé le programme \python. C'est à partir du répertoire courant que sont définis les chemins relatifs.\\ \hline \indexfr{chemin relatif, absolu}
\codes{getcwd ()}		& (module \codes{os}) Retourne le répertoire courant, voir la fonction \codes{chdir}. \\ \hline
\codes{mkdir (p)}	& (module \codes{os}) Crée le répertoire \codes{p}. \\ \hline
\codes{makedirs (p)}	& (module \codes{os}) Crée le répertoire \codes{p} et tous les répertoires des niveaux supérieurs s'ils n'existent pas. Dans le cas du répertoire \codes{d:/base/repfinal}, crée d'abord \codes{d:/base} s'il n'existe pas, puis \codes{d:/base/repfinal}. \\ \hline
\codes{remove (f)}		& (module \codes{os}) Supprime un fichier. \\ \hline
\codes{rename (f1,f2)}		& (module \codes{os}) Renomme un fichier \\ \hline
\codes{rmdir (p)}			& (module \codes{os}) Supprime un répertoire \\ \hline
\end{tabularx}\end{center} 
\caption{Liste non exhaustive des fonctionnalités offertes par les modules \codescaption{shutil} et \codescaption{os}. Les page \httpstyle{http://docs.python.org/library/shutil.html} et \httpstyle{http://docs.python.org/library/os.html} référencent toutes les fonctions de ces modules.}
\indexfonction{copy}\indexfonction{chdir}\indexfonction{getcwd}\indexfonction{mkdir}\indexfonction{makedirs}\indexfonction{remove}\indexfonction{rename}\indexfonction{rmdir}\indexmoduleint{shutil}\indexmoduleint{os}
\label{fonctionnalite_modules_shutil_os_table}
\end{table}

\subsection{Liste de fichiers}

La fonction \codes{listdir} du module \codes{os}\indexfonction{listdir}\indexmoduleint{os} permet de retourner les listes des éléments inclus dans un répertoire (fichiers et sous-répertoires). Toutefois, le module \codes{glob}\indexmoduleint{glob} propose une fonction plus intéressante qui permet de retourner la liste des éléments d'un répertoire en appliquant un filtre. Le programme suivant permet par exemple de retourner la liste des fichiers et des répertoires inclus dans un répertoire. \label{liste_de_fichier_glob}
%
\vspaceneg
\inputcodes{../python_cours/programme/filelist.py}{liste de fichiers}{ (1)}
\vspaceneg
%
Le programme repose sur l'utilisation d'une fonction récursive\indexfrr{fonction}{récursive} qui explore d'abord le premier répertoire. Elle se contente d'ajouter à une liste les fichiers qu'elle découvre puis cette fonction s'appelle elle-même sur le premier sous-répertoire qu'elle rencontre.
%
La fonction \codes{walk}\indexfonction{walk}\indexmoduleint{os} permet d'obtenir la liste des fichiers et des sous-répertoire. Cette fonction parcourt automatiquement les sous-répertoires inclus, le programme est plus court mais elle ne prend pas en compte le filtre qui peut être alors pris en compte grâce aux expressions régulières (paragraphe~\ref{regex_label_chap}).
%
\vspaceneg
\inputcodes{../python_cours/programme/filelist2.py}{liste de fichiers}{ (2)}
\vspaceneg
%


\section{Format binaire}
\indexfrr{format}{binaire}\indexfrr{fichier}{binaire}

Ecrire et lire des informations au travers d'un fichier texte revient à convertir les informations quel que soit leur type dans un format lisible pour tout utilisateur. Un entier est écrit sous forme de caractères décimaux alors que sa représentation en mémoire est binaire. Cette conversion dans un sens puis dans l'autre est parfois jugée coûteuse en temps de traitement et souvent plus gourmande en terme de taille de fichiers\footnote{Un fichier texte compressé, au format \codesnote{zip} par exemple, est une alternative aux fichiers binaires en terme de taille mais il allonge la lecture et l'écriture par des étapes de compression et de décompression.} même si elle permet de relire les informations écrites grâce à n'importe quel éditeur de texte. Il est parfois plus judicieux pour une grande masse d'informations d'utiliser directement le format binaire, c'est-à-dire celui dans lequel elles sont stockées en mémoire. Les informations apparaissent dans leur forme la plus simple pour l'ordinateur~: une suite d'octets (bytes en anglais).\indexfr{octet}\indexfr{byte} Deux étapes vont intervenir que ce soit pour l'écriture~:

\indexmoduleint{struct}
\begin{small}
\begin{enumerate}
\item On récupère les informations dans une suite d'octets (fonction \codesmall{pack} du module \codesmall{struct}).
\item On les écrit dans un fichier (méthode \codesmall{write} affiliée aux fichiers).
\end{enumerate}
\end{small}

Ou la lecture~:

\begin{small}
\begin{enumerate}
\item On lit une suite d'octets depuis un fichier (méthode \codesmall{read} affiliée aux fichiers).
\item On transforme cette suite d'octets pour retrouver l'information qu'elle formait initialement (fonction \codesmall{unpack} du module \codesmall{struct}).
\end{enumerate}
\end{small}



L'utilisation de fichiers binaires est moins évidente qu'il n'y paraît et il faut faire appel à des modules spécialisés alors que la gestion des fichiers texte ne pose aucun problème. Cela vient du fait que \pythons ne donne pas directement accès à la manière dont sont stockées les informations en mémoire contrairement à des langages tels que le~\textit{C++}. L'intérêt de ces fichiers réside dans le fait que l'information qu'ils contiennent prend moins de place stockée en binaire plutôt que convertie en chaînes de caractères au format texte\footnote{Par exemple, un réel est toujours équivalent à huit caractères en format binaire alors que sa conversion au format texte va souvent jusqu'à quinze caractères.}.

L'écriture et la lecture d'un fichier binaire soulèvent les mêmes problèmes que pour un fichier texte~: il faut organiser les données avant de les enregistrer pour savoir comment les retrouver. Les types immuables (réel, entier, caractère) sont assez simples à gérer dans ce format. Pour les objets complexes, \pythons propose une solution grâce au module \codes{pickle}.

\subsection{Ecriture dans un fichier binaire}

L'écriture d'un fichier binaire commence par l'ouverture du fichier en mode écriture par l'instruction \texttt{file = open ("<nom\_fichier>", "wb")}. C'est le code \codes{"wb"} qui est important (\textit{w} pour \textit{write}, \textit{b} pour \textit{binary}), il spécifie le mode d'ouverture \codes{"w"} et le format \codes{"b"}. La fermeture est la même que pour un fichier texte.

Le module \codes{struct} et la fonction \codes{pack}\indexmoduleint{struct}\indexfonction{pack} permet de convertir les informations sous forme de chaîne de caractères avant de les enregistrer au format binaire. La fonction \codes{pack} construit une chaîne de caractères égale au contenu de la mémoire. Son affichage avec la fonction \codes{print} produit quelque chose d'illisible le plus souvent. Le tableau suivant montre les principaux formats de conversion\footnote{La liste complète figure à l'adresse \httpstyle{http://docs.python.org/library/struct.html}.}.
\indexfr{taille mémoire}%
\begin{center}\begin{tabular}{|l|l|} \hline
\textbf{code} & \textbf{type correspondant} \\ \hline
\codes{c} & caractère 											\\ \hline
\codes{B} & caractère non signé (octet)		 \\ \hline
\codes{i} & entier (4 octets)		 					\\ \hline
\codes{I} & entier non signé (4 octets)		 \\ \hline
\codes{d} & double (8 octets)							 \\ \hline
\end{tabular}\end{center}
%
L'utilisation de ces codes est illustrée au paragraphe~\ref{exemple_complet_bin_}.

\subsection{Lecture d'un fichier binaire}

Le code associé à l'ouverture d'un fichier binaire en mode lecture est \codes{"rb"}, cela donne~: \texttt{file = open ("<nom\_fichier>", "rb")}. La lecture utilise la fonction \codes{unpack}\indexfonction{unpack} pour effectuer la conversion inverse, celle d'une chaîne de caractères en entiers, réels,~... Le paragraphe suivant illustre la lecture et l'écriture au format binaire. 

\subsection{Exemple complet} \label{exemple_complet_bin_} 
 \indexmethod{read}\indexmethod{write}\indexmethod{pack}\indexmethod{unpack}

Cet exemple crée un fichier \codes{"info.bin"} puis écrit des informations à l'intérieur. Il ne sera pas possible d'afficher le contenu du fichier à l'aide d'un éditeur de texte. La méthode \codes{pack} accepte un nombre de paramètres variable\footnote{voir également paragraphe~\ref{nombr_eparam_variable_ref}, page~\pageref{nombr_eparam_variable_ref}}, ceci explique la syntaxe \codes{struct.pack ("cccc" , *s)}.
%
\vspaceneg
\inputcodes{../python_cours/programme/binary_file.py}{fichiers binaires}{ (1)}
\vspaceneg
%
Les résultats de la méthode \codes{unpack} apparaissent dans un tuple mais les données sont correctement récupérées. Ce programme fait aussi apparaître une des particularité du format binaire. On suppose ici que la chaîne de caractères est toujours de longueur~4. En fait, pour stocker une information de dimension variable, il faut d'abord enregistrer cette dimension puis s'en servir lors de la relecture pour connaître le nombre d'octets à lire. On modifie le programme précédent pour sauvegarder une chaîne de caractères de longueur variable.
%
\vspaceneg
\inputcodes{../python_cours/programme/binary_file2.py}{fichiers binaires}{ (2)}
\vspaceneg
%
Cette méthode utilisée pour les chaînes de caractères est applicable aux listes et aux dictionnaires de longueur variable~: il faut d'abord stocker leur dimension. Il faut retenir également que la taille d'un réel est de huit octets, celle d'un entier de quatre octets et celle d'un caractère d'un octet\footnote{Cette règle est toujours vrai sur des ordinateurs \textit{32 bits}. Cette taille varie sur les ordinateurs 64 bits qui commencent à se répandre. Le programme suivant donnera la bonne réponse. \indexfr{taille mémoire}\\
\begin{tabular}{l}
\codesnote{from \; struct \; import \; pack} \\
\codesnote{print \; len (pack ('i',0))  \; \;   \# \; \text{longueur d'un entier}} \\
\codesnote{print \; len (pack ('d',0))  \; \;   \# \; \text{longueur d'un réel}} \\
\codesnote{print \; len (pack ('c',"e"))\; \;   \# \; \text{longueur d'un caractère}} \\
\end{tabular}
}. Cette taille doit être passée en argument à la méthode \codes{read}.

\subsection{Objets plus complexes}
\indexfrr{fichier}{sérialisation}

Il existe un moyen de sauvegarder dans un fichier des objets plus complexes à l'aide du module \codes{pickle}.\indexmoduleint{pickle} Celui-ci permet de stocker dans un fichier le contenu d'un dictionnaire à partir du moment où celui-ci contient des objets standard du langage \python. Le principe pour l'écriture est le suivant~:
%
\vspaceneg
\indexexemples{sérialisation}{}
\begin{verbatimx}
import pickle

dico = {'a': [1, 2.0, 3, "e"], 'b': ('string', 2), 'c': None}
lis  = [1, 2, 3]

f = open ('data.bin', 'wb')
pickle.dump (dico, f)
pickle.dump (lis, f)
f.close()
\end{verbatimx}
\vspaceneg
%
La lecture est aussi simple~:\indexfonction{dump}\indexfonction{load}\indexfonction{open}\indexfonction{close}
%
\vspaceneg
\indexexemples{sérialisation}{}
\begin{verbatimx}
f = open ('data.bin', 'rb')
dico = pickle.load (f)
lis  = pickle.load (f)
f.close()
\end{verbatimx}
\vspaceneg
%
Un des avantages du module \codes{pickle} est de pouvoir gérer les références circulaires~: il est capable d'enregistrer et de relire une liste qui se contient elle-même,\indexfr{référence circulaire} ce peut être également une liste qui en contient une autre qui contient la première...

Le module \codes{pickle} peut aussi gérer les classes définies par un programmeur à condition qu'elles puissent convertir leur contenu en un dictionnaire dans un sens et dans l'autre, ce qui correspond à la plupart des cas.
%
\vspaceneg
\inputcodes{../python_cours/programme/test_pickle.py}{module \codesindex{pickle} et classes}{ (1)}
\vspaceneg
%
Lorsque la conversion nécessite un traitement spécial, il faut surcharger les opérateurs \codes{\_\_getstate\_\_} et \codes{\_\_setstate\_\_}. Ce cas se produit par exemple lorsqu'il n'est pas nécessaire d'enregistrer tous les attributs de la classe car certains sont calculés ainsi que le montre l'exemple suivant~:\indexoperateur{\_\_getstate\_\_}\indexoperateur{\_\_setstate\_\_}
%
\vspaceneg
\inputcodes{../python_cours/programme/test_pickle2.py}{module \codesindex{pickle} et classes}{ (2)}
\vspaceneg

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Paramètres en ligne de commande} \indexfr{ligne de commande}

Certains développements nécessitent de pouvoir exécuter un programme \pythons en ligne de commande sans intervention extérieure. Ce peut être un programme de synchronisation de deux répertoires ou la récupération du contenu de pages HTML, des tâches souvent exécutées la nuit à une heure où personne n'est présent pour le faire. Prenons par exemple le cas d'un programme très simple de synchronisation qui recopie tous les fichiers d'un répertoire vers un autre. La fonctionne \codes{copie\_repertoire} effectue cette tâche. \indexmoduleint{glob}\indexmoduleint{shutil}
\vspaceneg
\indexexemples{liste de fichiers}{ (3)}
\begin{verbatimx}
# coding: latin-1
import glob
import shutil
def copie_repertoire (rep1, rep2) :
    """copie tous les fichiers d'un répertoire rep1 vers un autre rep2"""
    li = glob.glob (rep1 + "/*.*")   # récupère dans une liste fichiers et 
                                     # répertoires qui respectent le filtre
    for l in li :
        to = l.replace (rep1, rep2)  # nom du fichier copié 
                                     # (on remplace rep1 par rep2)
        shutil.copy (l, to)
copie_repertoire ("c:/original", "c:/backup")
\end{verbatimx}
\vspaceneg
%
Cette tâche est en plus exécutée sur deux répertoires et on ne voudrait pas avoir deux programmes différents alors que la tâche est la même quelque soit le couple de répertoire choisi. On souhaite pouvoir lancer le programme \pythons et lui spécifier les deux répertoires, c'est-à-dire être capable de lancer le programme comme suit (voir également figure~\ref{poyton__cmd_synchor2})~:
\vspaceneg
\indexexemples{ligne de commande}{ (1)}
\begin{verbatimx}
c:\python26\python.exe synchro.py c:/original c:/backup
\end{verbatimx}
\vspaceneg

        		\begin{figure}[ht]
            \begin{center}\begin{tabularx}{\textwidth}{|X|}\hline
            \includegraphics[width=13.4cm]{\filextellipse{../python_cours/image/cmds26}{../python_cours/image_ellipse/cmds26}}
            \\ \hline
            \end{tabularx}\end{center}
            \caption{Un programme \pythons lancé en ligne de commande.}
            \label{poyton__cmd_synchor2}
            \end{figure}
            
\indexmoduleint{sys}
Pour lancer un programme \pythons en ligne de commande, il faut écrire dans une fenêtre de commande ou un programme d'extension \textit{bat}\ifnotellipse{\indexfrr{extension de fichier}{bat}}les instructions suivantes séparées par des espaces~:
\vspaceneg
\begin{verbatimx}
interpréteur_python programme_python argument1 argument2 ...
\end{verbatimx}
\vspaceneg
%
Il faut maintenant récupérer ces paramètres au sein du programme \pythons grâce au module \codes{sys} qui contient une variable \codes{argv} contenant la liste des paramètres de la ligne de commande. S'il y a deux paramètres, cette liste \codes{argv} contiendra trois éléments~:
\begin{small}
\begin{enumerate}
\item nom du programme
\item paramètre 1
\item paramètre 2
\end{enumerate}
\end{small}

%
Le programme suivante utilise ce mécanisme avec le programme \codes{synchro} contenant la fonction \codes{copie\_repertoire}~:
%            
\vspaceneg
\inputcode{../python_cours/programme/synchro.py}{lancer un programme \pythons en ligne de commande}            
\vspaceneg
%

\begin{xremark}{paramètres contenant des espaces}
Lorsque les paramètres écrits sur la ligne de commande contiennent eux-mêmes des espaces, il faut les entourer avec des guillemets.
\vspaceneg
\indexexemples{ligne de commande}{ (2)}
\begin{verbatimx}
c:\python26\python.exe c:\batch\synchro.py 
          "c:\Program Files\source" "c:\Program Files\backup"
\end{verbatimx}
\end{xremark}

\vspaceneg
Pour des besoins plus complexes, le module \codes{getopt} propose des fonctions plus élaborées pour traiter les paramètres de la ligne de commande.\indexmoduleint{getopt} Il est également possible de lancer un programme en ligne de commande depuis \pythons grâce à la fonction \codes{system} du module \codes{os} comme ceci~: \indexfonction{system}\indexmoduleint{os}
%
\vspaceneg
\begin{verbatimx}
import os
os.system ("c:\python26\python.exe c:\batch\synchro.py " \
           "\"c:\Program Files\source\" \"c:\Program Files\backup\"")
\end{verbatimx}
\vspaceneg
%
Le programme suivant est un autre exemple de l'utilité de la fonction \codes{system}. Il écrit une matrice au format \textit{HTML}\footnote{La description du langage \textit{HTML} sort du cadre de ce livre mais la requête \codesnote{HTML \; syntaxe} effectuée sur n'importe quel moteur de recherche Internet retournera des résultats intéressants.} puis utilise la fonction \codes{system} pour lancer le navigateur \textit{Firefox} ou \textit{Internet Explorer} afin de pouvoir visualiser la page créée.
%
\vspaceneg
\inputcode{../python_cours/programme/htmlnavi.py}{lancer un navigateur en ligne de commande}            


\section{Expressions régulières} \indexfr{expressions régulières} \label{regex_label_chap}

\subsection{Premiers pas}

Chercher un mot dans un texte est une tâche facile, c'est l'objectif de la méthode \codes{find} attachée aux chaînes de caractères, elle suffit encore lorsqu'on cherche un mot au pluriel ou au singulier mais il faut l'appeler au moins deux fois pour chercher ces deux formes. Pour des expressions plus compliquées, il est conseillé d'utiliser les \textit{expressions régulières}. C'est une fonctionnalité qu'on retrouve dans beaucoup de langages. C'est une forme de grammaire qui permet de rechercher des expressions.

Lorsqu'on remplit un formulaire, on voit souvent le format "MM/JJ/AAAA" qui précise sous quelle forme on s'attend à ce qu'une date soit écrite. Les expressions régulières permettent de définir également ce format et de chercher dans un texte toutes les chaînes de caractères qui sont conformes à ce format.

La liste qui suit contient des dates de naissance. On cherche à obtenir toutes les dates de cet exemple sachant que les jours ou les mois contiennent un ou deux chiffres, les années deux ou quatre. 
\vspaceneg
\begin{verbatimx}
s = """date 0 : 14/9/2000     
date 1 : 20/04/1971     date 2 : 14/09/1913     date 3 : 2/3/1978     
date 4 : 1/7/1986     date 5 : 7/3/47     date 6 : 15/10/1914     
date 7 : 08/03/1941     date 8 : 8/1/1980     date 9 : 30/6/1976"""
\end{verbatimx}
\vspaceneg
Le premier chiffre du jour est soit 0, 1, 2, ou 3~; ceci se traduit par \codes{[0-3]}. Le second chiffre est compris entre 0~et~9, soit \codes{[0-9]}. Le format des jours est traduit par \codes{[0-3][0-9]}. Mais le premier jour est facultatif, ce qu'on précise avec le symbole~\codes{?}~: \codes{[0-3]?[0-9]}. Les mois suivent le même principe~: \codes{[0-1]?[0-9]}. Pour les années, ce sont les deux premiers chiffres qui sont facultatifs, le symbole \codes{?} s'appliquent sur les deux premiers chiffres, ce qu'on précise avec des parenthèses~: ([0-2][0-9])?[0-9][0-9]. Le format final d'une date devient~:
%
\vspaceneg
\begin{verbatimx}
[0-3]?[0-9]/[0-1]?[0-9]/([0-2][0-9])?[0-9][0-9]
\end{verbatimx}
\vspaceneg
%
Le module \codes{re}\indexmoduleint{re} gère les expressions régulières, celui-ci traite différemment les parties de l'expression régulière qui sont entre parenthèses de celles qui ne le sont pas~: c'est un moyen de dire au module \codes{re} que nous nous intéressons à telle partie de l'expression qui est signalée entre parenthèses. Comme la partie qui nous intéresse -~une date~- concerne l'intégralité de l'expression régulière, il faut insérer celle-ci entre parenthèses. 

La première étape consiste à construire l'expression régulière, la seconde à rechercher toutes les fois qu'un morceau de la chaîne \codes{s} définie plus haut correspond à l'expression régulière. \indexmethod{findall}\indexfonction{compile}
\vspaceneg
\begin{verbatimx}
import re
# première étape : construction
expression = re.compile ("([0-3]?[0-9]/[0-1]?[0-9]/([0-2][0-9])?[0-9][0-9])")
# seconde étape  : recherche
res = expression.findall (s)  
print res
\end{verbatimx}
\vspaceneg
Le résultat de ce programme est le suivant~: \label{regex_example_page1}
\vspaceneg
\begin{verbatimx}
[('14/9/2000', '20'), ('20/04/1971', '19'),  ('14/09/1913', '19'), 
 ('2/3/1978', '19'),  ('1/7/1986', '19'),    ('7/3/47', ''),      
 ('15/10/1914', '19'), ('08/03/1941', '19'), ('8/1/1980', '19'),  
 ('30/6/1976', '19')]
\end{verbatimx}
\vspaceneg
C'est une liste de couples dont chaque élément correspond aux parties comprises entre parenthèses qu'on appelle des \textit{groupes}.\indexfrr{expressions régulières}{groupe} Lorsque les expressions régulières sont utilisées, on doit d'abord se demander comment définir ce qu'on cherche puis quelles fonctions utiliser pour obtenir les résultats de cette recherche. Les deux paragraphes qui suivent y répondent.


\subsection{Syntaxe}

La syntaxe des expressions régulières est décrite sur le site officiel de \python\footnote{La page \httpstyle{http://docs.python.org/library/re.html\#regular-expression-syntax} décrit la syntaxe, la page \httpstyle{http://docs.python.org/howto/regex.html\#regex-howto} décrit comment se servir des expressions régulières, les deux pages sont en anglais.}. Comme toute grammaire, celle des expressions régulières est susceptible d'évoluer au fur et à mesure des versions du langage \python. 

\subsubsection{Les ensembles de caractères}  \indexfrr{expressions régulières}{ensemble de caractères}

Lors d'une recherche, on s'intéresse aux caractères et souvent aux classes de caractères~: on cherche un chiffre, une lettre, un caractère dans un ensemble précis ou un caractère qui n'appartient pas à un ensemble précis. Certains ensembles sont prédéfinis, d'autres doivent être définis à l'aide de crochets. 

Pour définir un ensemble de caractères, il faut écrire cet ensemble entre crochets~: \codes{[0123456789]} désigne un chiffre. Comme c'est une séquence de caractères consécutifs, on peut résumer cette écriture en \texttt{[0-9]}. Pour inclure les symboles \codes{-}, \codes{+}, il suffit d'écrire~: \texttt{[-0-9+]}. Il faut penser à mettre le symbole \codes{-} au début pour éviter qu'il ne désigne une séquence. 

Le caractère~~\codes{\hat{}}~~inséré au début du groupe signifie que le caractère cherché ne doit pas être un de ceux qui suivent. Le tableau suivant décrit les ensembles prédéfinis\footnote{La page \httpstyle{http://docs.python.org/library/re.html\#regular-expression-syntax} les recense tous.} et leur équivalent en terme d'ensemble de caractères~:
%
\begin{center}\begin{tabularx}{\textwidth}{|lX|} \hline
\codes{.}             & désigne tout caractère non spécial quel qu'il soit \\ 
\codes{\backslash d}  & désigne tout chiffre, est équivalent à \texttt{[0-9]} \\ 
\codes{\backslash D}  & désigne tout caractère différent d'un chiffre, est équivalent à  \texttt{[$\hat{~}$0-9]} \\
\codes{\backslash s}  & désigne tout espace ou caractère approché, est équivalent à  \codes{[\; \backslash t\backslash n\backslash r\backslash f\backslash v]}\footnote{Ces caractères sont spéciaux, les plus utilisés sont \codesnote{\backslash t} qui est une tabulation, \codesnote{\backslash n} qui est une fin de ligne et qui \codesnote{\backslash r} qui est un retour à la ligne.} \\
\codes{\backslash S}  & désigne tout caractère différent d'un espace, est équivalent à  \codes{[\hat{~} \backslash t\backslash n\backslash r\backslash f\backslash v]} \\
\codes{\backslash w}  & désigne tout lettre ou chiffre, est équivalent à \texttt{[a-zA-Z0-9\_]} \\
\codes{\backslash W}  & désigne tout caractère différent d'une lettre ou d'un chiffre, est équivalent à \texttt{[$\hat{~}$a-zA-Z0-9\_]} \\ \codes{\hat{~}}       & désigne le début d'un mot sauf s'il est placé entre crochets\\ 
\codes{\$}            & désigne la fin d'un mot sauf s'il est placé entre crochets\\ \hline
\end{tabularx}\end{center}
%
A l'instar des chaînes de caractères, comme le caractère \codes{\backslash} est un caractère spécial, il faut le doubler~: \codes{[\backslash\backslash]}. Avec ce système, le mot "taxinomie" qui accepte deux orthographes s'écrira~: \codes{tax[io]nomie}. \indexfrr{expressions régulières}{\codesindex{\backslash w}\codes{\backslash d}}\indexfrr{expressions régulières}{ensemble de caractères}

\begin{xremark}{caractères spéciaux et expressions régulières}
Le caractère $\backslash$ est déjà un caractère spécial pour les chaînes de caractères en \python, il faut donc le quadrupler pour l'insérer dans un expression régulière. L'expression suivante filtre toutes les images dont l'extension est \codes{png} et qui sont enregistrées dans un répertoire \codes{image}.\indexfrr{expressions régulières}{caractères spéciaux}
\vspaceneg
\begin{verbatimx}
s = r"D:\Dupre\_data\informatique\support\vba\image/vbatd1_4.png"
print re.compile ( "[\\\\/]image[\\\\/].*[.]png").search(s) # résultat positif
print re.compile (r"[\\/]image[\\/].*[.]png").search(s)     # même résultat
\end{verbatimx}
\end{xremark}

\subsubsection{Les multiplicateurs}  \indexfrr{expressions régulières}{multiplicateurs}

Les multiplicateurs permettent de définir des expressions régulières comme~: un mot entre six et huit lettres qu'on écrira \codes{[\backslash w]\{6,8\}}. Le tableau suivant donne la liste des multiplicateurs principaux\footnote{La page \httpstyle{http://docs.python.org/library/re.html\#regular-expression-syntax} les recense tous.}~:
%
\begin{center}\begin{tabularx}{\textwidth}{|lX|} \hline
\begin{tabular}{l}\codes{*} \end{tabular}						& présence de l'ensemble de caractères qui précède entre 0 fois et l'infini \\
\begin{tabular}{l}\codes{+} \end{tabular}						& présence de l'ensemble de caractères qui précède entre 1 fois et l'infini \\
\begin{tabular}{l}\codes{?} \end{tabular}						& présence de l'ensemble de caractères qui précède entre 0 et 1 fois \\
\begin{tabular}{l}\codes{\{m,n\}} \\ ~\end{tabular}	& présence de l'ensemble de caractères qui précède entre \codes{m} et \codes{n} fois, si \codes{m=n}, cette expression peut être résumée par \codes{\{n\}}. \\
\begin{tabular}{l}\codes{(?!(...))} \\ ~ \end{tabular}	& absence du groupe désigné par les points de suspensions (voir paragraphe~\ref{exemple_grefsdf_fsdsqsd}).  \\
\hline
\end{tabularx}\end{center}
%
L'algorithme des expressions régulières essaye toujours de faire correspondre le plus grand morceau à l'expression régulière. Par exemple, dans la chaîne \texttt{<h1>mot</h1>}, \texttt{<.*>} correspond avec \texttt{<h1>}, \texttt{</h1>} ou encore \texttt{<h1>mot</h1>}. Par conséquent, l'expression régulière correspond à trois morceaux. Par défaut, il prendra le plus grand. Pour choisir les plus petits, il faudra écrire les multiplicateurs comme ceci~: \codes{*?}, \codes{+?}, \codes{??}.
\vspaceneg
\begin{verbatimx}
import re
s = "<h1>mot</h1>"
print re.compile ("(<.*>)") .match (s).groups () # ('<h1>mot</h1>',)
print re.compile ("(<.*?>)").match (s).groups () # ('<h1>',)
\end{verbatimx}




\subsubsection{Groupes}  \indexfrr{expressions régulières}{groupe}

Lorsqu'un multiplicateur s'applique sur plus d'un caractère, il faut définir un groupe à l'aide de parenthèses. Par exemple, le mot \codes{yoyo} s'écrira~: \codes{(yo)\{2\}}. Les parenthèses jouent un rôle similaire à celui qu'elles jouent dans une expression numérique. Tout ce qui est compris entre deux parenthèses est considéré comme un groupe.


\subsubsection{Assembler les caractères}  

On peut assembler les groupes de caractères les uns à la suite des autres. Dans ce cas, il suffit de les juxtaposer comme pour trouver les mots commençant par \codes{s}~: \codes{s[a-z]*}. On peut aussi chercher une chaîne ou une autre grâce au symbole \codes{|}. Chercher dans un texte l'expression \textit{Xavier Dupont} ou \textit{M. Dupont} s'écrira~: \codes{(Xavier)|(M[.]) Dupont}. \indexfrr{expressions régulières}{assemblage}


\subsection{Fonctions} \label{regex_fonction_descrpition}

La fonction \codes{compile}\indexfonction{compile} du module \codes{re} permet de construire un objet "expression régulière". A partir de cet objet, on peut vérifier la correspondance entre une expression régulière et une chaîne de caractères (méthode \codes{match}).\indexmethod{match} On peut chercher une expression régulière (méthode \codes{search}).\indexmethod{search} On peut aussi remplacer une expression régulière par une chaîne de caractères (méthode \codes{sub}).\indexmethod{sub} La table~\ref{regex_method_table} récapitule ces méthodes.

\begin{table}[ht]
\begin{center}\begin{tabularx}{\textwidth}{|lX|} \hline
\codes{match(  	s[, pos[, end]])} & 
		Vérifie la correspondance entre l'expression régulière et la chaîne \codes{s}. Il est possible de n'effectuer cette vérification qu'entre les caractères dont les positions sont \codes{pos} et \codes{end}. La fonction retourne \codes{None} s'il n'y a pas de correspondance et sinon un objet de type \codes{Match}. \\ \hline
\codes{search( 	s[, pos[, end]])} &
    Fonction semblable à  \codes{match}, au lieu de vérifier la correspondance entre toute la chaîne et l'expression régulière, cherche la première chaîne de caractères extraite correspondant à l'expression régulière.\\ \hline
\begin{tabular}{@{}l@{}}\codes{split( 	s} \\ \codes{[, maxsplit = 0])} \end{tabular} &
    Recherche toutes les chaînes de caractères extraites qui vérifient l'expression régulière puis découpe cette chaîne en fonction des expressions trouvées. La méthode \codes{split} d'une chaîne de caractère permet de découper selon un séparateur. La méthode \codes{split} d'une expression régulière permet de découper selon plusieurs séparateurs. C'est pratique pour découper une chaîne de caractères en colonnes séparées par \codes{;} ou une tabulation. \codes{re.compile ("[\backslash t;]").split ("a;b\backslash tc;g")} donne \codes{["a", "b", "c", "g"]}.\\ \hline
\codes{findall( 	s[, pos[, end]])} &
    Identique à \codes{split} mais ne retourne pas les morceaux entre les chaînes extraites qui vérifient l'expression régulière.\\ \hline
\begin{tabular}{@{}l@{}}\codes{sub( 	repl, s} \\ \codes{[, count = 0])} \end{tabular}&
    Remplace dans la chaîne \codes{repl} les éléments \codes{\backslash 1}, \codes{\backslash 2}, ... par les parties de \codes{s} qui valident l'expression régulière. \\ \hline
\codes{flags} &
    Mémorise les options de construction de l'expression régulière. C'est un attribut. \\ \hline
\codes{pattern} &
    Chaîne de caractères associée à l'expression régulière. C'est un attribut. \\ \hline
\end{tabularx}\end{center}
\caption{Liste non exhaustive des méthodes et attributs qui s'appliquent à un objet de type "expression régulière" retourné par la fonction \codescaption{compile} du module \codescaption{re}. La page \httpstyle{http://docs.python.org/library/re.html} contient
la documentation associée au module~\codes{re}.}
\label{regex_method_table}\indexmethod{sub}\indexmethod{match}\indexmethod{search}\indexmethod{split}\indexmethod{findall}
\indexfonction{compile}
\end{table}

Les méthodes \codes{search} et \codes{match} retournent toutes des objets \codes{Match} dont les méthodes sont présentées par la table~\ref{regex_method_table2}. Appliquées à l'exemple décrit page~\pageref{regex_example_page1} concernant les dates, cela donne~:
\vspaceneg
\begin{verbatimx}
expression = re.compile ("([0-3]?[0-9]/[0-1]?[0-9]/([0-2][0-9])?[0-9][0-9])[^\d]")
print expression.search (s).group(1,2) # affiche ('14/9/2000', '20')
c = expression.search (s).span(1)      # affiche (9, 18)
print s [c[0]:c[1]]                    # affiche 14/9/2000
\end{verbatimx}
\vspaceneg


\begin{table}[ht]
\begin{center}\begin{tabularx}{\textwidth}{|lX|} \hline
\codes{group( 	[g1, ...])} & Retourne la chaîne de caractères validée par les groupes \codes{g1}... \\ \hline
\codes{groups( 	[default])} & Retourne la liste des chaînes de caractères qui ont été validées par chacun des groupes.\\ \hline
\codes{span( 	[gr])} & Retourne les positions dans la chaîne originale des chaînes extraites validées le groupe~\codes{gr}.\\ \hline
\end{tabularx}\end{center}
\caption{Liste non exhaustive des méthodes qui s'appliquent à un objet de type \codescaption{Match} qui est le résultat des méthodes \codescaption{search} et \codescaption{match}. Les groupes sont des sous-parties de l'expression régulière, chacune d'entre elles incluses entre parenthèses. Le n$^\text{ème}$ correspond au groupe qui suit la n$^\text{ème}$ parenthèse ouvrante. Le premier groupe a pour indice~1. La page \httpstyle{http://docs.python.org/library/re.html} contient la documentation associée au module~\codes{re}.
}
\label{regex_method_table2}\indexmethod{group}\indexmethod{groups}\indexmethod{search}\indexmethod{span}\indexmethod{match}
\end{table}



\subsection{Exemple plus complet}\indexfrr{expressions régulières}{exemple}\label{exemple_grefsdf_fsdsqsd}

L'exemple suivant présente trois cas d'utilisation des expressions régulières. On s'intéresse aux titres de chansons \textit{MP3} stockées dans un répertoire.\indexfr{MP3} Le module \codes{mutagen}\footnote{\httpstyle{http://code.google.com/p/quodlibet/wiki/Development/Mutagen}}\indexmoduleext{mutagen} permet de récupérer certaines informations concernant un fichier \textit{MP3} dont le titre, l'auteur et la durée. 

Le premier problème consiste à retrouver les chansons sans titre ou dont le titre contient seulement son numéro~: \textit{track03}, \textit{track - 03}, \textit{audiotrack 03}, \textit{track 03}, \textit{piste 03}, \textit{piste - 03}, \textit{audiopiste 03},~... Ce titre indésirable doit valider l'expression régulière suivante~: \texttt{$\hat{~}$(((audio)?track( )?( - )?[0-9]{1,2})|(piste [0-9]{1,2}))\$}.

Le second problème consiste à retrouver toutes les chansons dont le titre contient le mot \textit{heart} mais ni \textit{heartland} ni \textit{heartache}. Ce titre doit valider l'expression régulière~: \texttt{((heart)(?!((ache)|(land))))}.

Le troisième problème consiste à compter le nombre de mots d'un titre. Les mots sont séparés par l'ensemble de caractères \codes{[- ,;!'.?\&:]}. On utilise la méthode \codes{split} pour découper en mots. Le résultat est illustré par le programme suivant.


\inputcodes{../python_cours/programme/filemp3.py}{expressions régulières}{ (1)}

\begin{xremark}{Nommer des groupes}
Une expression régulière ne sert pas seulement de filtre, elle permet également d'extraire le texte qui correspond à chaque groupe, à chaque expression entre parenthèses. L'exemple suivant montre comment récupérer le jour, le mois, l'année à l'intérieur d'une date.
\begin{verbatimx}
import re
date = "05/22/2010"
exp  = "([0-9]{1,2})/([0-9]{1,2})/(((19)|(20))[0-9]{2})"
com  = re.compile (exp)
print com.search (date).groups ()    # ('05', '22', '2010', '20', None, '20')
\end{verbatimx}
Il n'est pas toujours évident de connaître le numéro du groupe qui contient l'information à extraire. C'est pourquoi il paraît plus simple de les nommer afin de les récupérer sous la forme d'un dictionnaire et non plus sous forme de tableau. La syntaxe \texttt{(?P<nom\_du\_groupe>expression)} permet de nommer un groupe. Elle est appliquée à l'exemple précédent.
\begin{verbatimx}
exp  = "(?P<jj>[0-9]{1,2})/(?P<mm>[0-9]{1,2})/(?P<aa>((19)|(20))[0-9]{2})"
com  = re.compile (exp)
print com.search (date).groupdict () # {'mm': '22', 'aa': '2010', 'jj': '05'}
\end{verbatimx}
\end{xremark}


\ifnotellipse{
Le programme suivant est un exemple d'utilisation des expressions régulières dont l'objectif est de détecter les fonctions définies dans un programme mais jamais utilisées. Les expressions servent à détecter les définitions de fonctions (d'après le mot-clé \codes{def}) puis à détecter les appels. On recoupe ensuite les informations en cherchant les fonctions définies mais jamais appelées.

Il n'est pas toujours évident de construire une expression régulière qui correspondent précisément à tous les cas qu'on veut détecter. Une stratégie possible est de construire une expression régulière plus permissive puis d'éliminer les cas indésirables à l'aide d'une seconde expression régulière, c'est le cas ici pour détecter les appels.
%
\vspaceneg
\inputcodes{../python_cours/programme/fonction.py}{expressions régulières}{ (2)}            
}


    



\section{Dates} \indexfr{dates}

Le module \codes{datetime}\footnote{Voir également la page~\httpstyle{http://docs.python.org/library/datetime.html}.}\indexmoduleint{datetime} fournit une classe \codes{datetime}\indexclass{datetime} qui permet de faire des opérations et des comparaisons sur les dates et les heures. L'exemple suivant calcule l'âge d'une personne née le 11~août~1975.
%
\vspaceneg
\indexexemples{dates}{}
\begin{verbatimx}
import datetime
naissance = datetime.datetime (1975,11,8,10,0,0)
jour = naissance.now () # obtient l'heure et la date actuelle
print jour              # affiche 2010-05-22 11:24:36.312000
age = jour - naissance  # calcule une différence
print age               # affiche 12614 days, 1:25:10.712000
\end{verbatimx}
\vspaceneg
%
L'objet \codes{datetime} autorise les soustractions et les comparaisons entre deux dates. Une soustraction retourne un objet de type \codes{timedelta} qui correspond à une durée.\indexclass{timedelta} qu'on peut multiplier par un réel ou ajouter à un objet de même type ou à un objet de type \codes{datetime}. L'utilisation de ce type d'objet évite de se pencher sur tous les problèmes de conversion.

Le module \codes{calendar}\indexmoduleint{calendar} est assez pratique pour construire des calendriers. Le programme ci-dessous affiche une liste de t-uples incluant le jour et le jour de la semaine du mois d'août 1975. Dans cette liste, on y trouve le t-uple \codes{(11,0)} qui signifie que le 11 août 1975 était un lundi. Cela permet de récupérer le jour de la semaine d'une date de naissance.\indexfr{date de naissance}
\vspaceneg
\indexexemples{date de naissance}{}
\begin{verbatimx}
import calendar
c = calendar.Calendar ()
for d in c.itermonthdays2 (1975,8) : print d
\end{verbatimx}

\section{Problème de jeux de caractères}\label{para_cosedescodes}
\indexfrr{chaîne de caractères}{encodage}\indexfr{jeu de caractères}

La langue anglaise est la langue dominante en ce qui concerne l'informatique mais cela n'empêche pas que des programmes anglais manipulent du japonais même si le nombre de caractères est beaucoup plus grand. Les jeux de caractères proposent une solution à ce problème~: un jeu de caractères définit la façon de décoder une suite d'octets\footnote{On confond souvent jeu de caractères et \textit{encodage}.\indexfr{encodage} Le jeu de caractère désigne l'ensemble de caractères dont le programme a besoin, l'encodage décrit la manière dont on passe d'une séquence de caractères français, japonais, anglais à une séquence d'octets qui est la seule information manipulée par un ordinateur.}. Les langues latines n'ont besoin que d'un octet pour coder un caractère, les langues asiatiques en ont besoin de plusieurs. Il n'existe pas qu'un seul jeu de caractères lorsqu'on programme. Ils interviennent à plusieurs endroits différents~:\indexfrr{jeu de caractères}{ascii}\indexfrr{jeu de caractères}{cp1252}\indexfrr{jeu de caractères}{utf-8}\indexfrr{jeu de caractères}{unicode}

\begin{small}
\begin{enumerate}
\item Le jeu de caractères utilisé par l'éditeur de texte pour afficher le programme.
\item Le jeu de caractères du programme, par défaut \codesmall{ascii} mais il peut être changé en insérant une première ligne de commentaire (voir paragraphe~\ref{par_intro_accent_code}, page~\pageref{par_intro_accent_code}). Les chaînes de caractères du programme sont codées avec ce jeu de caractères. Ce jeu devrait être identique à celui utilisé par l'éditeur de texte afin d'éviter les erreurs.\indexfr{ascii}\indexfrr{jeu de caractères}{ascii}
\item Le jeu de caractères de la sortie, utilisé pour chaque instruction \codesmall{print}, il est désigné par le code \codesmall{cp1252} sur un système \codesmall{Windows}.\indexfrr{jeu de caractères}{cp1252}
\item Le jeu de caractères dans lequel les chaînes de caractères sont manipulées. Un jeu standard qui permet de représenter toutes les langues est le jeu de caractères \codesmall{utf-8}. Il peut être différent pour chaque variable.\indexfr{utf-8}\indexfrr{jeu de caractères}{cp1252}
\item Le jeu de caractères d'un fichier texte. Il peut être différent pour chaque fichier.
\end{enumerate}
\end{small}

Le langage \pythons offre deux classes pour représenter les chaînes de caractères. La classe \codes{str} qui est adaptée aux langues latines, le jeu de caractères n'est pas précisé. La classe \codes{unicode} représente un caractère sur un à quatre octets avec un jeu de caractères désigné par l'appellation \codes{unicode}.\indexfr{unicode}\indexfrr{jeu de caractères}{unicode} Il est impératif de savoir quel jeu est utilisé à quel endroit et il faut faire des conversions de jeux de caractères pour passer l'information d'un endroit à un autre. Il existe deux méthodes pour cela présentées par la table~\ref{string_method2_encode_decode}.
\vspaceneg\indexfrr{jeu de caractères}{latin-1}\indexfrr{chaîne de caractères}{préfixe \codesindex{u}}\indexfr{accent}
\indexexemples{jeu de caractères}{}
\begin{verbatimx}
# coding: latin-1
st =  "eé"
su = u"eé"  # raccourci pour su = unicode ("eé", "latin-1")
            # ou encore      su = unicode ("eé".decode ("latin-1"))
            
print type (st)                                    # affiche <type 'str'>
print type (su)                                    # affiche <type 'unicode'>
print len (st),        ";", st                     # affiche  2 ; eé
print len (repr (st)), ";", repr (st)              # affiche  7 ; 'e\xe9'
print len (su),        ";", su.encode ("latin-1")  # affiche  2 ; eé
print len (repr (su)), ";", repr (su)              # affiche  8 ; u'e\xe9'
\end{verbatimx}
\vspaceneg
Lorsqu'on manipule plusieurs jeux de caractères, il est préférable de conserver un unique jeu de référence pour le programme par l'intermédiaire de la classe \codes{unicode}. Il "suffit" de gérer les conversions depuis ces chaînes de caractères vers les entrées sorties du programme comme les fichiers texte. Par défaut, ceux-ci sont écrits avec le jeu de caractères du système d'exploitation. Dans ce cas, la fonction \codes{open} suffit. En revanche, si le jeu de caractères est différent, il convient de le préciser lors de l'ouverture du fichier. On utilise la fonction \codes{open} du module \codes{codecs} qui prend comme paramètre supplémentaire le jeu de caractères du fichier. Toutes les chaînes de caractères seront lues et converties au format \codes{unicode}. \indexmoduleint{codecs}\indexfonction{open}
\vspaceneg
\indexexemples{jeu de caractères}{, fichier}
\begin{verbatimx}
import codecs
f = codecs.open ("essai.txt", "r", "cp1252")  # jeu Windows
s = "".join (f.readlines ())
f.close ()
print type (s)              # affiche <type 'unicode'>
print s.encode ("cp1252")   # pour l'afficher, 
                            # il faut convertir l'unicode en "cp1252"
\end{verbatimx}
\vspaceneg


        \begin{table}[ht]
        \begin{center}\begin{tabularx}
        				{\textwidth}{|lX|} \hline
        				%{|lp{10cm}|} \hline
        \begin{tabular}{@{}l} \codes{encode( } \\ \codes{	\; [enc[,err]])} \end{tabular} &  
        			Cette fonction permet de passer d'un jeu de caractères, celui de la variable, au jeu de caractères 
        			précisé par \codes{enc} à moins 
        			que ce ne soit le jeu de caractères par défaut. Le paramètre \codes{err} permet de préciser comment gérer 
        			les erreurs, doit-on interrompre le programme (valeur \codes{'strict'}) ou les ignorer (valeur \codes{'ignore'}). 
        			La documentation
        			\pythons recense toutes les valeurs possibles pour ces deux paramètres aux adresses 
        			\httpstyle{http://docs.python.org/library/codecs.html\#id3} et 
        			\httpstyle{http://docs.python.org/library/stdtypes.html\#id4}. Cette fonction retourne un résultat de type \codes{str}.
   																								\\ \hline
        \begin{tabular}{@{}l} \codes{decode(} \\ \codes{\;[enc[, err]])} \\ \end{tabular} &  
        		Cette fonction est la fonction inverse de la fonction \codes{encode}. 
        		Avec les mêmes paramètres, elle effectue la transformation inverse.
					%        				
   																								\\ \hline
        \end{tabularx}\end{center}
        \caption{ Conversion de jeux de caractères, ce sont deux méthodes qui fonctionnent de façons identiques
        					pour les deux classes de chaînes de caractères disponibles en \python~:  \codescaption{str} et \codescaption{unicode}.
        					\indexclass{str}\indexclass{unicode}\indexfonction{str}\indexfonction{unicode}
        					}
        \label{string_method2_encode_decode}
        \indexfonction{encode}\indexfonction{decode}
        \end{table}                            


Le programme suivant permet d'obtenir le jeu de caractères par défaut et celui du système d'exploitation.
\vspaceneg
\indexexemples{jeu de caractères}{}
\begin{verbatimx}
import sys
import locale
             # retourne le jeu de caractères par défaut
print sys.getdefaultencoding ()    # affiche ascii
             # retourne le jeu de caractères du système d'exploitation
print locale.getdefaultlocale()    # affiche ('fr_FR', 'cp1252')
\end{verbatimx}
\vspaceneg
Les problèmes de jeux de caractères peuvent devenir vite compliqués lorsqu'on manipule des informations provenant de plusieurs langues différentes. Il est rare d'avoir à s'en soucier tant que le programme gère les langues anglaise et française. Dans le cas contraire, il est préférable d'utiliser le type \codes{unicode} pour toutes les chaînes de caractères. Il est conseillé de n'utiliser qu'un seul jeu de caractères pour enregistrer les informations dans des fichiers et le jeu de caractères \codes{utf-8} est le plus indiqué.\indexfrr{jeu de caractères}{utf-8}





\firstpassagedo{
	\begin{thebibliography}{99}
	\input{python_cours_biblio.tex}
	\end{thebibliography}
}



\input{../../common/livre_table_end.tex}%
\input{../../common/livre_end.tex}%