\input{../../common/livre_begin.tex}%
\firstpassagedo{\input{python_cours_titre.tex}}
\input{../../common/livre_table_begin.tex}%
%\firstpassagedo{\input{python_cours_chapter.tex}}







%-------------------------------------------------------------------------------------------------------------
\chapter{Syntaxe du langage \pythons (boucles, tests, fonctions)} \label{chap_syntaxe}\label{chap_boucle}
% tests, boucles, fonctions
%-------------------------------------------------------------------------------------------------------------

Avec les variables, les boucles et les fonctions, on connaît suffisamment d'éléments pour écrire des programmes. Le plus difficile n'est pas forcément de les comprendre mais plutôt d'arriver à découper un algorithme complexe en utilisant ces briques élémentaires. C'est l'objectif des chapitres centrés autour des exercices. Toutefois, même si ce chapitre présente les composants élémentaires du langage, l'aisance qu'on peut acquérir en programmation vient à la fois de la connaissance du langage mais aussi de la connaissance d'algorithmes standards comme celui du tri ou d'une recherche dichotomique. C'est cette connaissance tout autant que la maîtrise d'un langage de programmation qui constitue l'expérience en programmation.


\section{Les trois concepts des algorithmes}

Les algorithmes sont composés d'instructions, ce sont des opérations élémentaires que le processeur exécute selon trois schémas~:
\ifnotellipse{\indexfr{séquence}\indexfr{saut}\indexfr{test}\indexfr{opérations élémentaires}}
        \begin{center}\begin{tabularx}{\textwidth}{|l|X|} \hline 
        la séquence        &        %\begin{minipage}{10cm} 
                                            enchaînement des instructions les unes à la suite des autres~: 
                                            passage d'une instruction à la suivante
                                            %\end{minipage} 
                                            \\ \hline
        le saut             &        %\begin{minipage}{10cm} 
                                            passage d'une instruction à une autre qui n'est pas forcément la suivante 
                                            (c'est une rupture de séquence)
                                            %\end{minipage} 
                                            \\ \hline
        le test                &        %\begin{minipage}{10cm} 
                                            choix entre deux instructions
                                            %\end{minipage} 
                                            \\ \hline
        \end{tabularx}\end{center}

Le saut n'apparaît plus de manière explicite dans les langages évolués car il est une source fréquente d'erreurs. Il intervient dorénavant de manière implicite au travers des boucles qui combinent un saut et un test comme le montre l'exemple suivant~:

\textbf{Version avec boucles~:} \vspaceneg
%
\begin{verbatimx}
initialisation de la variable moy à 0
faire pour i allant de 1 à N
      moy reçoit moy + ni
moy reçoit moy / N
\end{verbatimx}
%
\textbf{Version équivalente avec sauts~:} \vspaceneg
%
\begin{verbatimx}
ligne 1 : initialisation de la variable moy à 0
ligne 2 : initialisation de la variable i à 1
ligne 3 : moy reçoit moy + ni
ligne 4 : i reçoit i + 1
ligne 5 : si i est inférieur ou égal à N alors aller à la ligne 3
ligne 6 : moy reçoit moy / N
\end{verbatimx}
%
\indexfr{syntaxe}
Tout programme peut se résumer à ces trois concepts. Chaque langage les met en place avec sa propre syntaxe et parfois quelques nuances mais il est souvent facile de les reconnaître même dans des langages inconnus. Le calcul d'une somme décrit plus haut et écrit en \pythons correspond à l'exemple suivant~: \indexexemples{somme}{} \vspaceneg
%
\begin{verbatimxnocut}
moy = 0
for i in range(1,N+1):    # de 1 à N+1 exclu --> de 1 à N inclus
    moy += n [i]
moy /= N  
\end{verbatimxnocut}
%
\indexfonction{iskeyword}\indexmoduleint{keyword} \vspaceneg
Le premier élément de cette syntaxe est constitué de ses mots-clés (\codes{for} et \codes{in}) (voir également table~\ref{mot_cle}) et des symboles (\codes{=}, \texttt{+=}, \texttt{/=}, \codes{[}, \codes{]}, \codes{(}, \codes{)}, \codes{:}) (voir table~\ref{symbole}) La fonction \codes{iskeyword} du module \codes{keyword}\footnote{Les modules seront décrits au chapitre~\ref{chap_module}. Dans ce cas-ci, un module est une librairie de fonctionnalités. La syntaxe \codesnote{keyword.iskeyword} permet d'exécuter la fonctionnalité \codesnote{iskeyword} du module \codesnote{keyword}.} permet de savoir si un mot-clé donné fait partie du langage \python. \vspaceneg
%
\begin{verbatimx}
import keyword
print keyword.iskeyword("for")     # affiche True
print keyword.iskeyword("until")   # affiche False
\end{verbatimx}
\vspaceneg


            \begin{table}[ht]
            \begin{center}
            %\begin{ttpcr}
            \begin{tabularx}{\textwidth}{|XXXXXXXX|}\hline
						and       &  as        &  assert    &  break     &  class     &  continue  &  def       &  del      \\
						elif      &  else      &  except    &  exec      &  finally   &  for       &  from      &  global   \\
						if        &  import    &  in        &  is        &  lambda    &  not       &  or        &  pass     \\
						print     &  raise     &  return    &  try       &  while     &  with      &  yield     &           \\
						\hline
            \end{tabularx}
            %\end{ttpcr}
            \end{center}
            \caption{ Mots-clés du langage \python, voir également la page
                              \httpstyle{http://docs.python.org/reference/lexical\_analysis.html\#identifiers}. }
            \label{mot_cle}
            \end{table}


            \begin{table}[ht]
            \begin{center}\begin{small}
            %\begin{ttpcr}
            \begin{tabularx}{\textwidth}{|XXXXXXXXXXXXX|}\hline
						$+$   &  $-$   &  $*$   &  $**$  &  $/$   &  \texttt{//}  &  $\%$  &  \texttt{<}\texttt{<}  &  \texttt{>}\texttt{>}  & 
						              $\&$  &  \texttt{|}   &  $\hat{}$ & $\backslash$ \\
						$\sim$&  \texttt{<}   &  \texttt{>}   &  \texttt{<=}  &  \texttt{>=}  & 
						  \texttt{==}  &  \texttt{!=}  &  \texttt{<>}  &  $($   &  $)$   &  $[$   &  $]$      & \\
						$\{$  &  $\}$  &  \texttt{"}   &  $,$   &  $:$   &  $.$   &  \texttt{'}   &  $=$   &  $;$   &  \texttt{+=}  &  
						                   																																	\texttt{-=}  &  \texttt{*=}     & \\
						\texttt{/=}  &  \texttt{//=} &  \texttt{\%=} &  \texttt{\&=} &  \texttt{|=}  &$\hat{}=$ & 
												\texttt{>}\texttt{>=} &  \texttt{<}\texttt{<=} &  \texttt{**=} &  \texttt{"""} &  \texttt{'''} &  $\#$     & \\
            \hline
            \end{tabularx}
            %\end{ttpcr}
            \end{small}\end{center}
            \caption{Symbole du langage \python, certains ont plusieurs usages comme : qui est utilisé
                                à chaque test ou boucle et qui permet aussi de déterminer une plage d'indices dans un tableau.
                     L'opérateur \codescaption{<>} est identique à \codescaption{!=} 
                     mais est déclaré obsolète (deprecated)~: il est susceptible de disparaître 
                     dans une prochaine version de \python. \indexfr{obsolète}\indexfr{deprecated}
                                }
            \label{symbole}
            \end{table}

\begin{xremark}{syntaxe et espaces}
Les espaces entre les mots-clés et les symboles ont peu d'importance, il peut n'y en avoir aucun comme dix.\indexsyntaxenoc{espace} Les espaces servent à séparer un mot-clé, un nombre d'une variable.
\end{xremark}



\section{Tests}
\subsection{Définition et syntaxe}
\label{test_test}
\indexkeyword{if}\indexkeyword{elif}\indexkeyword{else}\indexsymbol{:}\indexfr{test}
%
            \begin{xdefinition}{test}
            Les tests permettent d'exécuter des instructions différentes selon la valeur d'une condition logique.
            \end{xdefinition}

\indexsyntaxenoc{test}
%
\begin{xsyntax}{test}
\begin{verbatimno}

if condition1 :
   instruction1
   instruction2
   ...
else :
   instruction3
   instruction4
   ...
\end{verbatimno}
\negvspace
La clause \codes{else} est facultative. Lorsque la condition \codes{condition1} est fausse et qu'il n'y a aucune instruction à exécuter dans ce cas, la clause \codes{else} est inutile. La syntaxe du test devient~: \indexsyntaxenoc{test}\indexsyntaxecod{if\;else}
%
\begin{verbatimno}
if condition1 :
   instruction1
   instruction2
   ...
\end{verbatimno}
\negvspace
%
S'il est nécessaire d'enchaîner plusieurs tests d'affilée, il est possible de condenser l'écriture avec le mot-clé \codes{elif}~: \indexsyntaxenoc{test enchaîné}\indexsyntaxecod{if\;elif\;else}
%
\begin{verbatimno}
if condition1 :
   instruction1
   instruction2
   ...
elif condition2 :
   instruction3
   instruction4
   ...
elif condition3 :
   instruction5
   instruction6
   ...
else :
   instruction7
   instruction8
   ...
\end{verbatimno}
\end{xsyntax}
%

\begin{xremark}{indentation}
Le décalage des instructions par rapport aux lignes contenant les mots-clés \codes{if}, \codes{elif}, \codes{else} est très important~: il fait partie de la syntaxe du langage et s'appelle l'\emph{indentation} (voir paragraphe~\ref{par_indentation}). Celle-ci permet de grouper les instructions ensemble. Le programme suivant est syntaxiquement correct même si le résultat n'est pas celui désiré. \indexfr{indentation}\label{remark_indentation} \vspaceneg
%
\begin{verbatimxnocut}
x = 1
if x > 0 :
   signe = 1
   print "le nombre est positif"
else :   
   signe = -1
print "le nombre est négatif"  # ligne mal indentée
print "signe = ", signe
\end{verbatimxnocut}
%
\vspaceneg
Une ligne est mal indentée (\texttt{print "le nombre est négatif"}). Elle ne devrait être exécutée que si la condition \codes{x >0} n'est pas vérifiée. Le fait qu'elle soit alignée avec les premières instructions du programme fait que son exécution n'a plus rien à voir avec cette condition. La programme répond de manière erronée~:
\vspaceneg
%
\begin{verbatimx}
le nombre est positif
le nombre est négatif
signe = 1
\end{verbatimx}
%
\vspaceneg
Dans certains cas, l'interpréteur \pythons ne sait pas à quel bloc attacher une instruction, c'est le cas de l'exemple suivant, la même ligne a été décalée de deux espaces, ce qui est différent de la ligne qui précède et de la ligne qui suit.
\vspaceneg
%
\begin{verbatimxnocut}
x = 1
if x > 0 :
    signe = 1
    print "le nombre est positif"
else :   
    signe = -1
  print "le nombre est négatif"     # ligne mal indentée
print "signe = ", signe
\end{verbatimxnocut}
%
\vspaceneg
L'interpréteur retourne l'erreur suivante~:
\vspaceneg
%
\begin{verbatimx}
  File "test.py", line 7
    print "le nombre est négatif" 
                                 ^
IndentationError: unindent does not match any outer indentation level
\end{verbatimx}
\end{xremark} 



                
\subsection{Comparaisons possibles}    
\label{par_comparaison}            
%
Les comparaisons possibles entre deux entités sont avant tout numériques mais ces opérateurs peuvent être définis pour tout type (voir chapitre~\ref{chap_classe}), notamment sur les chaînes de caractères pour lesquelles les opérateurs de comparaison transcrivent l'ordre alphabétique.

						            \indexsymbol{<}\indexsymbol{>}
						            \indexsymbol{<=}\indexsymbol{>=}
						            \indexsymbol{==}\indexsymbol{!=}
						            \indexkeyword{is}\indexkeyword{in}\indexkeyword{not}
            \begin{center}\begin{tabularx}{\textwidth}{|lX|}\hline
            \codes{<}        ,    \codes{>}                      &        inférieur, supérieur            \\ \hline
            \codes{<=}    , \codes{>=}                  &        inférieur ou égal, supérieur ou égal            \\ \hline
            \codes{==}    , \codes{!=}                    &        égal, différent            \\ \hline
            \codes{is}  , \codes{not \; is}     &        %\begin{minipage}{10cm}
                                                        \codes{x \; is \; y} vérifie que \codes{x} et \codes{y} 
                                                        sont égaux, \codes{not \; is}, différents, 
                                                        l'opérateur \codes{is} est différent de l'opérateur \codes{==},
                                                        il est expliqué au paragraphe~\ref{par_liste_copie}
                                                        (page~\pageref{par_liste_copie}).
                                                                                        %\end{minipage}            
                                                                                        \\ \hline
            \codes{in}, \codes{not \; in}            &        appartient, n'appartient pas            \\ \hline
            \end{tabularx}\end{center}

            
\subsection{Opérateurs logiques}                
\label{par_operateur_logique}            
%
%
Il existe trois opérateurs logiques qui combinent entre eux les conditions.
%
        \indexkeyword{and}\indexkeyword{or}\indexkeyword{not}
        \begin{center}\begin{tabular}{|ll|ll|ll|} \hline
        \codes{not}            & négation & %\\ \hline
        \codes{and}            & et logique & %\\ \hline
        \codes{or}            & ou logique \\ \hline
        \end{tabular}\end{center}
%        
%           
\begin{xremark}{priorité des opérations}
La priorité des opérations numériques est identique à celle rencontrée en mathématiques. L'opérateur puissance vient en premier, la multiplication/division ensuite puis l'addition/soustraction. Ces opérations sont prioritaires sur les opérateurs de comparaisons (\codes{>}, \codes{<}, \codes{==}, ...) qui sont eux-mêmes sur les opérateurs logiques \codes{not}, \codes{and}, \codes{or}. Il est tout de même conseillé d'ajouter des parenthèses en cas de doute. \label{priorite_operation}\indexfrr{opérateur}{priorité}
\end{xremark}

\subsection{Ecriture condensée}
%
Il existe deux écritures condensées de tests. La première consiste à écrire un test et l'unique instruction qui en dépend sur une seule ligne.
%
\indexsyntaxenoc{test condensé}\indexsyntaxecod{if\;elif\;else}\vspaceneg
\begin{center}\begin{tabular}{@{}llr@{}}
\begin{minipage}{4.7cm}
\begin{verbatimx}
if condition :
    instruction1
else :
    instruction2
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{3.5cm}
Ce code peut tenir en deux lignes~:        
\end{minipage}
%
\begin{minipage}{5.1cm}
\begin{verbatimx}
if condition : instruction1
else : instruction2


\end{verbatimx}
\end{minipage}
\end{tabular}
\end{center}
%
%
Le second cas d'écriture condensée concerne les comparaisons enchaînées. Le test \codes{if \; 3 < x \; and \; x < 5 : instruction} peut être condensé par \codes{if \; 3 < x < 5 : instruction}. Il est ainsi possible de juxtaposer autant de comparaisons que nécessaire~: \codes{if \; 3 < x < y < 5 : instruction}.

Le mot-clé \codes{in} permet également de condenser certains tests lorsque la variable à tester est entière. \codes{if \; x == 1 \; or \; x == 6  \; or \; x == 50 :} peut être résumé simplement par \codes{if \; x \; in \; (1,6,50) :}.






\subsection{Exemple}
\indexexemples{test}{}
%
L'exemple suivant associe à la variable \codes{signe} le signe de la variable \codes{x}.\vspaceneg
%
\begin{center}\begin{tabular}{@{}llr@{}}
\begin{minipage}{4.7cm}
\begin{verbatimx}
x = -5
if x < 0 :
   signe = -1
elif x == 0 :
   signe = 0
else :
   signe = 1
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{4cm}
Son écriture condensée lorsqu'il n'y a qu'une instruction à exécuter~:
\end{minipage}
%
\begin{minipage}{4.6cm}
\begin{verbatimx}
x = -5
if x < 0 : signe = -1
elif x == 0 : signe = 0
else : signe = 1



\end{verbatimx}
\end{minipage}
\end{tabular}
\end{center}

\vspaceneg
Le programme suivant saisit une ligne au clavier et dit si c'est "oui" ou "non" qui a été saisi. \indexfonctionbis{raw\_input}
\vspaceneg
%
\begin{verbatimx}
s = raw_input ("dites oui : ")    # voir remarque suivante
if s == "oui" or s [0:1] == "o" or s [0:1] == "O" or s == "1" :
       print "oui"
else : print "non"
\end{verbatimx}

\begin{xremark}{fonction \codes{raw\_input}}
La fonction \codes{raw\_input}\indexfonction{raw\_input} invite l'utilisateur d'un programme à saisir une réponse lors de l'exécution du programme. Tant que la touche entrée n'a pas été pressée, l'exécution du programme ne peut continuer. Cette fonction est en réalité peu utilisée. Les interfaces graphiques sont faciles d'accès en \python, on préfère donc saisir une réponse via une fenêtre plutôt qu'en ligne de commande. L'exemple suivant montre comment remplacer cette fonction à l'aide d'une fenêtre graphique, le résultat apparaît dans la figure~\ref{raw_input_window_try}. On peut améliorer la fonction \codes{question} en précisant une valeur par défaut par exemple, le chapitre~\ref{chap_interface} sera plus explicite à ce sujet. \label{rawinput_programme_label}
\inputcode{../python_cours/programme/rawinput.py}{version graphique de la fonction \codesindex{raw\_input}}
%
					\begin{figure}[ht]
					\begin{center}\begin{tabular}{|c|} \hline
					\includegraphics[width=13.5cm]{\filextellipse{../python_cours/image/rawinput}
					{../python_cours/image_ellipse/rawinput}} \\ \hline
          \end{tabular}\end{center}
          \caption{Fenêtre apparaissant lors de l'exécution du programme page~\pageref{rawinput_programme_label} proposant 
          				 une version graphique de la fonction \codescaption{raw\_input}.}
          \label{raw_input_window_try}
          \end{figure}
%
\end{xremark}

\begin{xremark}{\codes{if \; None}, \codes{if \; 0}}
L'écriture de certains tests peut encore être réduite lorsqu'on cherche à comparer une variable entière, booléenne ou \codes{None} comme le précise le tableau~\ref{table_short_cuts_test}.\ifnotellipse{\indexfrr{test}{\codesindex{if \; None}}\indexfrr{test}{\codesindex{if \; 0}}}\indexfr{\codesindex{None}}\indexfr{test}
\end{xremark}

\begin{table}[ht]
\begin{center}\begin{tabularx}{\textwidth}{@{}Xr@{}}
%\begin{minipage}{4cm}
\caption{Ce tableau précise le sens de certains tests lorsque leur écriture est tronquée. On suppose que \codes{v} est une variable.}
%\end{minipage}
&
\begin{footnotesize}
\begin{tabular}{|l|l|l|} \hline
\textbf{type} & \textbf{test} 				& \textbf{test équivalent} \\ \hline
\texttt{bool}  & \texttt{if v :} 			& \texttt{if v == True :} \\
\texttt{bool}  & \texttt{if not v :} 	& \texttt{if v == False :} \\ \hline
\texttt{int}   & \texttt{if v :} 			& \texttt{if v != 0 :} \\
\texttt{int}   & \texttt{if not v :} 	& \texttt{if v == 0 :} \\ \hline
\texttt{float} & \texttt{if v :} 			& \texttt{if v != 0.0 :} \\
\texttt{float} & \texttt{if not v :} 	& \texttt{if v == 0.0 :} \\ \hline
\texttt{None}  & \texttt{if v :} 			& \texttt{if v != None :} \\
\texttt{None}  & \texttt{if not v :} 	& \texttt{if v == None :} \\ \hline
\end{tabular}
\end{footnotesize}
\end{tabularx}
\end{center}
\label{table_short_cuts_test}
\end{table}




\subsection{Passer, instruction \codes{pass}}
\indexkeyword{pass}
%
Dans certains cas, aucune instruction ne doit être exécutée même si un test est validé. En \python, le corps d'un test ne peut être vide, il faut utiliser l'instruction \codes{pass}. Lorsque celle-ci est manquante, \pythons affiche un message d'erreur. \vspaceneg
%
\begin{verbatimx}
signe = 0
x = 0
if x < 0 : signe = -1
elif x == 0:
   pass          # signe est déjà égal à 0
else : signe = 1   
\end{verbatimx}
%
\vspaceneg
Dans ce cas précis, si l'instruction \codes{pass} est oubliée, l'interpréteur \pythons génère l'erreur suivante~:
\vspaceneg
\begin{verbatimx}
File "nopass.py", line 6
    else :
    ^
IndentationError: expected an indented block
\end{verbatimx}







\section{Boucles}
\indexfr{boucle}\indexkeyword{while}\indexkeyword{for}\indexkeyword{in}\indexsymbol{\:}
%
        \begin{xdefinition}{boucle}\label{def_boucle}
        Les boucles permettent de répéter une séquence d'instructions tant qu'une certaine condition
        est vérifiée.
        \end{xdefinition}
        
Le langage \pythons propose deux types de boucles. La boucle \codes{while} suit scrupuleusement la définition~\ref{def_boucle}. La boucle \codes{for} est une boucle \codes{while} déguisée (voir paragraphe~\ref{boucle_for}), elle propose une écriture simplifiée pour répéter la même séquence d'instructions pour tous les éléments d'un ensemble.



\subsection{Boucle \codes{while}}
\indexsymbol{:}

\subsubsection{Syntaxe et exemples}
\indexkeyword{while}
L'implémentation d'une boucle de type \codes{while} suit le schéma d'écriture suivant~:


\begin{xsyntax}{boucle \codes{while}}
\begin{verbatimno}

while cond : 
    instruction 1
    ...
    instruction n
\end{verbatimno}
\negvspace    
Où \codes{cond} est une condition qui détermine la poursuite de la répétition des instructions incluses dans la boucle. Tant que celle-ci est vraie, les instructions $1$ à $n$ sont exécutées.
\indexsyntaxecod{while}
\end{xsyntax}

\indexfr{indentation}
Tout comme les tests, la remarque~\ref{remark_indentation} concernant l'indentation reste vraie. Le décalage des lignes d'un cran vers la droite par rapport à l'instruction \codes{while} permet de les inclure dans la boucle comme le montre l'exemple suivant. \vspaceneg
%
\begin{center}\begin{tabular}{@{}llr@{}}
\begin{minipage}{5.7cm}
\begin{verbatimx}
n = 0
while n < 3:
   print "à l'intérieur ", n
   n += 1
print "à l'extérieur ", n   
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{2cm}
Résultat~:
\end{minipage}
&
\begin{minipage}{5.2cm}
\begin{verbatimx}
à l'intérieur  0
à l'intérieur  1
à l'intérieur  2
à l'extérieur  3

\end{verbatimx}
\end{minipage}
\end{tabular}
\end{center}



\subsubsection{Condition}
%
Les conditions suivent la même syntaxe que celles définies lors des tests (voir paragraphes~\ref{par_comparaison} et~\ref{par_operateur_logique}). A moins d'inclure l'instruction \codes{break}\footnote{L'instruction \codesnote{break} est décrite au paragraphe~\ref{bbrak_instruction_par}, page~\pageref{bbrak_instruction_par}.} qui permet de sortir prématurément d'une boucle, la condition qui régit cette boucle doit nécessairement être modifiée à l'intérieur de celle-ci. Dans le cas contraire, on appelle une telle boucle une \emph{boucle infinie} puisqu'il est impossible d'en sortir. \indexfrr{boucle}{infinie} L'exemple suivant contient une boucle infinie car le symbole \codes{=} est manquant dans la dernière instruction. La variable \codes{n} n'est jamais modifiée et la condition \codes{n<3} toujours vraie.\vspaceneg
%
\begin{verbatimx}
n = 0
while n < 3 :
   print n
   n + 1        # n n'est jamais modifié, l'instruction correcte serait n += 1
\end{verbatimx}







\subsection{Boucle \codes{for}}
\label{boucle_for}\indexsymbol{:}

\subsubsection{Syntaxe et exemples}
\indexkeyword{for}
L'implémentation d'une boucle de type \codes{for} suit le schéma d'écriture suivant~:


\begin{xsyntax}{boucle \codes{for}}
\begin{verbatimno}

for x in set :
    instruction 1
    ...
    instruction n
\end{verbatimno}
\negvspace
Où \codes{x} est un élément de l'ensemble \codes{set}. Les instructions $1$ à $n$ sont exécutées pour chaque élément \codes{x} de l'ensemble \codes{set}. Cet ensemble peut être une chaîne de caractères, un T-uple, une liste, un dictionnaire ou tout autre type incluant des itérateurs qui sont présentés au chapitre~\ref{chap_classe} concernant les classes (page~\pageref{chap_iterateur}).\indexsyntaxecod{for}
\end{xsyntax}


\indexfr{indentation}
Tout comme les tests, la remarque~\ref{remark_indentation} concernant l'indentation reste vraie. L'exemple suivant affiche tous les éléments d'un T-uple à l'aide d'une boucle \codes {for}.\vspaceneg
%
\begin{verbatimx}
t = (1,2,3,4)
for x in t:       # affiche les nombres 1,2,3,4
    print x       # chacun sur une ligne différente
\end{verbatimx}
%
\vspaceneg
Lors de l'affichage d'un dictionnaire, les éléments n'apparaissent pas triés ni dans l'ordre dans lequel ils y ont été insérés. L'exemple suivant montre comment afficher les clés et valeurs d'un dictionnaire dans l'ordre croissant des clés.  \vspace{-0.2cm}\indexexemples{clés croissantes}{}
%
\begin{verbatimx}
d = { 1:2, 3:4, 5:6, 7:-1, 8:-2 }
print d                # affiche le dictionnaire {8: -2, 1: 2, 3: 4, 5: 6, 7: -1}
k = d.keys ()
print k                # affiche les clés [8, 1, 3, 5, 7]
k.sort ()
print k                # affiche les clés triées [1, 3, 5, 7, 8]
for x in k:            # affiche les éléments du dictionnaire 
    print x,":",d [x]  # triés par clés croissantes
\end{verbatimx}
\vspaceneg
Le langage \pythons propose néanmoins la fonction \codes{sorted} qui réduit l'exemple suivant en trois lignes~:\indexfonction{sorted}
\vspaceneg
\begin{verbatimx}
d = { 1:2, 3:4, 5:6, 7:-1, 8:-2 }
for x in sorted(d):    # pour les clés dans l'ordre croissant
    print x,":",d [x]
\end{verbatimx}
\vspaceneg

%
\indexfonctionbis{range}\indexfonctionbis{xrange} \vspace{-0.2cm}
La boucle la plus répandue est celle qui parcourt des indices entiers compris entre $0$ et $n-1$. On utilise pour cela la boucle \codes{for} et la fonction \codes{range} ou \codes{xrange} comme dans l'exemple qui suit. La différence entre ces deux fonctions a déjà été présentée au paragraphe~\ref{fonction_range_xrange} (page~\pageref{fonction_range_xrange}). \vspace{-0.2cm}
%
\begin{verbatimx}
sum = 0
N   = 10
for n in range(0,N):     # ou for n in xrange(0,N):  (plus rapide)
   sum += n              # additionne tous les entiers compris entre 0 et N-1
\end{verbatimx}
%
\vspace{-0.2cm}Ou encore pour une liste quelconque~: \vspace{-0.2cm}
%
\begin{verbatimx}
l   = [ 4, 5, 3, -6, 7, 9]
sum = 0
for n in range(0,len (l)):  # ou for n in xrange(0,len (l)) :  (plus rapide)
   sum += l [n]             # additionne tous les éléments de l
\end{verbatimx}



\subsubsection{Listes et boucle \codes{for}}
\indexfrr{type}{liste}\indextype{list}\label{liste_for_raccourci2}
%
Le paragraphe~\ref{liste_for_raccourci} a montré comment le mot-clé \codes{for} peut être utilisé pour simplifier la création d'une liste à partir d'une autre. La syntaxe suit le schéma suivant~: \vspace{-0.2cm}

\begin{xsyntax}{boucle \codes{for}}
\begin{verbatimno}

[ expression for x in ensemble ]
\end{verbatimno}
\negvspace
Où \codes{expression} est une expression numérique incluant ou non \codes{x}, la variable de la boucle, \codes{ensemble} est un ensemble d'éléments, T-uple, liste, dictionnaire.\indexsyntaxecod{for}
\end{xsyntax}

Cette syntaxe permet de résumer en une ligne la création de la séquence \codes{y} du programme suivant. \vspace{-0.2cm}
%
\begin{verbatimx}
y = list ()
for i in range(0,5) : 
   y.append (i+1)
print y             # affiche [1,2,3,4,5]        
\end{verbatimx}    
%
\vspaceneg Les trois lignes du milieu sont maintenant résumées en une seule~:\vspaceneg
%
\begin{verbatimx}
y = [ i+1 for i in range(0,5)] # résume trois lignes du programme précédent
print y                        # affiche [1,2,3,4,5]        
\end{verbatimx}    
%
\vspaceneg Un autre exemple de cette syntaxe réduite a été présenté au paragraphe~\ref{liste_for_raccourci} page~\pageref{liste_for_raccourci}. Cette écriture condensée est bien souvent plus lisible même si tout dépend des préférences de celui qui programme.





\subsubsection{Itérateurs}\label{paragraphe_tterafsd_syntaxe}

Toute boucle \codes{for} peut s'appliquer sur un objet muni d'un itérateur tels que les chaînes de caractères, T-uples, les listes, les dictionnaires. \vspaceneg
%
\begin{verbatimx}
d = ["un", "deux", "trois"]
for x in d: 
   print x          # affichage de tous les éléments de d
\end{verbatimx}
%
\vspaceneg 
Cette syntaxe réduite a déjà été introduite pour les listes et les dictionnaires au chapitre précédent. Il existe une version équivalente avec la boucle \codes{while} utilisant de façon explicite les itérateurs. Il peut être utile de lire le chapitre suivant sur les classes et le chapitre~\ref{chap_exception} sur les exceptions avant de revenir sur la suite de cette section qui n'est de toutes façons pas essentielle.
%
\indexfr{itérateur}
L'exemple précédent est convertible en une boucle \codes{while} en faisant apparaître explicitement les itérateurs (voir paragraphe~\ref{chap_iterateur}). Un itérateur est un objet qui permet de parcourir aisément un ensemble. La fonction \codes{it = iter (e)} permet d'obtenir un itérateur \codes{it} sur l'ensemble~\codes{e}. L'appel à l'instruction \codes{it.next ()} parcourt du premier élément jusqu'au dernier en retournant la valeur de chacun d'entre eux. Lorsqu'il n'existe plus d'élément, l'exception \codes{StopIteration} est déclenchée (voir paragraphe~\ref{chap_exception}). Il suffit de l'intercepter pour mettre fin au parcours.\indexexemples{itérateur}{}
\vspaceneg
%
\begin{verbatimx}
d = ["un", "deux", "trois"]
it = iter (d)                     # obtient un itérateur sur d
while True:
    try: x = it.next ()           # obtient l'élément suivant, s'il n'existe pas
    except StopIteration: break   # déclenche une exception
    print x                       # affichage de tous les éléments de d
\end{verbatimx}


\subsubsection{Plusieurs variables de boucles}

Jusqu'à présent, la boucle \codes{for} n'a été utilisée qu'avec une seule variable de boucle, comme dans l'exemple suivant où on parcourt une liste de T-uple pour les afficher. \vspaceneg
%
\begin{verbatimx}
d = [ (1,0,0), (0,1,0), (0,0,1) ]
for v in d: print v
\end{verbatimx}
%
\vspaceneg 
Lorsque les éléments d'un ensemble sont des T-uples, des listes ou des dictionnaires composés de taille fixe, il est possible d'utiliser une notation qui rappelle les affectations multiples (voir paragraphe~\ref{affectation_multiple}). L'exemple précédent devient dans ce cas~: \vspaceneg
\indexfrr{affectation}{multiple}
%
\begin{verbatimx}
d = [ (1,0,0), (0,1,0), (0,0,1) ]
for x,y,z in d: print x,y,z
\end{verbatimx}
%
\vspaceneg
Cette écriture n'est valable que parce que chaque élément de la liste \codes{d} est un T-uple composé de trois nombres. Lorsqu'un des éléments est de taille différente à celle des autres, comme dans l'exemple suivant, une erreur survient. \vspaceneg
%
\begin{verbatimx}
d = [ (1,0,0), (0,1,0,6), (0,0,1) ]  # un élément de taille quatre
for x,y,z in d: print x,y,z
\end{verbatimx}
%
\vspaceneg 
Ce programme génère l'erreur suivante~:\vspaceneg 
%
\begin{verbatimx}
Traceback (most recent call last):
  File "c:\temp\delete.py", line 2, in -toplevel-
    for x,y,z in d: print x,y,z
ValueError: unpack tuple of wrong size
\end{verbatimx}
%
\indexfonctionbis{zip}\ifnotellipse{\indexfr{séquence}}
\vspaceneg 
Cette syntaxe est très pratique associée à la fonction \codes{zip} (voir paragraphe~\ref{fonction_zip}). Il est alors possible de parcourir plusieurs séquences (T-uple, liste, dictionnaire) simultanément. \vspaceneg
%
\begin{center}
\begin{tabular}{@{}ll@{}}
\begin{minipage}{6.7cm}
\begin{verbatimx}
a = range(0,5)
b = [x**2 for x in a]
for x,y in zip (a,b):
    print y, " est le carré de ", x
    # affichage à droite
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{6.7cm}
\begin{verbatimx}
0  est le carré de  0
1  est le carré de  1
4  est le carré de  2
9  est le carré de  3
16  est le carré de  4
\end{verbatimx}
\end{minipage}
\end{tabular}
\end{center}






\subsection{Ecriture condensée}

Comme pour les tests, lorsque les boucles ne contiennent qu'une seule instruction, il est possible de l'écrire sur la même ligne que celle de la déclaration de la boucle \codes{for} ou \codes{while}. \vspaceneg
%
\begin{verbatimx}
d = ["un", "deux", "trois"]
for x in d: print x          # une seule instruction
\end{verbatimx}
%
\vspaceneg Il existe peu de cas où la boucle \codes{while} s'écrit sur une ligne car elle inclut nécessairement une instruction permettant de modifier la condition d'arrêt. \vspaceneg
%
\begin{verbatimx}
d = ["un", "deux", "trois"]
i = 0
while d [i] != "trois" : i += 1
print "trois a pour position ", i
\end{verbatimx}





\subsection{Pilotage d'une boucle}

\subsubsection{Passer à l'itération suivante~: \codes{continue}}
\indexfrr{boucle}{itération suivante}\indexkeyword{continue}\indexfrr{boucle}{\codesindex{continue}}

\indexfr{crible d'Eratosthène}\indexfrr{nombre}{premier}\indexfr{Eratosthène}
Pour certains éléments d'une boucle, lorsqu'il n'est pas nécessaire d'exécuter toutes les instructions, il est possible de passer directement à l'élément suivant ou l'itération suivante. Le programme suivant utilise la crible d'Eratosthène\footnote{Le crible d'Eratosthène est un algorithme permettant de déterminer les nombres premiers. Pour un nombre premier~$p$, il paraît plus simple de considérer tous les entiers de $p-1$~à~$1$ pour savoir si l'un d'eux divise~$p$. C'est ce qu'on fait lorsqu'on doit vérifier le caractère premier d'un seul nombre. Pour plusieurs nombres à la fois, le crible d'Eratosthène est plus efficace~: au lieu de s'intéresser aux diviseurs, on s'intéresse aux multiples d'un nombre. Pour un nombre~$i$, on sait que $2i$, $3i$, ... ne sont pas premiers. On les raye de la liste. On continue avec $i+1$, $2(i+1)$, $3(i+1)$...} pour dénicher tous les nombres premiers compris entre 1~et~99. \vspaceneg\indexexemples{Eratosthène}{}
%
\begin{verbatimx}
d = dict ()
for i in range(1,100):            # d [i] est vrai si i est un nombre premier
    d [i] = True                  # au début, comme on ne sait pas, on suppose
                                  # que tous les nombres sont premiers
for i in range(2,100):
                                  # si d [i] est faux, 
   if not d [i]: continue         # les multiples de i ont déjà été cochés
                                  # et peut passer à l'entier suivant
   for j in range (2,100):        
       if i*j < 100: 
           d [i*j] = False        # d [i*j] est faux pour tous les multiples de i
                                  # inférieurs à 100
print "liste des nombres premiers"       
for i in d:
    if d [i]: print i
\end{verbatimx}
%
\vspaceneg Ce programme est équivalent au suivant~: \vspaceneg	
%
\begin{verbatimx}
d = dict ()
for i in range(1,100): d [i] = True

for i in range(2,100):
   if d [i]:                       
       for j in range (2,100):     
           if i*j < 100 : 
               d [i*j] = False

print "liste des nombres premiers"       
for i in d:
    if d [i]: print i
\end{verbatimx}
%
\vspaceneg 
Le mot-clé \codes{continue} évite de trop nombreuses indentations et rend les programmes plus lisibles.


\subsubsection{Sortie prématurée~: \codes{break}}  \label{bbrak_instruction_par}\indexfrr{boucle}{\codesindex{break}}

Lors de l'écriture d'une boucle \codes{while}, il n'est pas toujours adéquat de résumer en une seule condition toutes les raisons pour lesquelles il est nécessaire d'arrêter l'exécution de cette boucle. De même, pour une boucle \codes{for}, il n'est pas toujours utile de visiter tous les éléments de l'ensemble à parcourir. C'est le cas par exemple lorsqu'on recherche un élément, une fois qu'il a été trouvé, il n'est pas nécessaire d'aller plus loin. L'instruction \codes{break} permet de quitter l'exécution d'une boucle.
\indexfrr{boucle}{sortie prématurée}\indexkeyword{break}\vspaceneg
%
\begin{verbatimx}
l = [6,7,5,4,3]
n = 0
c = 5
for x in l:
   if x == c: break   # l'élément a été trouvé, on sort de la boucle
   n += 1             # si l'élément a été trouvé, cette instruction 
                      # n'est pas exécutée
print "l'élément ",c, " est en position ",
print n               # affiche l'élément 5 est en position 2
\end{verbatimx}
%
\vspaceneg
Si deux boucles sont imbriquées, l'instruction \codes{break} ne sort que de la boucle dans laquelle elle est insérée. L'exemple suivant vérifie si un entier est la somme des carrés de deux entiers compris entre 1 et 20.
\vspaceneg
%
\begin{verbatimx}
set = range (1,21)
n = 53
for x in set:
    for y in set:
        c = x*x + y*y
        if c == n: break
    if c == n: break   # cette seconde instruction break est nécessaire 
                       # pour sortir de la seconde boucle 
                       # lorsque la solution a été trouvée
if c == n:
    # le symbole \ permet de passer à la ligne sans changer d'instruction
    print n, " est la somme des carrés de deux entiers :", \  
          x, "*", x, "+", y, "*", y, "=", n
else:
    print n, " n'est pas la somme des carrés de deux entiers"
\end{verbatimx}
%
\vspaceneg Le programme affiche~: \vspaceneg
%
\begin{verbatimx}
53  est la somme des carrés de deux entiers : 2 * 2 + 7 * 7 = 53
\end{verbatimx}






\subsubsection{Fin normale d'une boucle~: \codes{else}}
\indexkeyword{else}\indexfrr{boucle}{fin normale d'une boucle}

Le mot-clé \codes{else} existe aussi pour les boucles et s'utilise en association avec le mot-clé \codes{break}. L'instruction \codes{else} est placée à la fin d'une boucle, indentée au même niveau que \codes{for} ou \codes{while}. Les lignes qui suivent le mot-clé \codes{else} ne sont exécutées que si aucune instruction \codes{break} n'a été rencontrée dans le corps de la boucle. On reprend l'exemple du paragraphe précédent. On recherche cette fois-ci la valeur 1 qui ne se trouve pas dans la liste \codes{L}. Les lignes suivant le test \codes{if \; x == c} ne seront jamais exécutées au contraire de la dernière.\vspaceneg
%
\begin{verbatimx}
L = [6,7,5,4,3]
n = 0
c = 1
for x in L :
   if x == c :
       print "l'élément ", c, " est en position ", n
       break  
   n += 1      
else:
   print "aucun élément ", c, " trouvé"  # affiche aucun élément  1  trouvé
\end{verbatimx}
%
\vspaceneg
Les lignes dépendant de la clause \codes{else} seront exécutées dans tous les cas où l'exécution de la boucle n'est pas interrompue par une instruction \codes{break} ou une instruction \codes{return}\footnote{voir les fonctions au paragraphe~\ref{chap_fonction}} ou par la levée d'une exception\footnote{voir paragraphe~\ref{chap_exception}}.




\subsubsection{Suppression ou ajout d'éléments lors d'une boucle}

En parcourant la liste en se servant des indices, il est possible de supprimer une partie de cette liste. Il faut néanmoins faire attention à ce que le code ne produise pas d'erreur comme c'est le cas pour le suivant. La boucle \codes{for} parcourt la liste \codes{range (0, len (li))} qui n'est pas modifiée en même temps que l'instruction \codes{del \; li [i:i+2]}.\vspaceneg\indexexemples{suppression}{}
%
\begin{verbatimx}
li = range (0,10)
print li                # affiche [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for i in range (0, len (li)):
    if i == 5 :
        del li [i:i+2]
    print li [i]        # affiche successivement 0, 1, 2, 3, 4, 7, 8, 9 et 
                        # produit une erreur
print li
\end{verbatimx}
%
\vspaceneg
Le programme suivant marche parfaitement puisque cette fois-ci la boucle parcourt la liste \codes{li}. En revanche, pour la suppression d'une partie de celle-ci, il est nécessaire de conserver en mémoire l'indice de l'élément visité. C'est le rôle de la variable~\codes{i}.
\vspaceneg
%
\begin{verbatimx}
li = range (0,10)
print li                # affiche [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
i = 0
for t in li :
    if i == 5 : del li [i:i+2]
    i = i+1
    print t             # affiche successivement 0, 1, 2, 3, 4, 5, 8, 9
print li                # affiche [0, 1, 2, 3, 4, 7, 8, 9]
\end{verbatimx}
%
\vspaceneg
Le langage \pythons offre la possibilité de supprimer des éléments d'une liste alors même qu'on est en train de la parcourir. Le programme qui suit ne marche pas puisque l'instruction \codes{del \; i} ne supprime pas un élément de la liste mais l'identificateur \codes{i} qui prendra une nouvelle valeur lors du passage suivant dans la boucle.
\vspaceneg
%
\begin{verbatimx}
li = range (0,10)
print li                # affiche [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for i in li :
    if i == 5 : del i
print li                # affiche [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{verbatimx}
%
\vspaceneg
On pourrait construire des exemples similaires dans le cadre de l'ajout d'un élément à la liste. Il est en règle générale déconseillé de modifier une liste, un dictionnaire pendant qu'on le parcourt. Malgré tout, si cela s'avérait indispensable, il convient de faire plus attention dans ce genre de situations.






\section{Fonctions}\label{chap_fonction}\label{par_fonction}

Les fonctions sont des petits programmes qui effectuent des tâches plus précises que le programme entier. On peut effectivement écrire un programme sans fonction mais ils sont en général illisibles. Utiliser des fonctions implique de découper un algorithme en tâches élémentaires. Le programme final est ainsi plus facile à comprendre. Un autre avantage est de pouvoir plus facilement isoler une erreur s'il s'en produit une~: il suffit de tester une à une les fonctions pour déterminer laquelle retourne un mauvais résultat. L'avantage le plus important intervient lorsqu'on doit effectuer la même chose à deux endroits différentes d'un programme~: une seule fonction suffit et elle sera appelée à ces deux endroits\footnote{Pour les utilisateurs experts~: en langage \python, les fonctions sont également des variables, elles ont un identificateur et une valeur qui est dans ce cas un morceau de code. Cette précision explique certaines syntaxes du chapitre~\ref{chap_interface} sur les interfaces graphiques ou celle introduite en fin de chapitre au paragraphe~\ref{paragraphe_fonction_variable}.}.



\subsection{Définition, syntaxe}

%\subsubsection{Syntaxe}
\label{par_fonction_syntaxe}


        \indexfr{sous-programme}\indexfr{paramètre}\indexfr{résultat d'une fonction}
        \begin{xdefinition}{fonction}
        Une fonction est une partie d'un programme -~ou sous-programme~- qui fonctionne indépendamment du reste 
        du programme. Elle reçoit une liste de paramètres et retourne un résultat. Le corps de la fonction
        désigne toute instruction du programme qui est exécutée si la fonction est appelée.
        \end{xdefinition}

Lorsqu'on écrit ses premiers programme, on écrit souvent des fonctions plutôt longues avant de s'apercevoir que certains parties sont identiques ailleurs. On extrait donc la partie répétée pour en faire une fonction. Avec l'habitude, on finit par écrire des fonctions plus petites et réutilisables.



\begin{xsyntax}{fonction, définition}
\begin{verbatimno}

def fonction_nom (par_1, ..., par_n) :
    instruction_1
    ...
    instruction_n
    return res_1, ..., res_n
\end{verbatimno}
\negvspace
\codes{fonction\_nom} est le nom de la fonction, il suit les mêmes règles que le nom des variables. \codes{par\_1} à \codes{par\_n} sont les noms des paramètres et \codes{res\_1} à \codes{res\_n} sont les résultats retournés par la fonction. Les instructions associées à une fonction doivent être indentées par rapport au mot-clé \codes{def}.  \indexsyntaxecod{def}\indexkeyword{def} \indexfr{fonction}\indexkeyword{def}\indexkeyword{return}\indexsymbol{\:}\indextype{None}
\end{xsyntax}

S'il n'y a aucun résultat, l'instruction \codes{return} est facultative ou peut être utilisée seule sans être suivie par une valeur ou une variable. Cette instruction peut apparaître plusieurs fois dans le code de la fonction mais une seule d'entre elles sera exécutée. A partir de ce moment, toute autre instruction de la fonction sera ignorée. Pour exécuter une fonction ainsi définie, il suffit de suivre la syntaxe suivante~:

\begin{xsyntax}{fonction, appel}
\begin{verbatimno}

x_1, ..., x_n = fonction_nom (valeur_1, valeur_2, ..., valeur_n)
\end{verbatimno}
\negvspace
Où \codes{fonction\_nom} est le nom de la fonction, \codes{valeur\_1} à \codes{valeur\_n} sont les noms des paramètres, \codes{x\_1} à \codes{x\_n} reçoivent les résultats retournés par la fonction. Cette affectation est facultative. Si on ne souhaite pas conserver les résultats, on peut donc appeler la fonction comme suit~:
\negvspace
\begin{verbatimno}
fonction_nom (valeur_1, valeur_2, ..., valeur_n)
\end{verbatimno}
\end{xsyntax}

Lorsqu'on commence à programmer, il arrive parfois qu'on confonde le rôle des mots-clés \codes{print} et \codes{return}. Dans ce cas, il faut se reporter à la remarque~\ref{remarque_print_return_exo} page~\pageref{remarque_print_return_exo}.


\subsection{Exemple}
\label{para_fonction_exemple}

Le programme suivant utilise deux fonctions. La première convertit des coordonnées cartésiennes en coordonnées polaires. Elle prend deux réels en paramètres et retourne deux autres réels. La seconde fonction affiche les résultats de la première pour tout couple de valeurs $\pa{x,y}$. Elle ne retourne aucun résultat.\indexexemples{coordonnées polaires}{}
\vspaceneg
%
\begin{verbatimx}
import math
def coordonnees_polaires (x,y):
    rho     = math.sqrt(x*x+y*y)   # calcul la racine carrée de x*x+y*y
    theta   = math.atan2 (y,x)     # calcule l'arc tangente de y/x en tenant 
                                   # compte des signes de x et y
    return rho, theta

def affichage (x,y):
    r,t = coordonnees_polaires(x,y)
    print "cartésien (%f,%f) --> polaire (%f,%f degrés)" \
                  % (x,y,r,math.degrees(t))

affichage (1,1)
affichage (0.5,1)
affichage (-0.5,1)
affichage (-0.5,-1)
affichage (0.5,-1)
\end{verbatimx}
%
\vspaceneg
Le programme affiche les lignes suivantes~:
\vspaceneg
%
\begin{verbatimx}
cartésien (1.000000,1.000000) --> polaire (1.414214,45.000000 degrés)
cartésien (0.500000,1.000000) --> polaire (1.118034,63.434949 degrés)
cartésien (-0.500000,1.000000) --> polaire (1.118034,116.565051 degrés)
cartésien (-0.500000,-1.000000) --> polaire (1.118034,-116.565051 degrés)
cartésien (0.500000,-1.000000) --> polaire (1.118034,-63.434949 degrés)
\end{verbatimx}


\subsection{Paramètres avec des valeurs par défaut}
\indexfrr{paramètre}{valeur par défaut}\indexfr{valeur par défaut}


Lorsqu'une fonction est souvent appelée avec les mêmes valeurs pour ses paramètres, il est possible de spécifier pour ceux-ci une valeur par défaut. 


\begin{xsyntax}{fonction, valeur par défaut}
\begin{verbatimno}

def fonction_nom (param_1, param_2 = valeur_2, ..., param_n = valeur_n):
    ...
\end{verbatimno}
\negvspace
Où \codes{fonction\_nom} est le nom de la fonction. \codes{param\_1} à \codes{param\_n} sont les noms des paramètres, \codes{valeur\_2} à \codes{valeur\_n} sont les valeurs par défaut des paramètres \codes{param\_2} à \codes{param\_n}. La seule contrainte lors de cette définition est que si une valeur par défaut est spécifiée pour un paramètre, alors tous ceux qui suivent devront eux aussi avoir une valeur par défaut. \indexsyntaxecod{def}\indexkeyword{def} 
\end{xsyntax}

\vspaceneg
Exemple~:
%
\vspaceneg
\begin{verbatimx}
def commander_carte_orange (nom, prenom, paiement = "carte", nombre = 1, zone = 2):
    print "nom : ", nom
    print "prénom : ", prenom
    print "paiement : ", paiement
    print "nombre : ", nombre
    print "zone :", zone
    
commander_carte_orange ("Dupré", "Xavier", "chèque")  
        # les autres paramètres nombre et zone auront pour valeur
        # leurs valeurs par défaut
\end{verbatimx}
\vspaceneg
%
Il est impossible qu'un paramètre sans valeur par défaut associée se situe après un paramètre dont une valeur par défaut est précisée. Le programme suivant ne pourra être exécuté.
%
\vspaceneg
\begin{verbatimx}
def commander_carte_orange (nom, prenom, paiement = "carte", nombre = 1, zone):
    print "nom : ", nom
    # ...
\end{verbatimx}
Il déclenche l'erreur suivante~:
\begin{verbatimx}
  File "problem_zone.py", line 1
    def commander_carte_orange (nom, prenom, paiement = "carte", nombre = 1, zone):
SyntaxError: non-default argument follows default argument
\end{verbatimx}
\vspaceneg


\indexfrr{paramètre}{valeur par défaut, modifiable}
\begin{xremark}{valeurs par défaut de type modifiable}
Les valeurs par défaut de type modifiable (liste, dictionnaire, classes) peuvent introduire des erreurs inattendues dans les programmes comme le montre l'exemple suivant~:
%
\vspaceneg
\begin{verbatimx}
def fonction (l = [0,0]) :
    l [0] += 1
    return l
    
print fonction ()         # affiche [1,0] : résultat attendu
print fonction ()         # affiche [2,0] : résultat surprenant
print fonction ( [0,0])   # affiche [1,0] : résultat attendu
\end{verbatimx}
%
\vspaceneg
L'explication provient du fait que la valeur par défaut est une liste qui n'est pas recréée à chaque appel~: c'est la même liste à chaque fois que la fonction est appelée sans paramètre. Pour remédier à cela, il faudrait écrire~:\indexexemples{copie}{}
\vspaceneg
%
\begin{verbatimx}
import copy
def fonction (l = [0,0]) :
    l = copy.copy (l)
    l [0] += 1
    return l
\end{verbatimx}
L'exercice~\ref{ex_hypercube} (page~\pageref{ex_hypercube}) propose un exemple plus complet, voire retors.
\end{xremark}


\subsection{Ordre des paramètres}
\indexfrr{paramètre}{ordre}

Le paragraphe~\ref{par_fonction_syntaxe} a présenté la syntaxe d'appel a une fonction. Lors de l'appel, le nom des paramètres n'intervient plus, supposant que chaque paramètre reçoit pour valeur celle qui a la même position que lui lors de l'appel à la fonction. Il est toutefois possible de changer cet ordre en précisant quel paramètre doit recevoir quelle valeur.


\begin{xsyntax}{fonction, ordre des paramètres}
\begin{verbatimno}

x_1, ..., x_n = fonction_nom (param_1 = valeur_1, ..., param_n = valeur_n)
\end{verbatimno}
\negvspace
Où \codes{fonction\_nom} est le nom de la fonction, \codes{param\_1} à \codes{param\_n} sont les noms des paramètres, \codes{valeur\_1} à \codes{valeur\_n} sont les valeurs que reçoivent ces paramètres. Avec cette syntaxe, l'ordre d'écriture n'importe pas. La valeur \codes{valeur\_i} sera toujours attribuée à \codes{param\_i}. Les variables \codes{x\_1} à \codes{x\_n} reçoivent les résultats retournés par la fonction. L'ordre des résultats ne peut pas être changé. S'il y a plusieurs résultats retournés, il est impossible de choisir lesquels conserver~: soit tous, soit aucun.
\end{xsyntax}
\vspaceneg
Exemple~:
%
\vspaceneg
\begin{verbatimx}
def identite (nom, prenom):
    print "nom : ", nom, " prénom : ", prenom

identite("Xavier", "Dupré")                 # nom :  Xavier prénom :  Dupré
identite(prenom = "Xavier", nom = "Dupré")  # nom :  Dupré  prénom :  Xavier
\end{verbatimx}
%
\vspaceneg
Cette possibilité est intéressante surtout lorsqu'il y a de nombreux paramètres par défaut et que seule la valeur d'un des derniers paramètres doit être changée.
%
\vspaceneg
\begin{verbatimx}
def commander_carte_orange (paiement = "carte", nombre = 1, zone = 2):
    print "paiement : ", paiement
    print "nombre : ", nombre
    print "zone :", zone
    
commander_carte_orange (zone = 5)  # seule la valeur par défaut 
                                   # du paramètre zone sera changée
\end{verbatimx}





\subsection{Surcharge de fonction}
\indexfonctionnoc{surcharge}\indexfr{surcharge}

Contrairement à d'autres langages, \pythons n'autorise pas la surcharge de fonction. Autrement dit, il n'est pas possible que plusieurs fonctions portent le même nom même si chacune d'entre elles a un nombre différent de paramètres. 
%
\vspaceneg
\begin{verbatimx}
def fonction (a,b):
    return a + b
    
def fonction (a,b,c):
    return a + b + c

print fonction (5,6)
print fonction (5,6,7)
\end{verbatimx}
%
\vspaceneg
Le petit programme précédent est syntaxiquement correct mais son exécution génère une erreur parce que la seconde définition de la fonction \codes{fonction} efface la première.
\vspaceneg
%
\begin{verbatimx}
Traceback (most recent call last):
  File "cours4.py", line 7, in ?
    print fonction (5,6)
TypeError: fonction() takes exactly 3 arguments (2 given)
\end{verbatimx}






\subsection{Commentaires}
\indexfrr{fonction}{aide}\indexfonctionbis{help}\indexfr{aide}\indexfr{commentaire}
\indexfonction{help}

Le langage \pythons propose une fonction \codes{help} qui retourne pour chaque fonction un commentaire ou mode d'emploi qui indique comment se servir de cette fonction. L'exemple suivant affiche le commentaire associé à la fonction \codes{round}.
%
\vspaceneg
\begin{verbatimx}
>>> help (round)
\end{verbatimx}
\vspaceneg
%

\begin{verbatimx}
Help on built-in function round:

round(...)
    round(number[, ndigits]) -> floating point number
    
    Round a number to a given precision in decimal digits (default 0 digits).
    This always returns a floating point number.  Precision may be negative.
\end{verbatimx}
%
\vspaceneg
Lorsqu'on utilise cette fonction \codes{help} sur la fonction \codes{coordonnees\_polaires} définie dans l'exemple du paragraphe précédent~\ref{para_fonction_exemple}, le message affiché n'est pas des plus explicites.
\vspaceneg
%
\begin{verbatimx}
>>> help (coordonnees_polaires)
\end{verbatimx}
%
\vspaceneg
\begin{verbatimx}
Help on function coordonnees_polaires in module __main__:

coordonnees_polaires(x, y)
\end{verbatimx}
%
\vspaceneg
Pour changer ce message, il suffit d'ajouter en première ligne du code de la fonction une chaîne de caractères.
\vspaceneg
%
\begin{verbatimx}
import math
def coordonnees_polaires (x,y):
    """convertit des coordonnées cartésiennes en coordonnées polaires
    (x,y) --> (pho,theta)"""
    rho     = math.sqrt(x*x+y*y)
    theta   = math.atan2 (y,x)
    return rho, theta
help (coordonnees_polaires)
\end{verbatimx}
%
\vspaceneg
Le programme affiche alors le message d'aide suivant nettement plus explicite~:
\vspaceneg
%
\begin{verbatimx}
Help on function coordonnees_polaires in module __main__:

coordonnees_polaires(x, y)
    convertit des coordonnées cartésiennes en coordonnées polaires
    (x,y) --> (pho,theta)
\end{verbatimx}
\vspaceneg
%
Il est conseillé d'écrire ce commentaire pour toute nouvelle fonction avant même que son corps ne soit écrit. L'expérience montre qu'on oublie souvent de l'écrire après.



\subsection{Paramètres modifiables}

\indexfrr{type}{immuable}\indexfrr{type}{modifiable}
\indexfrr{paramètre}{passage par valeur}\indexfrr{paramètre}{passage par référence}
\indexfrr{paramètre}{immuable}\indexfrr{paramètre}{modifiable}


Les paramètres de types immuables et modifiables se comportent de manières différentes à l'intérieur d'une fonction. Ces paramètres sont manipulés dans le corps de la fonction, voire modifiés parfois. Selon le type du paramètre, ces modifications ont des répercussions à l'extérieur de la fonction. 

Les types immuables ne peuvent être modifiés et cela reste vrai. Lorsqu'une fonction accepte un paramètre de type immuable, elle ne reçoit qu'une copie de sa valeur. Elle peut donc modifier ce paramètre sans que la variable ou la valeur utilisée lors de l'appel de la fonction n'en soit affectée. On appelle ceci un passage de paramètre par valeur. A l'opposé, toute modification d'une variable d'un type modifiable à l'intérieur d'une fonction est répercutée à la variable qui a été utilisée lors de l'appel de cette fonction. On appelle ce second type de passage un passage par adresse.

L'exemple suivant utilise une fonction \codes{somme\_n\_premier\_terme} qui modifie ces deux paramètres. Le premier, \codes{n}, est immuable, sa modification n'a aucune incidence sur la variable \codes{nb}. En revanche, le premier élément du paramètre \codes{liste} reçoit la valeur~0. Le premier élément de la liste \codes{l} n'a plus la même valeur après l'appel de la fonction \codes{somme\_n\_premier\_terme} que celle qu'il avait avant.

\vspaceneg
\begin{verbatimx}
def somme_n_premier_terme(n,liste):
    """calcul la somme des n premiers termes d'une liste"""
    somme = 0
    for i in liste:
        somme += i
        n -= 1             # modification de n (type immuable)
        if n <= 0: break
    liste[0] = 0           # modification de liste (type modifiable)
    return somme

l = [1,2,3,4]
nb = 3
print "avant la fonction ",nb,l   # affiche   avant la fonction  3 [1, 2, 3, 4]
s = somme_n_premier_terme (nb,l)  
print "après la fonction ",nb,l   # affiche   après la fonction  3 [0, 2, 3, 4]
print "somme : ", s               # affiche   somme :  6
\end{verbatimx}

\vspaceneg
La liste \codes{l} est modifiée à l'intérieur de la fonction \codes{somme\_n\_premier\_terme} comme l'affichage suivant le montre. En fait, à l'intérieur de la fonction, la liste \codes{l} est désignée par l'identificateur \codes{liste}, c'est la même liste. La variable \codes{nb} est d'un type immuable. Sa valeur a été recopiée dans le paramètre \codes{n} de la fonction \codes{somme\_n\_premier\_terme}. Toute modification de \codes{n} à l'intérieur de cette fonction n'a aucune répercussion à l'extérieur de la fonction.


\begin{xremark}{passage par adresse}
Dans l'exemple précédent, il faut faire distinguer le fait que la liste passée en paramètre ne soit que modifiée et non changée. L'exemple suivant inclut une fonction qui affecte une nouvelle valeur au paramètre \codes{liste} sans pour autant modifier la liste envoyée en paramètre.
%
\vspaceneg
\begin{verbatimx}
def fonction (liste):
    liste = []

liste = [0,1,2]
print liste       # affiche [0,1,2]
fonction (liste)
print liste       # affiche [0,1,2]
\end{verbatimx}
%
\vspaceneg
\indexfr{identificateur}
Il faut considérer dans ce programme que la fonction \codes{fonction} reçoit un paramètre appelé \codes{liste} mais utilise tout de suite cet identificateur pour l'associer à un contenu différent. L'identificateur \codes{liste} est en quelque sorte passé du statut de paramètre à celui de variable locale. La fonction associe une valeur à \codes{liste} -~ici, une liste vide~- sans toucher à la valeur que cet identificateur désignait précédemment. 

Le programme qui suit est différent du précédent mais produit les mêmes effets. Ceci s'explique par le fait que le mot-clé \codes{del} ne supprime pas le contenu d'une variable mais seulement son identificateur. Le langage \pythons détecte ensuite qu'un objet n'est plus désigné par aucun identificateur pour le supprimer. Cette remarque est à rapprocher de celles du paragraphe~\ref{par_copie_objet}.
%
\vspaceneg
\begin{verbatimx}
def fonction (liste):
    del liste

liste = [0,1,2]
print liste       # affiche [0,1,2]
fonction (liste)
print liste       # affiche [0,1,2]
\end{verbatimx}
\vspaceneg
%
Le programme qui suit permet cette fois-ci de vider la liste \codes{liste} passée en paramètre à la fonction \codes{fonction}. La seule instruction de cette fonction modifie vraiment le contenu désigné par l'identificateur \codes{liste} et cela se vérifie après l'exécution de cette fonction.
%
\vspaceneg
\begin{verbatimx}
def fonction (liste):
    del liste[0:len(liste)]  # on peut aussi écrire : liste[:] = []

liste = [0,1,2]
print liste       # affiche [0,1,2]
fonction (liste)
print liste       # affiche []
\end{verbatimx}
\end{xremark}



\subsection{Fonction récursive}
\indexfrr{fonction}{récursive}\indexfr{récursivité}


            \begin{xdefinition}{fonction récursive}
            Une fonction récursive est une fonction qui s'appelle elle-même.
            \end{xdefinition}

La fonction récursive la plus fréquemment citée en exemple est la fonction factorielle. Celle-ci met en évidence les deux composantes d'une fonction récursive, la récursion proprement dite et la condition d'arrêt.\indexfrr{récursivité}{condition d'arrêt}\indexexemples{factorielle}{}
%
\vspaceneg
\begin{verbatimx}
def factorielle(n):
    if n == 0 : return 1
    else : return n * factorielle(n-1)
\end{verbatimx}
\vspaceneg
%
La dernière ligne de la fonction \codes{factorielle} est la récursion tandis que la précédente est la condition d'arrêt, sans laquelle la fonction ne cesserait de s'appeler, empêchant le programme de terminer son exécution. Si celle-ci est mal spécifiée ou absente, l'interpréteur \pythons affiche une suite ininterrompue de messages. \pythons n'autorise pas plus de 1000 appels récursifs~: \codes{factorielle(999)} provoque nécessairement une erreur d'exécution même si la condition d'arrêt est bien spécifiée.
%
\vspaceneg
\begin{verbatimx}
Traceback (most recent call last):
  File "fact.py", line 5, in <module>
    factorielle(999)
  File "fact.py", line 3, in factorielle
    else : return n * factorielle(n-1)
  File "fact.py", line 3, in factorielle
    else : return n * factorielle(n-1)
  ...
\end{verbatimx}
\vspaceneg
%
La liste des messages d'erreurs est aussi longue qu'il y a eu d'appels à la fonction récursive. Dans ce cas, il faut transformer cette fonction en une fonction non récursive équivalente, ce qui est toujours possible.
%
\vspaceneg
\begin{verbatimx}
def factorielle_non_recursive (n) :
    r = 1
    for i in range (2, n+1) :
        r *= i
    return r
\end{verbatimx}



\subsection{Portée}

\subsubsection{Portée des variables, des paramètres}


Lorsqu'on définit une variable, elle n'est pas utilisable partout dans le programme. Par exemple, elle n'est pas utilisable avant d'avoir été déclarée au moyen d'une affectation. Le court programme suivant déclenche une erreur.
%
\vspaceneg
\begin{verbatimx}
print x   # déclenche une erreur
\end{verbatimx}
\vspaceneg
%
\begin{verbatimx}
Traceback (most recent call last):
  File "pas_declaree.py", line 1, in <module>
    print x
NameError: name 'x' is not defined
\end{verbatimx}
\vspaceneg
%
Il est également impossible d'utiliser une variable à l'extérieur d'une fonction où elle a été déclarée. Plusieurs fonctions peuvent ainsi utiliser le même nom de variable sans qu'à aucun moment, il n'y ait confusion. Le programme suivant déclenche une erreur identique à celle reproduite ci-dessus.
%
\vspaceneg
\begin{verbatimx}
def portee_variable(x):
    var = x
    print var
    
portee_variable(3)
print var           # déclenche une erreur car var est déclarée dans
                    # la fonction portee_variable
\end{verbatimx}
\vspaceneg

            \begin{xdefinition}{portée d'une variable}\indexfrr{variable}{portée}\indexfrr{portée}{variables}
            \indexfrr{variable}{identificateur}
            La portée d'une variable associée à un identificateur 
            recouvre la portion du programme à l'intérieur de laquelle ce même identificateur
            la désigne. Ceci implique que, dans cette portion de code, aucune autre variable,
            aucune autre fonction, aucune autre classe, ne peut porter le même identificateur.
            \end{xdefinition}


Une variable n'a donc d'existence que dans la fonction dans laquelle elle est déclarée. On appelle ce type de variable une variable locale. Par défaut, toute variable utilisée dans une fonction est une variable locale.

            \begin{xdefinition}{variable locale}\indexfrr{variable}{locale}
            Une variable locale est une variable dont la portée est réduite à une fonction.
            \end{xdefinition}

Par opposition aux variables locales, on définit les variables globales qui sont déclarées à l'extérieur de toute fonction.

            \begin{xdefinition}{variable globale}\indexfrr{variable}{globale}\indexkeyword{global}
            Une variable globale est une variable dont la portée est l'ensemble du programme.
            \end{xdefinition}
            
L'exemple suivant mélange variable locale et variable globale. L'identificateur \codes{n} est utilisé à la fois pour désigner une variable globale égale à~1 et une variable locale égale à~1. A l'intérieur de la fonction, \codes{n} désigne la variable locale égale à~2. A l'extérieur de la fonction, \codes{n} désigne la variable globale égale à~1.
%        
\vspaceneg
\begin{verbatimx}
n = 1                   # déclaration d'une variable globale
def locale_globale():
    n = 2               # déclaration d'une variable locale
    print n             # affiche le contenu de la variable locale

print n                 # affiche 1
locale_globale()        # affiche 2
print n                 # affiche 1
\end{verbatimx}
%
\vspaceneg
\indexkeyword{global}
Il est possible de faire référence aux variables globales dans une fonction par l'intermédiaire du mot-clé \codes{global}. Celui-ci indique à la fonction que l'identificateur \codes{n} n'est plus une variable locale mais désigne une variable globale déjà déclarée.
%
\vspaceneg
\begin{verbatimx}
n = 1                   # déclaration d'une variable globale
def locale_globale():
    global n            # cette ligne indique que n désigne la variable globale
    n = 2               # change le contenu de la variable globale
    print n             # affiche le contenu de la variable globale

print n                 # affiche 1
locale_globale()        # affiche 2
print n                 # affiche 2
\end{verbatimx}
\vspaceneg
%
Cette possibilité est à éviter le plus possible car on peut considérer que \codes{locale\_globale} est en fait une fonction avec un paramètre caché. La fonction \codes{locale\_globale} n'est plus indépendante des autres fonctions puisqu'elle modifie une des données du programme.







\subsubsection{Portée des fonctions}
\indexfrr{fonction}{portée}\indexfrr{portée}{fonctions}

\indexfrr{fonction}{locale}\indexfrr{fonction}{imbriquée}
Le langage \pythons considère les fonctions également comme des variables d'un type particulier. La portée des fonctions obéit aux mêmes règles que celles des variables. Une fonction ne peut être appelée que si elle a été définie avant son appel. 
%
\vspaceneg
\begin{verbatimx}
print type(factorielle)  # affiche <type 'function'>
\end{verbatimx}
\vspaceneg
%
Comme il est possible de déclarer des variables locales, il est également possible de définir des fonctions locales ou fonctions imbriquées. Une fonction locale n'est appelable qu'à l'intérieur de la fonction dans laquelle elle est définie. Dans l'exemple suivant, la fonction \codes{affiche\_pair} inclut une fonction locale qui n'est appelable que par cette fonction \codes{affiche\_pair}.
%
\vspaceneg
\begin{verbatimx}
def affiche_pair():
    def fonction_locale(i):            # fonction locale ou imbriquée
        if i % 2 == 0 : return True
        else : return False
    for i in range(0,10):
        if fonction_locale(i):
            print i
    
affiche_pair()
fonction_locale(5)      # l'appel à cette fonction locale 
                        # déclenche une erreur d'exécution
\end{verbatimx}
\vspaceneg
%
A l'intérieur d'une fonction locale, le mot-clé \codes{global} désigne toujours les variables globales du programme et non les variables de la fonction dans laquelle cette sous-fonction est définie.






\subsection{Nombre de paramètres variable} \label{nombr_eparam_variable_ref}
\indexfrr{paramètre}{nombre variable}


Il est possible de définir des fonctions qui prennent un nombre indéterminé de paramètres, lorsque celui-ci n'est pas connu à l'avance. Hormis les paramètres transmis selon le mode présenté dans les paragraphes précédents, des informations peuvent être ajoutées à cette liste lors de l'appel de la fonction, ces informations sont regroupées soit dans une liste de valeurs, soit dans une liste de couples (identificateur, valeur). La déclaration d'une telle fonction obéit à la syntaxe suivante~:

\begin{xsyntax}{fonction, nombre variable de paramètres}
\begin{verbatimno}

def fonction (param_1, ..., param_n, *liste, **dictionnaire) : 
\end{verbatimno}
\negvspace
Où \codes{fonction} est un nom de fonction, \codes{param\_1} à \codes{param\_n} sont des paramètres de la fonction, \codes{liste} est le nom de la liste qui doit recevoir la liste des valeurs seules envoyées à la fonction et qui suivent les paramètres (plus précisément, c'est un tuple),  \codes{dictionnaire} reçoit la liste des couples (identificateur, valeur). \indexsyntaxecod{def}\indexkeyword{def}
\end{xsyntax}

L'appel à cette fonction suit quant à lui la syntaxe suivante~:

\begin{xsyntax}{fonction, nombre variable de paramètres (appel)}
\begin{verbatimno}

fonction (valeur_1, ..., valeur_n, \
          liste_valeur_1, ..., liste_valeur_p, \
          nom_1 = v_1, ..., nom_q = v_q)
\end{verbatimno}
\negvspace
Où \codes{fonction} est un nom de fonction, \codes{valeur\_1} à \codes{valeur\_n} sont les valeurs associées aux paramètres \codes{param\_1} à \codes{param\_n}, \codes{liste\_valeur\_1} à \codes{liste\_valeur\_p} formeront la liste \codes{liste}, les couples \codes{nom\_1 : v\_1} à \codes{nom\_q : v\_q} formeront le dictionnaire \codes{dictionnaire}.
\end{xsyntax}

\vspaceneg
Exemple~:
\vspaceneg
%
\begin{verbatimx}
def fonction(p,*l,**d):
    print "p = ",p
    print "liste (tuple) l :", l 
    print "dictionnaire d :", d
    
fonction (1,2,3,a=5,b=6) # 1 est associé au paramètre p
                         # 2 et 3 sont insérés dans la liste l
                         # a=5 et b=6 sont insérés dans le dictionnaire d
\end{verbatimx}

%
\vspaceneg
Ce programme affiche~:
\vspaceneg
%
\begin{verbatimx}
p =  1
liste l : (2, 3)
dictionnaire d : {'a': 5, 'b': 6}
\end{verbatimx}
\vspaceneg
%
A l'instar des paramètres par défaut, la seule contrainte de cette écriture est la nécessité de respecter l'ordre dans lequel les informations doivent apparaître. Lors de l'appel, les valeurs sans précision de nom de paramètre seront placées dans une liste (ici le tuple \codes{l}). Les valeurs associées à un nom de paramètre seront placées dans un dictionnaire (ici \codes{d}). Les valeurs par défaut sont obligatoirement placées après les paramètres non nommés explicitement.

Une fonction qui accepte des paramètres en nombre variable peut à son tour appeler une autre fonction acceptant des paramètres en nombre variable.\indexsymbol{*} Il faut pour cela se servir du symbole~\codes{*} afin de transmettre à \codes{fonction} les valeurs reçues par \codes{fonction2}.
%
\vspaceneg
\begin{verbatimx}
def fonction(p,*l,**d):
    print "p = ",p
    print "liste l :", l 
    print "dictionnaire d :", d
    
def fonction2 (p, *l, **d) :
    l += (4,)              # on ajoute une valeur au tuple
    d ["c"] = 5            # on ajoute un couple (paramètre,valeur)
    fonction (p, *l, **d)  # ne pas oublier le symbole *
    
fonction2 (1,2,3,a=5,b=6)
\end{verbatimx}
%
\vspaceneg
Le programme affiche~:
\vspaceneg
%
\begin{verbatimx}
p =  1
liste l : (2, 3, 4)
dictionnaire d : {'a': 5, 'c': 5, 'b': 6}
\end{verbatimx}


\subsection{Ecriture simplifiée pour des fonctions simples}
\indexkeyword{lambda}

Lorsque le code d'une fonction tient en une ligne et est le résultat d'une expression, il est possible de condenser son écriture à l'aide du mot-clé \codes{lambda}.


\begin{xsyntax}{fonction \codes{lambda}}
\begin{verbatimno}

nom_fonction = lambda param_1, ..., param_n : expression
\end{verbatimno}
\negvspace
\codes{nom\_fonction} est le nom de la fonction, \codes{param\_1} à \codes{param\_n} sont les paramètres de cette fonction (ils peuvent également recevoir des valeurs par défaut), \codes{expression} est l'expression retournée par la fonction. \indexsyntaxecod{lambda}\indexkeyword{lambda}
\end{xsyntax}

L'exemple suivant utilise cette écriture pour définir la fonction \codes{min} retournant le plus petit entre deux nombres positifs.
%
\vspaceneg
\begin{verbatimx}
min = lambda x,y : (abs (x+y) - abs (x-y))/2

print min (1,2)      # affiche 1
print min (5,4)      # affiche 4
\end{verbatimx}
\vspaceneg
%
Cette écriture correspond à l'écriture non condensée suivante~:
%
\vspaceneg
\begin{verbatimx}
def min(x,y):
    return (abs (x+y) - abs (x-y))/2

print min (1,2)      # affiche 1
print min (5,4)      # affiche 4
\end{verbatimx}

\begin{xremark}{fonction \codes{lambda} dans une boucle}
La fonction \codes{lambda} considère le contexte de fonction qui la contient comme son contexte. Il est possible de créer des fonctions \codes{lambda} mais celle-ci utiliseront le contexte dans l'état où il est au moment de son exécution et non au moment de sa création.

\vspaceneg
\begin{verbatimx}
fs = []
for a in range (0,10) :
    f = lambda x : x + a
    fs.append (f)
for f in fs :
    print (f(1))   # le programme affiche 10 fois 10 de suite
                   # car la variable a vaut dix à la fin de la boucle
\end{verbatimx}

Pour que le programme affiche les entiers de 1 à 10, il faut préciser à la fonction \codes{lambda} une variable \codes{y} égale à \codes{a} au moment de la création de la fonction et qui sera intégrée au contexte de la fonction \codes{lambda}~:

\vspaceneg
\begin{verbatimx}
fs = []
for a in range (0,10) :
    f = lambda x,y=a : x + y   # ligne changée
    fs.append (f)
for f in fs :
    print (f(1))
\end{verbatimx}
\end{xremark}




\subsection{Fonctions générateur}
\indexkeyword{yield}\indexkeyword{for}
\indexfrr{fonction}{générateurs}\indexfr{générateurs}

Le mot-clé \codes{yield} est un peu à part. Utilisé à l'intérieur d'une fonction, il permet d'interrompre le cours de son exécution à un endroit précis de sorte qu'au prochain appel de cette fonction, celle-ci reprendra le cours de son exécution exactement au même endroit avec des variables locales inchangées. Le mot-clé \codes{return} ne doit pas être utilisé. Ces fonctions ou \emph{générateurs} sont utilisées en couple avec le mot-clé \codes{for} pour simuler un ensemble. L'exemple suivant implémente une fonction \codes{fonction\_yield} qui simule l'ensemble des entiers compris entre~0 et~n~exclu.\indexexemples{\codesindex{yield}}{}
%
\vspaceneg
\begin{verbatimx}
def fonction_yield(n):
    i = 0
    while i < n-1:
        print "yield 1" # affichage : pour voir ce que fait le programme
        yield i         # arrête la fonction qui reprendra
        i = i+1         # à la ligne suivante lors du prochain appel
    print "yield 2"     # affichage : pour voir ce que fait le programme
    yield i             # arrête la fonction qui ne reprendra pas
                        # lors du prochain appel car le code de la fonction
                        # prend fin ici
                        
for a in fonction_yield(2):
    print a                 # affiche tous les éléments que retourne la 
                            # fonction fonction_yield, elle simule la liste
                            # [0,1]
print "-----------------------------------------------"                            
for a in fonction_yield(3):
    print a                 # nouvel appel, l'exécution reprend 
                            # au début de la fonction,
                            # affiche tous les éléments que retourne la 
                            # fonction fonction_yield, elle simule la liste
                            # [0,1,2]
\end{verbatimx}
\vspaceneg
%
Le programme affiche tous les entiers compris entre~0 et~4~inclus ainsi que le texte \codes{"yield \; 1"} ou \codes{"yield \; 2"} selon l'instruction \codes{yield} qui a retourné le résultat. Lorsque la fonction a finalement terminé son exécution, le prochain appel agit comme si c'était la première fois qu'on l'appelait.
%
\vspaceneg
\begin{verbatimx}
yield 1
0
yield 2
1
-----------------------------------------------
yield 1
0
yield 1
1
yield 2
2
\end{verbatimx}







\subsection{Identificateur appelable}

\indexfr{appelable}\indexfonction{callable}

La fonction \codes{callable} retourne un booléen permettant de savoir si un identificateur est une fonction (voir chapitre~\ref{chap_classe}), de savoir par conséquent si tel identificateur est appelable comme une fonction.
%
\vspaceneg
\begin{verbatimx}
x = 5
def y () :
    return None
print callable (x)  # affiche False car x est une variable
print callable (y)  # affiche True car y est une fonction
\end{verbatimx}






\subsection{Fonctions ajoutées lors de l'exécution du programme}

\subsubsection{Fonction \codes{eval}}
\indexfonction{eval}

Cette fonction a déjà été abordée lors des paragraphes~\ref{fonction_print_eval} (paragraphe~\ref{fonction_eval}, page~\pageref{fonction_eval}). Un exemple a déjà été présenté page~\pageref{eval_fonction_chapitre_deux}. Elle évalue toute chaîne de caractères contenant une expression écrite avec la syntaxe du langage \python. Cette expression peut utiliser toute variable ou toute fonction accessible au moment où est appelée la fonction \codes{eval}. \vspaceneg\indexexemples{\codesindex{eval}}{}
%
\vspaceneg
\begin{verbatimx}
x = 3
y = 4
print eval ("x*x+y*y+2*x*y")  # affiche 49
print (x+y)**2                # affiche 49
\end{verbatimx}
%
\vspaceneg Si l'expression envoyée à la fonction \codes{eval} inclut une variable non définie, l'interpréteur \pythons génère une erreur comme le montre l'exemple suivant. \vspaceneg
%
\begin{verbatimx}
x = 3
y = 4
print eval ("x*x+y*y+2*x*y+z")
\end{verbatimx}
%
\vspaceneg La variable \codes{z} n'est pas définie et l'expression n'est pas évaluable.\vspaceneg
%
\begin{verbatimx}
Traceback (most recent call last):
  File "c:\temp\cours.py", line 3, in -toplevel-
    print eval ("x*x+y*y+2*x*y+z")
  File "<string>", line 0, in -toplevel-
NameError: name 'z' is not defined
\end{verbatimx}
%
\vspaceneg
L'erreur se produit dans une chaîne de caractères traduite en programme informatique, c'est pourquoi l'interpréteur ne peut pas situer l'erreur dans un fichier. L'erreur ne se produit dans aucun fichier, cette chaîne de caractères pourrait être définie dans un autre.




\subsubsection{Fonctions \codes{compile}, \codes{exec}}\label{par_compilation_fonction}
\indexfonction{compile}\indexkeyword{exec}

Plus complète que la fonction \codes{eval}, la fonction \codes{compile} permet d'ajouter une ou plusieurs fonctions au programme, celle-ci étant définie par une chaîne de caractères. Le code est d'abord compilé (fonction \codes{compile}) puis incorporé au programme (fonction \codes{exec}) comme le montre l'exemple suivant. \vspaceneg
%
\begin{verbatimx}
import math
str = """def coordonnees_polaires (x,y):
    rho     = math.sqrt(x*x+y*y)
    theta   = math.atan2 (y,x)
    return rho, theta"""       # fonction définie par une chaîne de caractères

obj = compile(str,"","exec")   # fonction compilée
exec obj                       # fonction incorporée au programme
print coordonnees_polaires(1,1)# affiche (1.4142135623730951, 0.78539816339744828)
\end{verbatimx}
%
\vspaceneg
La fonction \codes{compile} prend en fait trois arguments. Le premier est la chaîne de caractères contenant le code à compiler. Le second paramètre ("" dans l'exemple) contient un nom de fichier dans lequel seront placées les erreurs de compilation. Le troisième paramètre est une chaîne de caractères à choisir parmi "exec" ou "eval". Selon ce choix, ce sera la fonction \codes{exec} ou \codes{eval} qui devra être utilisée pour agréger le résultat de la fonction \codes{compile} au programme. L'exemple suivant donne un exemple d'utilisation de la fonction \codes{compile} avec la fonction \codes{eval}. \vspaceneg\indexexemples{\codesindex{compile}}{}
%
\indexfonction{eval}
\begin{verbatimx}
import math
str = """math.sqrt(x*x+y*y)"""  # expression définie par une chaîne de caractères

obj = compile(str,"","eval")    # expression compilée
x = 1
y = 2
print eval (obj)                # résultat de l'expression
\end{verbatimx}


\if 0
\section{Commentaires accentués}
\indexfr{commentaires}
\indexsymbol{\#}

Les commentaires commencent par le symbole \codes{\#} et se terminent par la fin de la ligne~; ils ne sont pas interprétés, ils n'ont aucune influence sur l'exécution du programme. Lorsque les commentaires incluent des symboles exclusivement français tels que les accents, le compilateur génère l'erreur suivante~: \vspaceneg
\indexfrr{erreur}{DeprecationWarning, Non-ASCII character}
\indexfrr{commentaire}{accent}
%
\begin{verbatimx}
sys:1: DeprecationWarning: Non-ASCII character '\xe9' 
SyntaxError: Non-ASCII character '\xe9' in file i.py on line 1, 
             but no encoding declared; 
             see http://www.python.org/peps/pep-0263.html for details
\end{verbatimx}
%
\vspaceneg
Il est néanmoins possible d'utiliser des accents dans les commentaires à condition d'insérer le commentaire suivant à la première ligne du programme. Il n'est pas nécessaire de retenir cette commande si le programme est écrit dans l'éditeur de texte fourni avec \pythons car ce dernier propose automatiquement d'insérer cette ligne. Ce point a déjà été abordé au paragraphe~\ref{par_intro_accent_code} (page~\pageref{par_intro_accent_code}). Il faut inclure la placer le texte suivant en première ligne~:
\vspaceneg
%
\begin{verbatimx}
# coding: cp1252
\end{verbatimx}
\vspaceneg Ou encore~: \vspaceneg
\begin{verbatimx}
# coding: latin-1
\end{verbatimx}
\indexfr{\codesindex{\# coding: cp1252}}\indexfrr{accent}{\codesindex{\# coding: cp1252}}
\indexfr{\codesindex{\# coding: latin-1}}\indexfrr{accent}{\codesindex{\# coding: latin-1}}
\fi





\section{Indentation}
\indexfr{indentation}
\label{par_indentation}

L'indentation est synonyme de décalage. Pour toute boucle, test, fonction, et plus tard, toute définition de classe, le fait d'indenter ou décaler les lignes permet de définir une dépendance d'un bloc de lignes par rapport à un autre. Les lignes indentées par rapport à une boucle \codes{for} dépendent de celle-ci puisqu'elle seront exécutées à chaque passage dans la boucle. Les lignes indentées par rapport au mot-clé \codes{def} sont considérées comme faisant partie du corps de la fonction. La remarque~\ref{remark_indentation} page~\pageref{remark_indentation} précise l'erreur que l'interpréteur \pythons retourne en cas de mauvaise indentation.

Contrairement à d'autres langages comme le~\textit{C} ou \textit{PERL}, \pythons n'utilise pas de délimiteurs pour regrouper les lignes. L'indentation, souvent présentée comme un moyen de rendre les programmes plus lisibles, est ici intégrée à la syntaxe du langage.\indexsymbolmodif{\backslash} Il n'y a pas non plus de délimiteurs entre deux instructions autre qu'un passage à la ligne. Le caractère $\backslash$ placé à la fin d'une ligne permet de continuer l'écriture d'une instruction à la ligne suivante.




\section{Fonctions usuelles} \label{paragraphe_fonction_usuelles}  \indexfonctionnoc{usuelle}

Certaines fonctions sont communes aux dictionnaires et aux listes, elles sont également définis pour de nombreux objets présents dans les extensions du langages. Quelque soit le contexte, le résultat attendu à la même signification. Les plus courantes sont présentées par la table~\ref{table_fonction_communes}.




La fonction \codes{map}\indexfonctionbis{map} permet d'écrire des boucles de façon simplifiée. Elle est utile dans le cas où on souhaite appliquer la même fonction à tous les éléments d'un ensemble. Par exemple les deux dernières lignes du programme suivant sont équivalentes.\label{exemple_programme_map}\indexexemples{\codesindex{map}}{}
\vspaceneg
\begin{verbatimx}
l = [0,3,4,4,5,6]
print [ est_pair (i) for i in l ]  # affiche [0, 1, 0, 0, 1, 0]
print map (est_pair, l)            # affiche [0, 1, 0, 0, 1, 0]
\end{verbatimx}
\vspaceneg
Elle peut aider à simplifier l'écriture lorsque plusieurs listes sont impliquées. Ici encore, les deux dernières lignes sont équivalentes.
\vspaceneg
\begin{verbatimx}
def addition (x,y) : return x + y
l = [0,3,4,4,5,6]
m = [1,3,4,5,6,8]
print [ addition (l [i], m [i]) for i in range (0, len (l)) ]
print map (addition, l, m)   # affiche [1, 6, 8, 9, 11, 14]
\end{verbatimx}
\vspaceneg
Il est possible de substituer \codes{None} à la fonction \codes{f} pour obtenir l'équivalent de la fonction \codes{zip}.\indexfonction{zip}\indexexemples{\codesindex{zip}}{}
\vspaceneg
\begin{verbatimx}
print map (None, l,m)  # affiche [(0, 1), (3, 3), (4, 4), (4, 5), (5, 6), (6, 8)]
print zip (l,m)        # affiche [(0, 1), (3, 3), (4, 4), (4, 5), (5, 6), (6, 8)]
\end{verbatimx}


\label{fonction_sorted_enumerate}
\indexfonction{sorted}

Comme pour les dictionnaires, la fonction \codes{sorted} permet de parcourir les éléments d'une liste de façon ordonnée. Les deux exemples qui suivent sont presque équivalents. Dans le second, la liste \codes{l} demeure inchangée alors qu'elle est triée dans le premier programme.

\begin{center}\begin{tabular}{@{}lr@{}}
\begin{minipage}{6.7cm}
\begin{verbatimx}
l   = [ 4, 5, 3, -6, 7, 9]
l.sort ()
for n in l : 
    print n
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{6.7cm}
\begin{verbatimx}
l   = [ 4, 5, 3, -6, 7, 9]

for n in sorted (l) :
    print n    
\end{verbatimx}
\end{minipage}
\end{tabular}
\end{center}

\indexfonction{enumerate}
La fonction \codes{enumerate} permet d'éviter l'emploi de la fonction \codes{range} ou \codes{xrange} lorsqu'on souhaite parcourir une liste alors que l'indice et l'élément sont nécessaires. 

\begin{center}\begin{tabular}{@{}lr@{}}
\begin{minipage}{6.7cm}
\begin{verbatimx}
l   = [ 4, 5, 3, -6, 7, 9]
for i in xrange (0, len (l)) :
    print i, l [i]
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{6.7cm}
\begin{verbatimx}
l   = [ 4, 5, 3, -6, 7, 9]
for i,v in enumerate (l) :
    print i, v
\end{verbatimx}
\end{minipage}
\end{tabular}
\end{center}





\begin{table}[H]
\begin{center}\begin{tabularx}{\textwidth}{|lX|} \hline
\codes{abs (x)} & Retourne la valeur absolue de \codes{x}.\\ \hline
\codes{callable (x)} & Dit si la variable \codes{x} peut être appelée.\\ \hline
\codes{chr (i)} & Retourne le caractère associé au code numérique \codes{i}.\\ \hline
\codes{cmp (x,y)} & Compare \codes{x} et \codes{y}, retourne -1 si \codes{x<y}, 0 en cas d'égalité, 1 sinon.\\ \hline
%\codes{complex (a,b)} & Retourne le nombre complexe $a+ib$.\\ \hline
\codes{dir (x)} & Retourne l'ensemble des méthodes associées à \codes{x} qui peut être un objet, un module, un variable,...\\ \hline
\codes{enumerate(x)} & parcourt un ensemble itérable (voir paragraphe~\ref{fonction_sorted_enumerate}) \\ \hline
\codes{help (x)} & Retourne l'aide associée à \codes{x}.\\ \hline
\codes{id (x)} & Retourne un identifiant unique associé à l'objet \codes{x}. Le mot-clé \codes{is} est relié à cet identifiant.\\ \hline
\begin{tabular}{@{}l}\codes{isinstance(}\\ \;\;\;\codes{x,classe} \end{tabular}& Dit si l'objet \codes{x} est de type \codes{classe}, voir le chapitre~\ref{chap_classe} sur les classes.\\ \hline
\begin{tabular}{@{}l}\codes{issubclass(}\\ \;\;\;\codes{cl1,cl2)} \end{tabular} & Dit si la classe \codes{cl1} hérite de la classe \codes{cl2}, voir le chapitre~\ref{chap_classe} sur les classes.\\ \hline
\codes{len(l)} & Retourne la longueur de \codes{l}.\\ \hline
\codes{map(f,l1,l2,...)} & Applique la fonction \codes{f} sur les listes \codes{l1}, \codes{l2}... Voir l'exemple page~\pageref{exemple_programme_map}.\\ \hline
\codes{max(l)} & Retourne le plus grand élément de \codes{l}.\\ \hline
\codes{min(l)} & Retourne le plus petit élément de \codes{l}.\\ \hline
\codes{ord(s)} & Fonction réciproque de \codes{chr}.\\ \hline
\codes{range(i,j[,k]} & Construit la liste des entiers de \codes{i} à \codes{j}. Si \codes{k} est précisé, va de \codes{k} en \codes{k} à partir de \codes{i}.\\ \hline
\codes{reload(module)} & Recharge un module (voir paragraphe~\ref{chap_module}).\\ \hline
\codes{repr(o)} & Retourne une chaîne de caractères qui représente l'objet \codes{o}.\\ \hline
\codes{round(x[,n])} & Arrondi \codes{x} à \codes{n} décimales près ou aucune si \codes{n} n'est pas précisé. \\ \hline
\begin{tabular}{@{}l}\codes{sorted(x}\\\codes{[,cmp[,key[,}\\\codes{reverse]]])}\end{tabular} & tri un ensemble itérable (voir paragraphe~\ref{fonction_sorted_enumerate}) \\ \hline
\codes{str(o)} & Retourne une chaîne de caractères qui représente l'objet \codes{o}.\\ \hline
\codes{sum(l)} & Retourne la somme de l'ensemble \codes{l}.\\ \hline
\codes{type(o)} & Retourne le type de la variable \codes{o}.\\ \hline
\codes{xrange(i,j[,k]} & Plus rapide que la fonction \codes{range} mais utilisable que dans une boucle \codes{for}.\\ \hline
\codes{zip(l1,l2,...)} & Construit une liste de tuples au lieu d'un tuple de listes.\\ \hline
\end{tabularx}\end{center}
\caption{Liste non exhaustive de fonctions définis par le langage \pythons sans qu'aucune extension ne soit nécessaire. Elles ne sont pas toujours applicables même si la syntaxe d'appel est correcte, elles produisent une erreur dans ce cas.}
\label{table_fonction_communes}
\indexfonction{abs}\indexfonction{callable}\indexfonction{chr}\indexfonction{cmp}\indexfonction{complex}\indexfonction{dir}\indexfonction{help}\indexfonction{id}\indexfonction{isinstance}\indexfonction{issubclass}\indexfonction{len}\indexfonction{max, min}\indexfonction{ord}\indexfonction{range}\indexfonction{reload}\indexfonction{repr}\indexfonction{round}\indexfonction{sum}\indexfonction{type}\indexfonction{xrange}\indexfonction{zip}
\end{table}





\section{Constructions classiques}

Les paragraphes qui suivent décrivent des schémas qu'on retrouve dans les programmes dans de nombreuses situations. Ce sont des combinaisons simples d'une ou deux boucles, d'un test, d'une liste, d'un dictionnaire.



\subsection{Recherche d'un élément}\indexexemples{recherche}{}\label{recherche_classique_classique}

Rechercher un élément consiste à parcourir un ensemble jusqu'à ce qu'on le trouve~: le résultat souhaité est sa position ou un résultat indiquant qu'il n'a pas été trouvé. Cette recherche est souvent insérée dans une fonction dont voici le schéma~:
%
\vspaceneg
\begin{verbatimx}
def recherche (li, c) :
    for i,v in enumerate (li) :
        if v == c : return i
    return -1
li = [ 45, 32, 43, 56 ]
print recherche (li, 43)    # affiche 2
\end{verbatimx}
\vspaceneg
La méthode \codes{index} permet de réduire ce programme.\indexmethod{index}
\vspaceneg
\begin{verbatimx}
print li.index (43)
\end{verbatimx}
\vspaceneg
Néanmoins, la fonction \codes{recherche} peut être adaptée pour rechercher la première valeur trouvée parmi deux possibles, ce qu'il n'est pas possible de faire avec la méthode \codes{index}.
\vspaceneg
\begin{verbatimx}
def recherche (li, c,d) :
    for i,v in enumerate (li) :
        if v in [c,d] : return i
    return -1
li = [ 45, 32, 43, 56 ]
print recherche (li, 43, 32)    # affiche 1
\end{verbatimx}
\vspaceneg
Ce court exemple montre qu'il est utile de connaître quelques algorithmes simples. Ils ne sont pas forcément les plus efficaces mais ils aident à construire des programmes plus rapidement et à obtenir un résultat. S'il est positif alors il sera toujours temps de se pencher sur l'optimisation du programme pour qu'il soit plus efficace.


\subsection{Maximum, minimum}\indexfr{maximum}\indexfr{minimum} \indexfonctionbis{max, min}

La recherche d'un extremum comme le calcul d'une somme fait toujours intervenir une boucle. La différence est qu'on souhaite parfois  obtenir la position du maximum.\indexexemples{maximum}{}
\vspaceneg
\begin{verbatimx}
li = [ 0, 434, 43, 6436, 5 ]
m  = li [0]             # initialisation
for l in li :           # boucle
    if m < l : m = l    # m est le maximum
\end{verbatimx}
\vspaceneg

\begin{center}\begin{tabular}{@{}lr@{}}
\begin{minipage}{6.7cm}
Ce code est équivalent à l'instruction \codes{max(li)}.\indexfonction{max} Pour récupérer la position du maximum, il faut itérer sur les positions et non sur les éléments.
\end{minipage}
&
\begin{minipage}{6.7cm}\indexexemples{maximum}{avec indices}
\begin{verbatimx}
li = [ 0, 434, 43, 6436, 5 ]
m  = 0
for i in xrange (0, len (li)) : 
    if li [m] < li [i] : m = i
\end{verbatimx}
\end{minipage}
\end{tabular}
\end{center}
%
Pour éviter la boucle, on peut utiliser l'astuce décrite au paragraphe~\ref{tri_position_iniiag} qui consiste à former une liste de couples avec la position initiale~:
\vspaceneg\indexexemples{maximum}{avec la fonction \codesindex{max}}
%
\begin{verbatimx}
k = [ (v,i) for i,v in enumerate (li) ]
m = max (k) [1]
\end{verbatimx}
\vspaceneg

Il arrive fréquemment qu'on ne doive pas chercher le maximum d'une liste mais le maximum au sein d'un sous-ensemble de cette liste. Dans l'exemple qui suit, on cherche le tuple dont la première valeur est maximale et dont la seconde valeur est égale à~1.
\vspaceneg\indexexemples{maximum}{sur un sous-ensemble}
\begin{verbatimx}
li = [ (0,0), (434,0), (43,1), (6436,1), (5,0) ]
m  = -1 # -1 car le premier élément peut ne pas faire partie du sous-ensemble
for i in range (0, len (li)) : 
    if li [i][1] == 0 and (m == -1 or li [m][0] < li [i][0]) : m = i
\end{verbatimx}
\vspaceneg



\subsection{Recherche dichotomique}\indexexemples{recherche dichotomique}{}\indexfr{dichotomie}

La recherche dichotomique est plus rapide qu'une recherche classique mais elle suppose que celle-ci s'effectue dans un ensemble trié. L'idée est de couper en deux l'intervalle de recherche à chaque itération. Comme l'ensemble est trié, en comparant l'élément cherché à l'élément central, on peut éliminer une partie de l'ensemble~: la moitié inférieure ou supérieure.
\vspaceneg
\inputcode{../python_cours/programme/dicho.py}{recherche dichotomique}

\vspaceneg


\subsection{Décomposition en matrice}\indexfr{matrice}\indexexemples{matrice}{}

Les quelques lignes qui suivent permettent de décomposer une chaîne de caractères en matrice. Chaque ligne et chaque colonne sont séparées par des séparateurs différents. Ce procédé intervient souvent lorsqu'on récupère des informations depuis un fichier texte lui-même provenant d'un tableur.
\vspaceneg
%
\begin{verbatimx}
s       = "case11;case12;case13|case21;case22;case23"
# décomposition en matrice
ligne   = s.split ("|")                     # lignes
mat     = [ l.split (";") for l in ligne ]  # colonnes
\end{verbatimx}
L'opération inverse~:
\begin{verbatimx}
ligne   = [ ";".join (l) for l in mat ]     # colonnes
s       = "|".join (ligne)                  # lignes
\end{verbatimx}


\subsection{Somme}\indexfr{somme}\indexexemples{somme}{}

Le calcul d'une somme fait toujours intervenir une boucle car le langage \pythons ne peut faire des additions qu'avec deux nombres. Le schéma est toujours le même~: initialisation et boucle.
\vspaceneg
\begin{verbatimx}
li = [ 0, 434, 43, 6456 ]
s  = 0                       # initialisation
for l in li :                # boucle
    s += l                   # addition
\end{verbatimx}
\vspaceneg
Ce code est équivalent à l'instruction \codes{sum(li)}. Dans ce cas où la somme intègre le résultat d'une fonction et non les éléments d'une liste, il faudrait écrire~:\indexfonctionbis{sum}\indexfonctionbis{map}
\vspaceneg
\begin{verbatimx}
def fonction (x) : return x*x
s  = 0
for l in li : s += fonction (l)
\end{verbatimx}
\vspaceneg

\begin{center}\begin{tabular}{@{}lr@{}}
\begin{minipage}{6.7cm}
Et ces deux lignes pourraient être résumées en une seule grâce à l'une de ces deux instructions.
\end{minipage}
&
\begin{minipage}{6.7cm}
\begin{verbatimx}
s = sum ( [fonction (l) for l in li] )

s = sum ( map (fonction, li) )
\end{verbatimx}
\end{minipage}\end{tabular}
\end{center}

\vspaceneg

L'avantage de la solution avec la boucle est qu'elle évite la création d'une liste intermédiaire, c'est un point à prendre en compte si la liste sur laquelle opère la somme est volumineuse. Il peut être intéressant de regarder l'exercice~\ref{variance_exemple_cout_ela} page~\pageref{variance_exemple_cout_ela}.



\subsection{Tri}\indexfr{tri}\indexexemples{tri}{}

Le tri est une opération fréquente. On n'a pas toujours le temps de programmer le tri le plus efficace comme un tri \textit{quicksort} et un tri plus simple suffit la plupart du temps. Le tri suivant consiste à recherche le plus petit élément puis à échanger sa place avec le premier élément du tableau du tableau. On recommence la même procédure à partir de la seconde position, puis la troisième et ainsi de suite jusqu'à la fin du tableau.
\vspaceneg
\begin{verbatimx}
for i in xrange (0, len (li)) :
    # recherche du minimum entre i et len (li) exclu
    pos = i
    for j in xrange (i+1, len (li)) :
        if li [j] < li [pos] : pos = j
    # échange
    ech      = li [pos]
    li [pos] = li [i]
    li [i]   = ech
\end{verbatimx}
\vspaceneg
La méthode \codes{sort} trie également une liste mais selon un algorithme plus efficace que celui-ci dont la logique est présentée par l'exercice~\ref{quickost_exo_label}, page~\pageref{quickost_exo_label}. Ceci explique pourquoi on hésite toujours à programmer un tri quitte à avoir recours à une astuce telle que celles présentées au paragraphe suivant.



\subsection{Tri et position initiale}\indexfrr{tri}{position initiale}\label{tri_position_iniiag}\indexexemples{tri, position initiale}{}

Il arrive parfois qu'on souhaite trier un tableau puis appliquer la même transformation à un second tableau. Pour cela, il faut récupérer la position initiale des éléments dans le tableau trié. Une possibilité consiste à trier non pas le tableau mais une liste de couples (valeur, position) comme le montre l'exemple suivant~:
%
\vspaceneg
\inputcode{../python_cours/programme/tri_position.py}{tri avec positions initiales}
\vspaceneg
%
La liste \codes{ [ p [1]\; for \;p \;in \; pos] } correspond à l'ensemble des positions initiales des éléments de la liste \codes{tab}. Les deux lignes qui suivent permettent d'en déduire la position de chaque élément dans l'ensemble trié. \codes{ordre [i]} est le rang de l'élément d'indice \codes{i} avant le tri.
%
\vspaceneg
\begin{verbatimx}
ordre = range (0, len (pos))
for i in xrange (0, len (pos)) : ordre [pos [i][1]] = i
\end{verbatimx}
\vspaceneg


\subsection{Comptage} \indexexemples{comptage}{}

On souhaite ici compter le nombre d'occurrences de chaque élément d'un tableau. Par exemple, on pourrait connaître par ce moyen la popularité d'un mot dans un discours politique ou l'étendue du vocabulaire utilisé. L'exemple suivant compte les mots d'une liste de mots.
%
\vspaceneg
\begin{verbatimx}
li = ["un", "deux", "un", "trois"]
d  = { }
for l in li :
    if l not in d : d [l] = 1
    else : d [l] += 1
print d   # affiche {'un': 2, 'trois': 1, 'deux': 1}
\end{verbatimx}
\vspaceneg
%
La structure la plus appropriée ici est un dictionnaire puisqu'on cherche à associer une valeur à un élément d'une liste qui peut être de tout type. Si la liste contient des éléments de type modifiable comme une liste, il faudrait convertir ceux-ci en un type immuable comme une chaîne de caractères. L'exemple suivant illustre ce cas en comptant les occurrences des lignes d'une matrice.
%
\vspaceneg
\begin{verbatimx}
mat = [ [1,1,1], [2,2,2], [1,1,1]]
d  = { }
for l in mat :
    k = str (l)    # k = tuple (l) lorsque cela est possible
    if k not in d : d [k] = 1
    else : d [k] += 1
print d   # affiche {'[1, 1, 1]': 2, '[2, 2, 2]': 1}
\end{verbatimx}
\vspaceneg
%
On peut également vouloir non pas compter le nombre d'occurrence mais mémoriser les positions des éléments tous identiques. On doit utiliser un dictionnaire de listes~:
%
\vspaceneg
\begin{verbatimx}
li = ["un", "deux", "un", "trois"]
d  = { }
for i,v in enumerate (li) :
    if v not in d : d [v] = [ i ]
    else : d [v].append (i)
print d   # affiche {'un': [0, 2], 'trois': [3], 'deux': [1]}
\end{verbatimx}
\vspaceneg


\subsection{Matrice en un vecteur} \indexfr{matrice}\indexexemples{matrice}{}\indexexemples{vecteur}{}\indexfr{vecteur}\indexfr{liste de listes}

Dans un langage comme le \textit{C++}, il arrive fréquemment qu'une matrice ne soit pas représentée par une liste de listes mais par une seule liste car cette représentation est plus efficace. Il faut donc convertir un indice en deux indices ligne et colonne. Il faut bien sûr que le nombre de colonnes sur chaque ligne soit constant. Le premier programme convertit une liste de listes en une seule liste.
%
\vspaceneg
\begin{verbatimx}
mat = [[0,1,2],[3,4,5]]
lin = [ i * len (mat [i]) + j \
            for i in range (0, len (mat)) \
            for j in range (0, len (mat [i])) ]
\end{verbatimx}        
\vspaceneg        
Le programme suivant fait l'inverse. Il faut faire attention à la position des crochets et l'ordre des boucles \codes{for}.
\vspaceneg
\begin{verbatimx}
nc = len (mat [0])
mat = [ [ lin [i * nc + j] for j in range (0, len (mat [i])) ] \
                           for i in range (0, len (mat)) ]
\end{verbatimx}


\subsection{Fonctions et variables} \label{paragraphe_fonction_variable}
\indexfrr{type}{fonction}

Une fonction peut aussi recevoir en paramètre une autre fonction. L'exemple suivant inclut la fonction \codes{calcul\_n\_valeur} qui prend comme paramètres \codes{l} et \codes{f}. Cette fonction calcule pour toutes les valeurs \codes{x} de la liste \codes{l} la valeur \codes{f(x)}. \codes{fonction\_carre} ou \codes{fonction\_cube} sont passées en paramètres à la fonction \codes{calcul\_n\_valeur} qui les exécute. Le paragraphe~\ref{paragraphe_fonction_variable_classe} page~\pageref{paragraphe_fonction_variable_classe} présente le même programme mais rédigé avec des classes.
\vspaceneg  \label{exemple_cube_pointeur_fonction}
%
\begin{verbatimx}
def fonction_carre(x) :  return x*x
def fonction_cube (x) :  return x*x*x

def calcul_n_valeur (l,f):
    res = [ f(i) for i in l ]
    return res

l = [0,1,2,3]
print l   # affiche [0, 1, 2, 3]

l1 = calcul_n_valeur (l, fonction_carre)
print l1  # affiche [0, 1, 4, 9]

l2 = calcul_n_valeur (l, fonction_cube)
print l2  # affiche [0, 1, 8, 27]
\end{verbatimx}








\firstpassagedo{
    \begin{thebibliography}{99}
    \input{python_cours_biblio.tex}
    \end{thebibliography}
}



\input{../../common/livre_table_end.tex}%
\input{../../common/livre_end.tex}%