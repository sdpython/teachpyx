\input{../../common/livre_begin.tex}%
\firstpassagedo{\input{python_cours_titre.tex}}
\input{../../common/livre_table_begin.tex}%
%\firstpassagedo{\input{python_cours_chapter.tex}}



\newcommand{\spaceneg}[0]{\vspace{-0.15cm}}
\newcommand{\spacenegl}[0]{\vspace{-0.1cm}}




%-------------------------------------------------------------------------------------------------------------
\chapter{Interface graphique}
\label{chap_interface}
%-------------------------------------------------------------------------------------------------------------
\indexfr{interface graphique}

\indexfr{événement}
Les interfaces graphiques servent à rendre les programmes plus conviviaux. Elles sont pratiques à utiliser mais elles demandent un peu de temps pour les concevoir. Un programme sans interface exécute des instructions les unes à la suite des autres, le programme a un début -~un point d'entrée~- et une fin. Avec une interface, le programme fonctionne de manière différente. Il n'exécute plus successivement les instructions mais attend un événement -~pression d'une touche du clavier, clic de souris~- pour exécuter une fonction. C'est comme si le programme avait une multitude de points d'entrée. \indexfr{point d'entrée}

\indexmoduleint{Tkinter}\indexmoduleext{wxPython}
Il existe plusieurs modules permettant d'exploiter les interfaces graphiques. Le plus simple est le module \codes{Tkinter} présent lors de l'installation du langage \python. Ce module est simple mais limité. Le module \codes{wxPython} est plus complet mais un peu plus compliqué dans son utilisation\footnote{Le paragraphe~\ref{par_intro_interface_g} page~\pageref{par_intro_interface_g} présente d'autres alternatives.}. Toutefois, le fonctionnement des interfaces graphiques sous un module ou un autre est identique. C'est pourquoi ce chapitre n'en présentera qu'un seul, le module \codes{Tkinter}. Pour d'autres modules, les noms de classes changent mais la logique reste la même~: il s'agit d'associer des événements à des parties du programme \python.

Les interfaces graphiques évoluent sans doute plus vite que les autres modules, des composantes de plus en plus complexes apparaissent régulièrement. Un module comme \codes{wxPython} change de version plusieurs fois par an. Il est possible de trouver sur Internet des liens\footnote{L'adresse \httpstyle{http://gnuprog.info/prog/python/pwidget.php} illustre chaque objet de \codesnote{Tkinter}, on peut citer également \httpstyle{http://effbot.org/tkinterbook/}.} qui donnent des exemples de programme. Une excellente source de documentation sont les forums de discussion\indexfr{forum de discussion} qui sont un lieu où des programmeurs échangent questions et réponses. Un message d'erreur entré sur un moteur de recherche Internet permet souvent de tomber sur des échanges de ce type, sur des problèmes résolus par d'autres.



\section{Introduction}
\label{chap_interface_intro_section}


Un programme muni d'une interface graphique fonctionne différemment d'un programme classique. Un programme classique est une succession presque linéaire d'instructions. Il y a un début ou \textit{point d'entrée} du programme et aucun événement extérieur ne vient troubler son déroulement.\indexfr{point d'entrée} Avec une interface graphique, le point d'entrée du programme est masqué~: il est pris en compte automatiquement. Du point de vue du programmeur, le programme a plusieurs points d'entrée~: une simple fenêtre avec deux boutons (voir figure~\ref{fenetre_exemple_label_deuxneetree}) propose deux façons de commencer et il faut prévoir une action associée à chaque bouton.
    
La conception d'une interface graphique se déroule généralement selon deux étapes. La première consiste à dessiner l'interface, c'est-à-dire choisir une position pour les objets de la fenêtre (boutons, zone de saisie, liste déroulante, ...). La seconde étape définit le fonctionnement de la fenêtre, c'est-à-dire associer à chaque objet des fonctions qui seront exécutées si un tel événement se réalise (pression d'un bouton, pression d'une touche, ...).

Pour le moment, nous allons supposer que ces deux étapes sont scindées même si elles sont parfois entremêlées lorsqu'un événement implique la modification de l'apparence de la fenêtre. La section qui suit décrit des objets que propose le module \codes{Tkinter}. La section suivante présente la manière de les disposer dans une fenêtre. La section d'après décrit les événements et le moyen de les relier à des fonctions du programme. Ce chapitre se termine par quelques constructions courantes à propos des interfaces graphiques.

			\begin{figure}[ht]
			\figureoneimage{ \caption{	Une fenêtre contenant deux boutons~: ce sont deux points d'entrée du programme.\vspace{-0.5cm}} }
  		{ \includegraphics[width=3cm]{\filextellipse{../python_cours/image/entree}{../python_cours/image_ellipse/entree}} }
  		{\label{fenetre_exemple_label_deuxneetree}}
  		\end{figure}
    		    
    		

\vspace{-1cm}


\section{Les objets} \label{interface_graphique_objet_s}
\indextk{objets}

\indexfr{objet}\indexfr{widget}\indextk{widget}
Les interfaces graphiques sont composées d'\emph{objets} ou \emph{widgets}\footnote{On les appelle aussi \emph{contrôle}.\indexfr{contrôle (graphique)}\indextk{contrôle} Comme ils reçoivent des événements, en un sens, ce sont ces objets qui pilotent un programme ou qui le contrôlent.}. Ce paragraphe décrit les principales méthodes qui permettent de modifier le contenu et l'apparence des objets. Il faut se reporter à la documentation du langage\footnote{La page \httpstyle{http://wiki.python.org/moin/Tkinter} recense quelques liens utiles autour de \codesnote{Tkinter} dont la documentation officielle.} pour avoir la liste de toutes les options disponibles.

Les exemples de codes des paragraphes qui suivent permettent de disposer les objets dans une fenêtre qui ne s'affichera pas sans les quelques lignes de code supplémentaires présentées au paragraphe~\ref{mainloop_fenetre_principale} et l'utilisation d'une méthode \codes{pack} (paragraphe~\ref{disposition_paragraphe_python}). L'exemple suivant crée un objet~: 
\spaceneg
\indexexemples{\codesindex{Label}}{}
\begin{verbatimx}
    zone_texte = Tkinter.Label (text = "zone de texte")
\end{verbatimx}
\spaceneg Et pour l'afficher, il faut l'enrober~: \spaceneg\indexexemples{interface}{}
\begin{verbatimx}
    import Tkinter         # import de Tkinter
    root = Tkinter.Tk ()   # création de la fenêtre principale
    # ...
    obj = Tkinter.Label (text = "zone de texte")
    # ...
    obj.pack ()            # on ajoute l'objet à la fenêtre principale
    root.mainloop ()       # on affiche enfin la fenêtre principal et on attend
                           # les événements (souris, clic, clavier)
\end{verbatimx}
\spaceneg

\subsection{Zone de texte}
\indextk{zone de texte}\indextkk{Label}

Une zone de texte sert à insérer dans une fenêtre graphique une légende indiquant ce qu'il faut insérer dans une zone de saisie voisine comme le montre la figure~\ref{fenetre_exemple_label}. Une zone de texte correspond à la classe \codes{Label} du module \codes{Tkinter}. Pour créer une zone de texte, il suffit d'écrire la ligne suivante~: \spaceneg
\begin{verbatimx}
    zone_texte = Tkinter.Label (text = "zone de texte")
\end{verbatimx} 
\spaceneg Il est possible que le texte de cette zone de texte doive changer après quelques temps. Dans ce cas, il faut appeler la méthode \codes{config} comme suit~: \spaceneg
\begin{verbatimx}
    zone_texte = Tkinter.Label (text = "premier texte")
    # ...
    # pour changer de texte
    zone_texte.config (text = "second texte")
\end{verbatimx}

				\begin{figure}[ht]
				\figureoneimagetrup{ \caption{	Exemple de zone de texte ou \emph{Label} associée à une zone de saisie.
    							La seconde image montre une zone de texte dans l'état \codescaption{DISABLED}.\vspace{-1cm}} }
    		{ \includegraphics[width=4.5cm]{\filextellipse{../python_cours/image/label}{../python_cours/image_ellipse/label}} }
    		{ \includegraphics[width=4.5cm]{\filextellipse{../python_cours/image/label2}
    		{../python_cours/image_ellipse/label2}} }
    		{\label{fenetre_exemple_label}}
    		\indextkk{Label}
    		\end{figure}


    		
La figure~\ref{fenetre_exemple_label} montre deux zones de texte. La seconde est grisée par rapport à la première. Pour obtenir cet état, il suffit d'utiliser l'instruction suivante~: \spaceneg
\indexexemples{\codesindex{DISABLED}}{}
\begin{verbatimx}
    zone_texte.config (state = Tkinter.DISABLED)
\end{verbatimx}  
\spaceneg Et pour revenir à un état normal~: \spaceneg
\begin{verbatimx}
    zone_texte.config (state = Tkinter.NORMAL)
\end{verbatimx}
%
Ces deux dernières options sont communes à tous les objets d'une interface graphique. Cette option sera rappelée au paragraphe~\ref{methode_communes_interface}.









\subsection{Bouton}
\indextk{bouton}\indextkk{Button}

Un bouton a pour but de faire le lien entre une fonction et un clic de souris. Un bouton correspond à la classe \codes{Button} du module \codes{Tkinter}. Pour créer un bouton, il suffit d'écrire la ligne suivante~: \spaceneg
\indexexemples{\codesindex{Button}}{}
\begin{verbatimx}
    bouton = Tkinter.Button (text = "zone de texte")
\end{verbatimx}
\spaceneg Il est possible que le texte de ce bouton doive changer après quelques temps. Dans ce cas, il faut appeler la méthode \codes{config} comme suit~: \spaceneg
\begin{verbatimx}
    bouton = Tkinter.Button (text = "premier texte")
    # ...
    # pour changer de texte
    bouton.config (text = "second texte")
\end{verbatimx}
\spaceneg
				\begin{figure}[ht]
				\figureoneimagequ{   \caption{	Exemple de boutons, non pressé, pressé, grisé. 
														Le bouton grisé ne peut être pressé.\vspace{-1cm}} }
    		{ \includegraphics[width=2cm]{\filextellipse{../python_cours/image/bouton}
    				{../python_cours/image_ellipse/bouton}} }
    		{ \includegraphics[width=2cm]
    				{\filextellipse{../python_cours/image/bouton2}{../python_cours/image_ellipse/bouton2}} }
    		{ \includegraphics[width=1.8cm]{\filextellipse{../python_cours/image/bouton3}
    				{../python_cours/image_ellipse/bouton3}} }
    		{\label{fenetre_exemple_bouton}}
    		\end{figure}



La figure~\ref{fenetre_exemple_bouton} montre trois boutons. Le troisième est grisé par rapport au premier. Les boutons grisés ne peuvent pas être pressés. Pour obtenir cet état, il suffit d'utiliser l'instruction suivante~: \spaceneg
\begin{verbatimx}
    bouton.config (state = Tkinter.DISABLED)
\end{verbatimx}
\spaceneg Et pour revenir à un état normal~:\spaceneg
\begin{verbatimx}
    bouton.config (state = Tkinter.NORMAL)
\end{verbatimx}
\spaceneg C'est pour cet objet que cette option est la plus intéressante car elle permet d'interdire la possibilité pour l'utilisateur de presser le bouton tout en le laissant visible. 

Il est possible également d'associer une image à un bouton. Par exemple, les trois lignes suivantes créent un bouton, charge une image au format \codes{gif}\ifnotellipse{\indexfrr{image}{gif}} puis l'associe au bouton \codes{b}. Lors de l'affichage de la fenêtre, le bouton \codes{b} ne contient pas de texte mais une image. \indextkk{PhotoImage}
\vspaceneg\vspaceneg\indexexemples{bouton image}{}

\begin{center}\begin{tabular}{@{}lr@{}}
\begin{minipage}{11.4cm}
\begin{verbatimx}
b = Tkinter Button ()
im = Tkinter.PhotoImage (file = "chameau.gif")
b.config (image = im)
\end{verbatimx}
\end{minipage}
& 
\begin{minipage}{2.1cm}
\includegraphics[width=2cm]{\filextellipse{../python_cours/image/bbette2}
    		{../python_cours/image_ellipse/bbette2}} 
\end{minipage}    		
\end{tabular}\end{center} 
\vspaceneg   		


Les images qu'il est possible de charger sont nécessairement au format \codes{GIF}, le seul que le module \codes{Tkinter} puisse lire.



\subsection{Zone de saisie}
\indextk{zone de saisie}\indextkk{Entry}


Une zone de saisie a pour but de recevoir une information entrée par l'utilisateur. Une zone de saisie correspond à la classe \codes{Entry} du module \codes{Tkinter}~; pour en créer une, il suffit d'écrire la ligne suivante~: \spaceneg
\indexexemples{\codesindex{Entry}}{}
\begin{verbatimx}
    saisie = Tkinter.Entry ()
\end{verbatimx}
\spaceneg Pour modifier le contenu de la zone de saisie, il faut utiliser la méthode \codes{insert} qui insère un texte à une position donnée. \indextkk{insert}\spaceneg 
\begin{verbatimx}
    # le premier paramètre est la position
    # où insérer le texte (second paramètre)
    saisie.insert (pos, "contenu")
\end{verbatimx}
\spaceneg Pour obtenir le contenu de la zone de saisie, il faut utiliser la méthode \codes{get}~:\indextkk{get}\spaceneg 
\begin{verbatimx}
    contenu = saisie.get ()
\end{verbatimx}
\spaceneg Pour supprimer le contenu de la zone de saisie, il faut utiliser la méthode \codes{delete}. Cette méthode supprime le texte entre deux positions.\indextkk{delete}\spaceneg
\begin{verbatimx}
    # supprime le texte entre les positions pos1, pos2
    saisie.delete (pos1, pos2)
\end{verbatimx}
\spaceneg Par exemple, pour supprimer le contenu d'une zone de saisie, on peut utiliser l'instruction suivante~:\spaceneg
\begin{verbatimx}
    saisie.delete (0, len (saisie.get ()))
\end{verbatimx}
\spaceneg

		\begin{figure}[ht]
		\figureoneimagetrup{ \caption{	Exemple de zones de saisie, normale et grisée, la zone grisée ne peut être modifiée.\vspace{-1cm}} }
		{\includegraphics[width=3cm]{\filextellipse{../python_cours/image/saisie1}{../python_cours/image_ellipse/saisie1}} }
		{ \includegraphics[width=3cm]{\filextellipse{../python_cours/image/saisie2}{../python_cours/image_ellipse/saisie2}} }
		{\label{fenetre_exemple_saisie}}
		\end{figure}

La figure~\ref{fenetre_exemple_saisie} montre deux zones de saisie. La seconde est grisée par rapport à la première. Les zones de saisie grisées ne peuvent pas être modifiées. Pour obtenir cet état, il suffit d'utiliser la méthode \codes{config} comme pour les précédents objets. Cette option sera rappelée au paragraphe~\ref{methode_communes_interface}.




\subsection{Zone de saisie à plusieurs lignes}
\indextk{zone de saisie à plusieurs lignes}\indextkk{Text}


Une zone de saisie à plusieurs lignes est identique à la précédente à ceci près qu'elle autorise la saisie d'un texte sur plusieurs lignes. Cette zone correspond à la classe \codes{Text} du module \codes{Tkinter}. Pour créer une telle zone, il suffit d'écrire la ligne suivante~:\spaceneg
\indexexemples{\codesindex{Text}}{}
\begin{verbatimx}
    saisie = Tkinter.Text ()
\end{verbatimx}
\spaceneg Pour modifier le contenu de la zone de saisie, il faut utiliser la méthode \codes{insert} qui insère un texte à une position donnée. La méthode diffère de celle de la classe \codes{Entry} puisque la position d'insertion est maintenant une chaîne de caractères contenant deux nombres séparés par un point~: le premier nombre désigne la ligne, le second la position sur cette ligne. \indextkk{insert}\spaceneg
\begin{verbatimx}
    # le premier paramètre est la position
    # où insérer le texte (second paramètre)
    pos = "0.0"
    saisie.insert (pos, "première ligne\nseconde ligne")
\end{verbatimx}
\spaceneg Pour obtenir le contenu de la zone de saisie, il faut utiliser la méthode \codes{get} qui retourne le texte entre deux positions. La position de fin n'est pas connue, on utilise la chaîne de caractères "\codes{end}" pour désigner la fin de la zone de saisie. \indextkk{get}\spaceneg
\begin{verbatimx}
    # retourne le texte entre deux positions
    pos1 = "0.0"
    pos2 = "end"  # ou Tkinter.END
    contenu = saisie.get (pos1, pos2)
\end{verbatimx}
\spaceneg Pour supprimer le contenu de la zone de saisie, il faut utiliser la méthode \codes{delete}. Cette méthode supprime le texte entre deux positions. \indextkk{delete}\spaceneg
\begin{verbatimx}
    # supprime le texte entre les positions pos1, pos2
    saisie.delete (pos1, pos2)
\end{verbatimx}
\spaceneg Par exemple, pour supprimer le contenu d'une zone de saisie à plusieurs lignes, on peut utiliser l'instruction suivante~:\spaceneg 
\begin{verbatimx}
    saisie.delete ("0.0", "end")
    # on peut aussi utiliser 
    # saisie.delete ("0.0", Tkinter.END)
\end{verbatimx}
\spaceneg Pour modifier les dimensions de la zone de saisie à plusieurs lignes, on utilise l'instruction suivante~:\indextkk{config}

\spaceneg\spaceneg
\begin{center}\begin{tabular}{@{}lr@{}}
\begin{minipage}{9cm}
\begin{verbatimx}
    # modifie les dimensions de la zone
    # width <--> largeur
    # height <--> hauteur en lignes
    saisie.config (width = 10, height = 5)
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{5.4cm}
\includegraphics[width=3.5cm]{\filextellipse{../python_cours/image/text1}{../python_cours/image_ellipse/text1}}  
\end{minipage}
\end{tabular}\end{center}

\vspaceneg

L'image précédente montre une zone de saisie à plusieurs lignes. Pour griser cette zone, il suffit d'utiliser la méthode \codes{config} rappelée au paragraphe~\ref{methode_communes_interface}.


















\subsection{Case à cocher}
\indextk{case à cocher}\indextkk{Checkbutton}\indextkk{IntVar}
Une case à cocher correspond à la classe \codes{Checkbutton} du module \codes{Tkinter}. Pour créer une case à cocher, il suffit d'écrire la ligne suivante~: 
\spaceneg
\indexexemples{\codesindex{CheckButton}}{}
\begin{verbatimx}
    # crée un objet entier pour récupérer la valeur de la case à cocher,
    # 0 pour non cochée, 1 pour cochée
    v    = Tkinter.IntVar ()
    case = Tkinter.Checkbutton (variable = v)
\end{verbatimx}
\spaceneg 
En fait, ce sont deux objets qui sont créés. Le premier, de type \codes{IntVar}, mémorise la valeur de la case à cocher. Le second objet, de type \codes{CheckButton}, gère l'apparence au niveau de l'interface graphique. La raison de ces deux objets est plus évidente dans le cas de l'objet \codes{RadioButton} décrit au paragraphe suivant. Pour savoir si la case est cochée ou non, il suffit d'exécuter l'instruction~:\indextkk{get}
\spaceneg
\begin{verbatimx}
    v.get ()  # égal à 1 si la case est cochée, 0 sinon
\end{verbatimx}
\spaceneg 
Pour cocher et décocher la case, il faut utiliser les instructions suivantes~:\indextkk{select}
\spaceneg
\begin{verbatimx}
    case.select ()      # pour cocher
    case.deselect ()    # pour décocher
\end{verbatimx}
\spaceneg 
Il est possible d'associer du texte à l'objet case à cocher~:\spaceneg
\begin{verbatimx}
    case.config (text = "case à cocher")
\end{verbatimx}
\spaceneg


		\begin{figure}[ht]
		\figureoneimagetrup{     		\caption{	Exemples de cases à cocher, non cochée, cochée, grisée. Lorsqu'elle est grisée,
							son état ne peut être modifié. La dernière image montre une case à cocher associée
							à un texte.\vspace{-0.5cm}} }
		{ \includegraphics[width=3cm]{\filextellipse{../python_cours/image/check}{../python_cours/image_ellipse/check}} }
		{ \includegraphics[width=3.5cm]{\filextellipse{../python_cours/image/check2}{../python_cours/image_ellipse/check2}} }
		{\label{fenetre_exemple_checkbouton}}
		\end{figure}

La figure~\ref{fenetre_exemple_checkbouton} montre trois cases. La troisième est grisée par rapport à la première. Les cases grisées ne peuvent pas être cochées. Pour obtenir cet état, il suffit d'utiliser la méthode \codes{config} rappelée au paragraphe~\ref{methode_communes_interface}.












\subsection{Case ronde ou bouton radio}
\indextk{case ronde}\indextk{bouton radio}\indextkk{Radiobutton}\indextkk{IntVar}



Une case ronde ou \textit{bouton radio} correspond à la classe \codes{Radiobutton} du module \codes{Tkinter}. Elles fonctionnent de manière semblable à des cases à cocher excepté le fait qu'elles n'apparaissent jamais seules~: elles fonctionnent en groupe. Pour créer un groupe de trois cases rondes, il suffit d'écrire la ligne suivante~: \spaceneg
\indexexemples{\codesindex{RadioButton}}{}
\begin{verbatimx}
    # crée un objet entier partagé pour récupérer le numéro du bouton radio activé
    v     = Tkinter.IntVar ()
    case1 = Tkinter.Radiobutton (variable = v, value = 10)
    case2 = Tkinter.Radiobutton (variable = v, value = 20)
    case3 = Tkinter.Radiobutton (variable = v, value = 30)
\end{verbatimx}
\spaceneg La variable \codes{v} est partagée par les trois cases rondes. L'option \codes{value} du constructeur permet d'associer un bouton radio à une valeur de \codes{v}. Si \codes{v == 10}, seul le premier bouton radio sera sélectionné. Si \codes{v == 20}, seul le second bouton radio le sera. Si deux valeurs sont identiques pour deux boutons radio, ils seront cochés et décochés en même temps. Et pour savoir quel bouton radio est coché ou non, il suffit d'exécuter l'instruction~: \indextkk{get}\spaceneg
\begin{verbatimx}
    v.get ()  #  retourne le numéro du bouton radio coché (ici, 10, 20 ou 30)
\end{verbatimx}
\spaceneg Pour cocher un des boutons radio, il faut utiliser l'instruction suivante~:\indextkk{set}\spaceneg
\begin{verbatimx}
    v.set (numero)  # numéro du bouton radio à cocher
                    # pour cet exemple, 10, 20 ou 30
\end{verbatimx}
\spaceneg Il est possible d'associer du texte à un bouton radio (voir figure~\ref{fenetre_exemple_radiobouton})~:\spaceneg
\begin{verbatimx}
   case1.config (text = "premier bouton")
   case2.config (text = "second bouton")
   case3.config (text = "troisième bouton")
\end{verbatimx}
\spaceneg


				\begin{figure}[ht]
				\figureoneimagetrup{      		\caption{	Exemples de cases rondes ou boutons radio, non cochée, cochée, grisée.
														 Lorsqu'elle est grisée,
    							son état ne peut être modifiée. La seconde image présente un groupe de bouton radio. Un
    							seul peut être sélectionné à la fois à moins que deux boutons ne soient associés à la même 
    							valeur. Dans ce cas, ils agiront de pair.} }
				{ \includegraphics[width=2cm]{\filextellipse{../python_cours/image/radio}{../python_cours/image_ellipse/radio}} }
    		{ \includegraphics[width=3cm]{\filextellipse{../python_cours/image/radio2}{../python_cours/image_ellipse/radio2}} }
    		{\label{fenetre_exemple_radiobouton}}
    		\end{figure}
    		
La figure~\ref{fenetre_exemple_radiobouton} montre trois cases. La troisième est grisée par rapport à la première. Si un des boutons radio est grisé parmi les trois, le choix du bouton à cocher s'effectue parmi les deux restants ou aucun si le bouton radio grisé est coché.












\subsection{Liste}
\indextk{liste}\indextkk{Listbox}


Un objet liste contient une liste d'intitulés qu'il est possible de sélectionner. Une liste correspond à la classe \codes{ListBox} du module \codes{Tkinter}. Pour la créer, il suffit d'écrire la ligne suivante~: \spaceneg
\indexexemples{\codesindex{Listbox}}{}
\begin{verbatimx}
    li  = Tkinter.Listbox ()
\end{verbatimx}
\spaceneg 
Pour modifier les dimensions de la zone de saisie à plusieurs lignes, on utilise l'instruction suivante~:\indextkk{config}
\spaceneg
\begin{verbatimx}
    # modifie les dimensions de la liste
    # width <--> largeur
    # height <--> hauteur en lignes
    li.config (width = 10, height = 5)
\end{verbatimx}
\spaceneg 
On peut insérer un élément dans la liste avec la méthode \codes{insert}~:\indextkk{insert}
\spaceneg
\begin{verbatimx}
    pos = 0   # un entier, "end" ou Tkinter.END pour insérer ce mot à la fin
    li.insert (pos, "première ligne")
\end{verbatimx}
\spaceneg 
On peut supprimer des intitulés de cette liste avec la méthode \codes{delete}.\indextkk{delete}
\spaceneg
\begin{verbatimx}
    pos1 = 0    # un entier
    pos2 = None # un entier, "end" ou Tkinter.END pour supprimer tous les éléments
                # de pos1 jusqu'au dernier
    li.delete (pos1, pos2 = None)
\end{verbatimx}
\spaceneg 
Les intitulés de cette liste peuvent ou non être sélectionnés. Cliquer sur un intitulé le sélectionne mais la méthode \codes{select\_set} permet aussi de le faire.\indextkk{select\_set}
\spaceneg
\begin{verbatimx}
    pos1 = 0
    li.select_set (pos1, pos2 = None)
    # sélectionne tous les éléments entre les indices pos1 et 
    # pos2 inclus ou seulement celui d'indice pos1 si pos2 == None
\end{verbatimx}
\spaceneg 
Réciproquement, il est possible d'enlever un intitulé de la sélection à l'aide de la méthode \codes{select\_clear}.\indextkk{select\_clear}
\spaceneg
\begin{verbatimx}
    pos1 = 0
    li.select_clear (pos1, pos2 = None)
    # retire la sélection de tous les éléments entre les indices 
    # pos1 et pos2 inclus ou seulement celui d'indice pos1 si pos2 == None
\end{verbatimx}
\spaceneg 
La méthode \codes{curselection} permet d'obtenir la liste des indices des éléments sélectionnés.\indextkk{curselection}
\spaceneg
\begin{verbatimx}
    sel = li.curselection ()
\end{verbatimx}
\spaceneg 
La méthode \codes{get} permet récupérer un élément de la liste tandis que la méthode \codes{size} retourne le nombre d'éléments~:\indextkk{size}\indextkk{get}
\spaceneg
\begin{verbatimx}
    for i in range (0,li.size ()) :
        print li.get (i)
\end{verbatimx}
\spaceneg

				\begin{figure}[ht]
				\figureoneimagetr{ \caption{	Exemple de liste. La seconde liste est grisée et ne peut être modifiée.\vspace{-0.5cm}} }
    		{ \includegraphics[width=3cm]{\filextellipse{../python_cours/image/list1}{../python_cours/image_ellipse/list1}} }
    		{ \includegraphics[width=3cm]{\filextellipse{../python_cours/image/list2}{../python_cours/image_ellipse/list2}} }
    		{\label{fenetre_exemple_liste}}
    		\end{figure}

La figure~\ref{fenetre_exemple_liste} montre deux listes. La seconde est grisée par rapport à la première. Elle ne peut être modifiée. Pour obtenir cet état, il faut appeler la méthode \codes{config} rappelée au paragraphe~\ref{methode_communes_interface}.

%%%%%%%%%%%%%%%%%%%

\begin{xremark}{liste et barre de défilement}
Il est possible d'adjoindre une barre de défilement verticale. Il faut pour cela inclure l'objet dans une sous-fenêtre \codes{Frame} qui est définie au paragraphe~\ref{interf_fraph_sous_gene} comme dans l'exemple suivant~:\indextkk{Scrollbar}\indextkk{Frame}\indexexemples{barre de défilement}{}
\vspaceneg
\begin{verbatimx}
    frame      = Tkinter.Frame (parent)
    scrollbar  = Tkinter.Scrollbar (frame)
    li         = Tkinter.Listbox (frame, width = 88, height = 6, \
                                  yscrollcommand = scrollbar.set)
    scrollbar.config (command = li.yview)
    li.pack (side = Tkinter.LEFT)
    scrollbar.pack (side = Tkinter.RIGHT, fill = Tkinter.Y)
\end{verbatimx}
\vspaceneg
Il suffit de transposer cet exemple pour ajouter une barre de défilement horizontale. Toutefois, il est préférable d'utiliser un objet prédéfini présent dans le module \codes{Tix} qui est une extension du module \codes{Tkinter}. Elle est présentée au paragraphe~\ref{chap_interface_exemple_programme}.
\end{xremark}

\begin{xremark}{plusieurs Listbox}
Lorsqu'on insère plusieurs objets \codes{Listbox} dans une seule fenêtre, ces objets partagent par défaut la même sélection. Autrement dit, lorsqu'on clique sur un élément de la seconde \codes{Listbox}, l'élément sélectionné dans la première ne l'est plus. Afin de pouvoir sélectionner un élément dans chaque \codes{Listbox}, il faut ajouter dans les paramètres du constructeur l'option \codes{exportselection=0} comme l'illustre l'exemple suivant~:\indextkk{exportselection}
\vspaceneg
\begin{verbatimx}
    li = Tkinter.Listbox (frame, width = 88, height = 6, exportselection=0)
\end{verbatimx}
\end{xremark}
\vspaceneg
%
Il existe des méthodes plus avancées qui permettent de modifier l'aspect graphique d'un élément comme la méthode \codes{itemconfigure}.\indextkk{itemconfigure} Son utilisation est peu fréquente à moins de vouloir réaliser une belle interface graphique. Le paragraphe~\ref{more_than_on_e_window_ref_liste} montre l'utilisation qu'on peut en faire.


\subsection{Liste avec barre de défilement, Combobox}
\indextk{barre de défilement}\indextkk{Scrollbar} \label{chap_interface_exemple_programme}\indexmoduleint{Tix}
	
Il n'existe pas dans le module \codes{Tkinter} d'objets \codes{List} avec une barre de défilement incluse mais il existe un autre module interne \codes{Tix}\indexmoduleint{Tix} qui étend la liste des objets proposés par \codes{Tkinter}. Ce module propose notamment une liste avec une barre de défilement intégrée~:
%
\vspaceneg
\inputcode{../python_cours/programme/listebar.py}{liste avec barre de défilement}
\vspaceneg
%
Le module \codes{Tix} quoique assez riche puisqu'il propose des fenêtres permettant de sélectionner un fichier ou de remplir un tableau est mal documenté sur \python. Il existe une documentation officielle\footnote{\httpstyle{http://pydoc.org/2.1/Tix.html} ou encore \httpstyle{http://docs.python.org/library/tix.html}} et des exemples\footnote{\httpstyle{http://coverage.livinglogic.de/index.html}}. La plupart du temps, on trouve un exemple approché. Dans l'exemple précédent comme dans le suivant avec une "\codes{ComboBox}", la pression du bouton \codes{print} écrit la zone sélectionnée. La figure~\ref{fenetre_combobox_two} illustre graphiquement ce qu'est une \codes{Combobox}.

\indextkk{ComboBox}
\vspaceneg
\inputcode{../python_cours/programme/combobox.py}{liste \codesindex{ComboBox}}
\vspaceneg
%
L'avantage du module \codes{Tix} est d'être installé automatiquement avec le langage \python. Il reste malgré tout très peu documenté et arriver à ses fins peut nécessiter quelques heures de recherche. 
	
	  \begin{figure}[ht]
	  \figureoneimagetrup{   \caption{    Exemple de fenêtre \codescaption{Combobox} définie par le module interne 
	  							\codescaption{Tix} qui est une extension du module
	  						 \codescaption{Tkinter}. La seconde image est la même \codescaption{Combobox} mais dépliée.} }
		{  \includegraphics[width=4cm]{\filextellipse{../python_cours/image/combo1}{../python_cours/image_ellipse/combo1}} }
	  { \includegraphics[width=4cm]{\filextellipse{../python_cours/image/combo2}{../python_cours/image_ellipse/combo2}} }
	  {\label{fenetre_combobox_two}}
	  \end{figure}



\subsection{Canevas}
\indextk{canevas}\indextkk{Canvas}


Pour dessiner, il faut utiliser un objet canevas, correspondant à la classe \codes{Canvas} du module \codes{Tkinter}. Pour la créer, il suffit d'écrire la ligne suivante~: \spaceneg
\indexexemples{\codesindex{Canvas}}{}
\begin{verbatimx}
    ca  = Tkinter.Canvas ()
\end{verbatimx}
\spaceneg Pour modifier les dimensions de la zone de saisie à plusieurs lignes, on utilise l'instruction suivante~:\indextkk{config}\spaceneg\indexfr{pixel}
\begin{verbatimx}
    # modifie les dimensions du canevas
    # width <--> largeur en pixels
    # height <--> hauteur en pixels
    ca.config (width = 10, height = 5)
\end{verbatimx}
\spaceneg Cet objet permet de dessiner des lignes, des courbes, d'écrire du texte grâce aux méthodes \codes{create\_line}, \codes{create\_rectangle}, \codes{create\_text}. La figure~\ref{fenetre_exemple_canvas} illustre ce que donnent les quelques lignes qui suivent.\indextkk{create\_line}\indextkk{create\_rectangle}\indextkk{create\_text}\spaceneg
\begin{verbatimx}
      # dessine deux lignes du point 10,10 au point 40,100 et au point 200,60
      # de couleur bleue, d'épaisseur 2
    ca.create_line (10,10,40,100, 200,60, fill = "blue", width = 2)
      # dessine une courbe du point 10,10 au point 200,60
      # de couleur rouge, d'épaisseur 2, c'est une courbe de Bézier
      # pour laquelle le point  40,100 sert d'assise
    ca.create_line (10,10, 40,100, 200,60, smooth=1, fill = "red", width = 2)
      # dessine un rectangle plein de couleur jaune, de bord noir et d'épaisseur 2
    ca.create_rectangle (300,100,60,120, fill = "gray", width = 2)
      # écrit du texte de couleur noire au point 80,80 et avec la police arial
    ca.create_text (80,80, text = "écrire", fill = "black", font = "arial")
\end{verbatimx}

				\begin{figure}[ht]
				\figureoneimage{  \caption{	Exemple de canevas. } }
    		{\includegraphics[width=5cm]{\filextellipse{../python_cours/image/can}{../python_cours/image_ellipse/can}} }
    		{\label{fenetre_exemple_canvas}}
    		\end{figure}
    	
\subsection{Menus}

Les menus apparaissent en haut des fenêtres. La plupart des applications arborent un menu commençant par \textit{Fichier Edition Affichage...} Le paragraphe~\ref{interface_label_menu} page~\pageref{interface_label_menu} les décrit en détail.


\subsection{Méthodes communes}  \label{methode_communes_interface}
\indextkk{config}

Nous avons vu que tous les objets présentés dans ce paragraphe possèdent une méthode \codes{config} qui permet de définir l'état du widget (grisé ou normal)\footnote{La "disparition" d'un objet est évoquée au paragraphe~\ref{disposition_paragraphe_python}.}. \indextkk{config}\indextkk{DISABLED}\indextkk{NORMAL}\spaceneg 
\begin{verbatimx}
    widget.config (state = Tkinter.DISABLED) # grisé
    widget.config (state = Tkinter.NORMAL)   # aspect normal
\end{verbatimx}
\spaceneg 
Elle permet également de modifier le texte d'un objet, sa position, ... De nombreuses options sont communes à tous les objets et certaines sont spécifiques. L'aide associée à cette méthode\footnote{Par exemple pour la classe \codesnote{Label}, cette aide est affichée grâce à l'instruction \codesnote{help (Tkinter.Label.config)}.} ne fournit aucun renseignement. En fait, le constructeur et cette méthode ont les mêmes paramètres optionnels. Il est équivalent de préciser ces options lors de l'appel au constructeur~:\spaceneg
\begin{verbatimx}
   l = Tkinter.Label (text = "légende")
\end{verbatimx}
\spaceneg 
Ou de les modifier à l'aide de la méthode \codes{config}~:
\spaceneg
\begin{verbatimx}
   l = Tkinter.Label ()
   l.config (text = "légende")
\end{verbatimx}
\spaceneg 
L'aide associée à la méthode \codes{config} est la suivante~:\indextkk{help}
\spaceneg
\begin{verbatimx}
        Help on method configure in module Tkinter:
        
        configure(self, cnf=None, **kw) unbound Tkinter.Label method
            Configure resources of a widget.
            
            The values for resources are specified as keyword
            arguments. To get an overview about
            the allowed keyword arguments call the method keys.
\end{verbatimx}
\spaceneg 
Tandis que l'aide associée au constructeur de la classe \codes{Label}\footnote{Affichée avec l'instruction \codesnote{help (Tkinter.Label.\_\_init\_\_}).} donne plus d'informations~: 
\spaceneg
\begin{verbatimx}
        __init__(self, master=None, cnf={}, **kw) unbound Tkinter.Label method
            Construct a label widget with the parent MASTER.
            
            STANDARD OPTIONS
            
                activebackground, activeforeground, anchor,
                background, bitmap, borderwidth, cursor,
                disabledforeground, font, foreground,
                highlightbackground, highlightcolor,
                highlightthickness, image, justify,
                padx, pady, relief, takefocus, text,
                textvariable, underline, wraplength
            
            WIDGET-SPECIFIC OPTIONS
            
                height, state, width
\end{verbatimx}
\vspaceneg
\indextkk{background}\indextkk{borderwidth}\indextkk{justify}\indextkk{font}\indextkk{takefocus}
Cette aide mentionne les options communes à tous les objets (ou widgets) et les options spécifiques à cet objet, ici de type \codes{Label}. Toutes ont une valeur par défaut qu'il est possible de changer soit dans le constructeur, soit par la méthode \codes{config}. Quelques-unes ont été décrites, d'autres permettent de modifier entre autres la police avec laquelle est affiché le texte de l'objet (option \codes{font}), la couleur du fond (option \codes{background}), l'alignement du texte, à gauche, à droite, centré (option \codes{justify}), l'épaisseur du bord (option \codes{borderwidth}), le fait qu'un objet reçoive le \emph{focus}\footnote{voir paragraphe~\ref{focus_paragraphe__}}\indextk{focus} après la pression de la touche tabulation (\codes{takefocus})... \indextk{touche tabulation}





\section{Disposition des objets dans une fenêtre}
\indextk{positionnement d'objet}
\label{disposition_paragraphe_python}

\subsection{Emplacements}

Chacun des objets (ou widgets) présentés au paragraphe précédent possède trois méthodes qui permettent de déterminer sa position dans une fenêtre~: \codes{pack}, \codes{grid}, \codes{place}. Les deux premières permettent de disposer les objets sans se soucier ni de leur dimension ni de leur position. La fenêtre gère cela automatiquement. La dernière place les objets dans une fenêtre à l'aide de coordonnées sans utiliser l'aide d'aucune grille. Dans une fenêtre, tous les objets doivent être placés avec la même méthode. Dans le cas contraire, les résultats risquent ne pas être ceux attendus.

\subsubsection{Méthode \codes{pack}}
\indextkk{pack}

Cette méthode empile les objets les uns à la suite des autres. Par défaut, elle les empile les uns en dessous des autres. Par exemple, l'exemple suivant produit l'empilement des objets de la figure~\ref{fenetre_exemple_pack}.
\vspaceneg
\indexexemples{\codesindex{pack}}{}
\begin{verbatimx}
    l = Tkinter.Label (text = "première ligne")
    l.pack ()
    s = Tkinter.Entry ()
    s.pack ()
    e = Tkinter.Label (text = "seconde ligne")
    e.pack ()
\end{verbatimx}
\vspaceneg


            \begin{figure}[ht]
            \figureoneimagetrup {             \caption{    Les objets sont empilés à l'aide de la méthode \codescaption{pack}
            															 les uns en dessous des autres
                                pour la première image, les uns à droite des autres pour la seconde image. \vspace{-0.5cm}} }
						{ \includegraphics[width=3.5cm]{\filextellipse{../python_cours/image/pack1}{../python_cours/image_ellipse/pack1}} }
						{ \includegraphics[width=7cm]{\filextellipse{../python_cours/image/pack2}{../python_cours/image_ellipse/pack2}}   }
            {\label{fenetre_exemple_pack}}
            \end{figure}

On peut aussi les empiler les uns à droite des autres grâce à l'option \codes{side}.\indextkk{RIGHT}\indextkk{LEFT}
\vspaceneg
\begin{verbatimx}
    l = Tkinter.Label (text = "première ligne")
    l.pack (side = Tkinter.RIGHT)
    s = Tkinter.Entry ()
    s.pack (side = Tkinter.RIGHT)
    e = Tkinter.Label (text = "seconde ligne")
    e.pack (side = Tkinter.RIGHT)
\end{verbatimx}
\vspaceneg
La méthode \codes{pack} possède trois options~: \indextkk{RIGHT}\indextkk{LEFT}\indextkk{TOP}\indextkk{BOTTOM}
\spacenegl

\begin{small}
\begin{enumerate}
        \item \codesmall{side}~: à choisir entre \codesmall{Tkinter.TOP} (valeur par défaut), \codesmall{Tkinter.LEFT},
                    \codesmall{Tkinter.BOTTOM}, \codesmall{Tkinter.RIGHT}. \spacenegl
        \item \codesmall{expand}~: égale à \codesmall{True} ou \codesmall{False} (valeur par défaut), si cette option est vraie,
                    l'objet occupe tout l'espace. \spacenegl
        \item \codesmall{fill}~: égale à \codesmall{None} (valeur par défaut), \codesmall{X}, \codesmall{Y}, \codesmall{BOTH}, 
                        l'objet s'étend selon un axe (X ou Y ou les deux). \spacenegl
\end{enumerate}
\end{small}

Il n'est pas toujours évident d'obtenir du premier coup le positionnement des objets souhaités au départ et il faut tâtonner pour y arriver. Lorsque un objet n'est plus nécessaire, il est possible de le faire disparaître en appelant la méthode \codes{pack\_forget}.\indextkk{pack\_forget} Le rappel de la méthode \codes{pack} le fera réapparaître mais rarement au même endroit.
\vspaceneg
\begin{verbatimx}
   s.pack_forget ()  # disparition
   s.pack ()         # insertion à un autre endroit
\end{verbatimx}


\subsubsection{Méthode \codes{grid}}
\indextkk{grid}

La méthode \codes{grid} suppose que la fenêtre qui les contient est organisée selon une grille dont chaque case peut recevoir un objet. L'exemple suivant place trois objets dans les cases de coordonnées $\pa{0,0}$, $\pa{1,0}$ et $\pa{0,1}$. Le résultat apparaît dans la figure~\ref{fenetre_exemple_grid}.
\vspaceneg
\indexexemples{\codesindex{grid}}{}
\begin{verbatimx}
    l = Tkinter.Label (text = "première ligne")
    l.grid (column = 0, row = 0)
    s = Tkinter.Entry ()
    s.grid (column = 0, row = 1)
    e = Tkinter.Label (text = "seconde ligne")
    e.grid (column = 1, row = 0)
\end{verbatimx}
\vspaceneg


      \begin{figure}[ht]
      \figureoneimage{       \caption{    Les objets sont placés dans une grille à l'aide de la méthode \codescaption{grid}. 
                          Une fois que chaque objet a reçu une position, à l'affichage, il ne sera pas tenu
                          compte des lignes et colonnes vides. \vspace{-0.5cm}} }
			{ \includegraphics[width=6cm]{\filextellipse{../python_cours/image/grid1}{../python_cours/image_ellipse/grid1}} }
      {\label{fenetre_exemple_grid}}
      \end{figure}



La méthode \codes{grid} possède plusieurs options, en voici cinq~: \indextkk{column}\indextkk{columnspan}\indextkk{row}\indextkk{rowspan}\indextkk{sticky}\spacenegl

\begin{small}
\begin{enumerate}
        \item \codesmall{column}~: colonne dans laquelle sera placée l'objet. \spacenegl
        \item \codesmall{columnspan}~: nombre de colonnes que doit occuper l'objet. \spacenegl
        \item \codesmall{row}~: ligne dans laquelle sera placée l'objet. \spacenegl
        \item \codesmall{rowspan}~: nombre de lignes que doit occuper l'objet. \spacenegl
        \item \codesmall{sticky}~: indique ce qu'il faut faire lorsque la case est plus grande que l'objet qu'elle doit contenir. Par défaut, l'objet est centré mais il est possible d'aligner l'objet sur un ou plusieurs bords en précisant que \codesmall{sticky = "N"} ou \codesmall{"S"} ou \codesmall{"W"} ou \codesmall{"E"}. Pour aligner l'objet sur un angle, il suffit de concaténer les deux lettres correspondant aux deux bords concernés. Il est aussi possible d'étendre l'objet d'un bord à l'autre en écrivant \codesmall{sticky = "N+S"} ou \codesmall{sticky = "E+W"}.
\end{enumerate} 
\end{small}

Enfin, comme pour la méthode \codes{pack}, il existe une méthode \codes{grid\_forget}\indextkk{grid\_forget} qui permet de faire disparaître les objets. \spaceneg
\begin{verbatimx}
   s.grid_forget ()  # disparition
\end{verbatimx}




\subsubsection{Méthode \codes{place}}
\indextkk{place}\indextkk{place\_forget}

La méthode \codes{place} est sans doute la plus simple à comprendre puisqu'elle permet de placer chaque objet à une position définie par des coordonnées. Elle peut être utilisée en parallèle avec les méthodes \codes{pack} et \codes{grid}. 
\vspaceneg
\begin{verbatimx}
    l = Tkinter.Label (text = "première ligne")
    l.place (x=10,y=50)
\end{verbatimx}
\vspaceneg
La méthode \codes{place\_forget} permet de faire disparaître un objet placer avec cette méthode. L'inconvénient de cette méthode survient lorsqu'on cherche à modifier l'emplacement d'un objet~: il faut en général revoir les positions de tous les autres éléments de la fenêtre. On procède souvent par tâtonnement pour construire une fenêtre et disposer les objets. Ce travail est beaucoup plus long avec la méthode \codes{place}.


\subsection{Sous-fenêtre}
\indextk{sous-fenêtre}\indextkk{Frame}\label{interf_fraph_sous_gene}


Les trois méthodes précédentes ne permettent pas toujours de placer les éléments comme on le désire. On souhaite parfois regrouper les objets dans des boîtes et placer celles-ci les unes par rapport aux autres. La figure~\ref{fenetre_exemple_frame} montre deux objets regroupés dans un rectangle avec à sa gauche une zone de texte. Les boîtes sont des instances de la classe \codes{Frame}. Ce sont des objets comme les autres excepté le fait qu'une boîte contient d'autres objets y compris de type \codes{Frame}. Pour créer une boîte, il suffit d'écrire la ligne suivante~:
\spacenegl
\indexexemples{\codesindex{Frame}}{}
\begin{verbatimx}
    f = Tkinter.Frame ()
\end{verbatimx}
\spacenegl
Ensuite, il faut pouvoir affecter un objet à cette boîte \codes{f}. Pour cela, il suffit que \codes{f} soit le premier paramètre du constructeur de l'objet créé~:
\spacenegl
\begin{verbatimx}
    l = Tkinter.Label (f, text = "première ligne")
\end{verbatimx}        
\spacenegl
L'exemple qui suit correspond au code qui permet d'afficher la fenêtre de la figure~\ref{fenetre_exemple_frame}~:\indextkk{RIGHT}\indextkk{LEFT}
\spacenegl
\begin{verbatimx}
    f = Tkinter.Frame ()
    l = Tkinter.Label (f, text = "première ligne")
    l.pack ()                     # positionne l à l'intérieur de f
    s = Tkinter.Entry (f)
    s.pack ()                     # positionne s à l'intérieur de f
    f.pack (side = Tkinter.LEFT)  # positionne f à l'intérieur   
                                  #   de la fenêtre principale
    e = Tkinter.Label (text = "seconde ligne")
    e.pack_forget ()
    e.pack (side = Tkinter.RIGHT) # positionne e à l'intérieur 
                                  #   de la fenêtre principale
\end{verbatimx}
\vspaceneg
%
L'utilisation de ces blocs \codes{Frame} est pratique lorsque le même ensemble de contrôles apparaît dans plusieurs fenêtres différentes ou au sein de la même fenêtre. Cette possibilité est envisagée au paragraphe~\ref{more_than_on_e_window_ref}.

	    \begin{figure}[ht]
	    \figureoneimage{ 	    \caption{Les deux premiers objets -~une zone de texte au-dessus d'une zone de saisie~-
	                     sont regroupés dans une boîte -~rectangle rouge, invisible à l'écran. A droite
	                     et centrée, une dernière zone de texte. Cet alignement est plus simple à réaliser 
	                     en regroupant les deux premiers objets dans un rectangle (objet \codescaption{Frame}).\vspace{-0.9cm}} }
			{ \includegraphics[width=5cm]{\filextellipse{../python_cours/image/frame}{../python_cours/image_ellipse/frame}}  }
	    {\label{fenetre_exemple_frame}}
	    \end{figure}


\section{Evénements}

\subsection{Fenêtre principale}
\indextkk{Tk}\indextkk{mainloop}
\label{mainloop_fenetre_principale}

Tous les exemples des paragraphes précédents décrivent les différents objets disponibles et comment les disposer dans une fenêtre. Pour afficher cette fenêtre, il suffit d'ajouter au programme les deux lignes suivantes~: \spaceneg
%
\indexexemples{\codesindex{mainloop}}{}
\begin{verbatimx}
    root = Tkinter.Tk ()
    #  ici, on trouve le code qui définit les objets
    #  et leur positionnement
    root.mainloop ()
\end{verbatimx}
%
\indextk{boucle de message} \spaceneg
La première ligne permet d'obtenir un identificateur relié à la fenêtre principale. La seconde ligne, outre le fait qu'elle affiche cette fenêtre, lance ce qu'on appelle une \emph{boucle de messages}. Cette fonction récupère -~intercepte~- les événements comme un clic de souris, la pression d'une touche. Elle parcourt ensuite tous les objets qu'elle contient et regarde si l'un de ces objets est intéressé par cet événement. S'il est intéressé, cet objet prend l'événement et le traite. On peut revenir ensuite à la fonction \codes{mainloop} qui attend à nouveau un événement. Cette fonction est définie par \codes{Tkinter}, il reste à lui indiquer quels événements un objet désire intercepter et ce qu'il est prévu de faire au cas où cet événement se produit.

\begin{xremark}{instruction \codes{root = Tkinter.Tk ()}}
Cette première instruction doit se trouver au début du programme. Si elle intervient alors qu'une méthode de positionnement (\codes{pack}, \codes{grid}, ou \codes{place}) a déjà été appelée, le programme affichera deux fenêtres dont une vide.
\end{xremark}




\subsection{Focus}
\label{focus_paragraphe__}

\indextk{focus}\indextk{tabulation}\indextkk{focus\_set}
Une fenêtre peut contenir plusieurs zones de saisie, toutes capables d'intercepter la pression d'une touche du clavier et d'ajouter la lettre correspondante à la zone de saisie. Or la seule qui ajoute effectivement une lettre à son contenu est celle qui a le \emph{focus}. La pression de la touche tabulation fait passer le focus d'un objet à l'autre. La figure~\ref{fenetre_exemple_focus} montre un bouton qui a le focus. Lorsqu'on désire qu'un objet en particulier ait le focus, il suffit d'appeler la méthode \codes{focus\_set}.\indextkk{focus\_set}\indexfr{focus}
%
\vspaceneg
\begin{verbatimx}
    e = Tkinter.Entry ()
    e.pack ()
    e.focus_set ()
\end{verbatimx}



				\begin{figure}[ht]
				\figureoneimage{ \caption{Ce bouton est entouré d'un cercle noir en pointillé, il a le \emph{focus}. \vspace{-0.5cm}}}
				{ \includegraphics[width=2cm]{\filextellipse{../python_cours/image/focus}{../python_cours/image_ellipse/focus}}  }
				{\label{fenetre_exemple_focus}}
				\end{figure}
				

\subsection{Lancer une fonction lorsqu'un bouton est pressé}
\label{bouton_command_association}

La plupart de temps, le seul événement qu'on souhaite attraper est la pression d'un bouton. Le code suivant permet de créer un bouton dont l'identificateur est \codes{b}. Il a pour intitulé \codes{fonction \; change\_legende}. On définit ensuite une fonction \codes{change\_legende} qui change la légende de ce bouton. L'avant-dernière ligne permet d'associer au bouton \codes{b} la fonction \codes{change\_legende} qui est alors appelée lorsque le bouton est pressé. La dernière ligne affiche la fenêtre principale et lance l'application.
%
\vspaceneg
\inputcode{../python_cours/programme/command.py}{Tkinter, bouton}
\vspaceneg
% 
Lorsque le bouton \codes{b} est pressé, on vérifie qu'il change bien de légende (voir figure~\ref{fenetre_exemple_commande}).


			\begin{figure}[ht]
			\figureoneimagetrup{ 			\caption{La première fenêtre est celle qui apparaît lorsque le programme de la 
															page~\pageref{bouton_command_association} est lancé. Comme le bouton change de légende la première
			      fois qu'il est pressé, l'apparence de la fenêtre change aussi, ce que montre la seconde image.} }
			{ \includegraphics[width=3cm]{\filextellipse{../python_cours/image/comm1}{../python_cours/image_ellipse/comm1}}  }
			{ \includegraphics[width=3cm]{\filextellipse{../python_cours/image/comm2}{../python_cours/image_ellipse/comm2}} }
			{\label{fenetre_exemple_commande}}
			\end{figure}
			
\begin{xremark}{événement associé à une méthode}
L'exemple\label{remarque_evenement_associe_methode_tkinter} précédent associe une fonction au bouton. Lorsque l'interface devient conséquente, la lisibilité du programme en est réduite car le nombre de fonctions associées à des boutons augmentent rapidement. Pour éviter cela, il est possible d'associer au bouton une méthode de classe comme le suggère l'exemple du paragraphe~\ref{more_than_on_e_window_ref}.
\end{xremark}


				
				
\subsection{Associer n'importe quel événement à un objet}
\indextk{événement, association}
\label{parag_graph_bind}
Le paragraphe précédent s'est intéressé à l'association entre une fonction et la pression d'un bouton mais il est possible de faire en sorte que le programme exécute une fonction au moindre déplacement de la souris, à la pression d'une touche. Il est possible d'associer une fonction au moindre événement susceptible d'être intercepté par l'interface graphique. 

On peut regrouper les événements en deux classes. La première classe regroupe les événements provenant du clavier ou de la souris. Ce sont des événements en quelque sorte \textit{bruts}.\indexfrr{événement}{brut} La seconde classe regroupe des événements produit par des objets tels qu'un bouton. En effet, lorsque celui-ci détecte le clic du bouton droit de la souris, il construit un événement \codes{"pression du bouton"} et c'est celui-ci qui va déclencher l'exécution d'une fonction. Il n'est pas souvent nécessaire de revenir aux événements \textit{bruts} car les objets proposent d'eux-mêmes de pouvoir attacher des fonctions à des événements liés à leur apparence.

Toutefois, pour un jeu par exemple, il est parfois nécessaire d'avoir accès au mouvement de la souris et il faut revenir aux événements \textit{bruts}. Un événement est décrit par la classe \codes{Event} dont les attributs listés par la table~\ref{table_attribut_event} décrivent l'événement qui sera la plupart du temps la pression d'une touche du clavier ou le mouvement de la souris.\indextkk{Event} 

            \begin{table}[ht]
            \begin{center}\begin{tabularx}{\textwidth}{|l|X|} \hline
            \codes{char} &     %\begin{minipage}{10cm}
                                            Lorsqu'une touche a été pressée, cet attribut contient son code, il ne tient pas compte des
                                            touches dites muettes \indextk{touches muettes} comme les touches \codes{shift},
                                            \codes{ctrl}, \codes{alt}.
                                            Il tient pas compte non plus des touches \codes{return} ou \codes{suppr}.
                                          %\end{minipage} 
                                          \\ \hline
            \codes{keysym} &     %\begin{minipage}{10cm} 
                                                Lorsqu'une touche a été pressée, cet attribut contient son code, quelque
                                                soit la touche, muette ou non.
                                          %\end{minipage} 
                                          \\ \hline
            \codes{num} &     %\begin{minipage}{10cm}
                                            Contient un identificateur de l'objet ayant reçu l'événement.
                                          %\end{minipage} 
                                          \\ \hline
            \codes{x,y} &     %\begin{minipage}{10cm}
                                            Coordonnées relatives de la souris par rapport au coin supérieur gauche de l'objet
                                            ayant reçu l'événement.
                                          %\end{minipage} 
                                          \\ \hline
            \codes{x\_root, y\_root} &     %\begin{minipage}{10cm}
                                            Coordonnées absolues de la souris par rapport au coin supérieur gauche de l'écran.
                                          %\end{minipage} 
                                          \\ \hline
            \codes{widget} &     %\begin{minipage}{10cm}
                                            Identifiant permettant d'accéder à l'objet ayant reçu l'événement.
                                          %\end{minipage} 
                                          \\ \hline
            \end{tabularx}\end{center}
            \caption{Attributs principaux de la classe \codescaption{Event}, ils décrivent les événements liés au clavier
                                et à la souris. La liste complète est accessible en utilisant 
                                l'instruction \codescaption{help (Tkinter.Event)}.}
            \label{table_attribut_event}
            \end{table}


La méthode \codes{bind}\indextkk{bind} permet d'exécuter une fonction lorsqu'un certain événement donné est intercepté par un objet donné. La fonction exécutée accepte un seul paramètre de type \codes{Event} qui est l'événement qui l'a déclenchée. Cette méthode a pour syntaxe~:


\begin{xsyntax}{méthode \codes{bind}}\indextkk{bind}
\begin{verbatimno}

w.bind (ev, fonction)
\end{verbatimno}
\negvspace
\codes{w} est l'identificateur de l'objet devant intercepter l'événement désigné par la chaîne de 
caractères \codes{ev} (voir table~\ref{table_attribut_event_liste}). 
\codes{fonction} est la fonction qui est appelée lorsque l'événement survient. Cette fonction
ne prend qu'un paramètre de type \codes{Event}.                 \indextkk{bind}
\end{xsyntax}


            \begin{table}[ht]
            \begin{center}\begin{tabularx}{\textwidth}{|l|X|} \hline
            \texttt{<Key>} &     %\begin{minipage}{10cm}
                                                Intercepter la pression de n'importe quelle touche du clavier.
                                          %\end{minipage} 
                                          \\ \hline
            \texttt{<Button-i>} &     %\begin{minipage}{10cm}
                                            Intercepter la pression d'un bouton de la souris.
                                            \codes{i} doit être remplacé par 1,2,3. 
                                          %\end{minipage} 
                                          \\ \hline
            \texttt{<ButtonRelease-i>} &     %\begin{minipage}{10cm}
                                            Intercepter le relâchement d'un bouton de la souris.
                                            \codes{i} doit être remplacé par 1,2,3. 
                                          %\end{minipage} 
                                          \\ \hline
            \texttt{<Double-Button-i>} &     %\begin{minipage}{10cm}
                                            Intercepter la double pression d'un bouton de la souris.
                                            \codes{i} doit être remplacé par 1,2,3. 
                                          %\end{minipage} 
                                          \\ \hline
            \texttt{<Motion>} &     %\begin{minipage}{10cm}
                                            Intercepter le mouvement de la souris, dès que le curseur bouge, la fonction liée
                                            à l'événement est appelée.
                                          %\end{minipage} 
                                          \\ \hline
            \texttt{<Enter>} &     %\begin{minipage}{10cm}
                                            Intercepter un événement correspondant au fait que le curseur de la souris entre la zone
                                            graphique de l'objet.
                                          %\end{minipage} 
                                          \\ \hline
            \texttt{<Leave>} &     %\begin{minipage}{10cm}
                                            Intercepter un événement correspondant au fait que le curseur de la souris sorte la zone
                                            graphique de l'objet.
                                          %\end{minipage} 
                                          \\ \hline
            \end{tabularx}\end{center}
            \caption{Chaînes de caractères correspondant aux principaux types d'événements qu'il est 
                             possible d'intercepter avec le module \codescaption{Tkinter}. La liste complète est accessible en
                             utilisant l'instruction \codescaption{help (Tkinter.Label.bind)}.}
						\indextkk{<Key>}\indextkk{<Button-i>}\indextkk{<ButtonRelease-i>}\indextkk{<Double-Button-i>}\indextkk{<Motion>}
						\indextkk{<Enter>}\indextkk{<Leave>}
            \label{table_attribut_event_liste}
            \end{table}

L'exemple suivant utilise la méthode \codes{bind} pour que le seul bouton de la fenêtre intercepte toute pression d'une touche, tout mouvement et toute pression du premier bouton de la souris lorsque le curseur est au dessus de la zone graphique du bouton. La fenêtre crée par ce programme ainsi que l'affichage qui en résulte apparaissent dans la figure~\ref{fenetre_exemple_commande_bind}.
%
\vspaceneg
\inputcode{../python_cours/programme/exemple_bind.py}{Tkinter, fonction \codesindex{bind}}

				  % bug bug
\begin{figure}[ht]
\begin{center}\begin{tabular}{cc}
\begin{tabular}{|c|}\hline
\includegraphics[width=3.5cm]{\filextellipse{../python_cours/image/bind}{../python_cours/image_ellipse/bind}} \\ \hline
\end{tabular} & \begin{tabular}{cc}
\begin{minipage}{4.2cm}
\begin{verbatimx}
evt.char =  ??
evt.keysym =  ??
evt.num =  1
evt.x,evt.y =  105 , 13
evt.x_root,evt.y_root = 
               292 , 239
evt.widget =  .9261224
\end{verbatimx}
\end{minipage}
&
\begin{minipage}{4.2cm}
\begin{verbatimx}
evt.char =  
evt.keysym =  Return
evt.num =  ??
evt.x,evt.y =  105 , 13
evt.x_root,evt.y_root = 
               292 , 239
evt.widget =  .9261224
\end{verbatimx}
\end{minipage}
\end{tabular}\end{tabular}\end{center}
\caption{ Fenêtre affichée par le programme du paragraphe~\ref{parag_graph_bind}.
              La pression d'une touche déclenche l'affichage des caractéristiques de l'événement.
              La seconde colonne correspond à la pression du premier bouton de la souris.
              La dernière colonne    correspond à la pression de la touche \codescaption{Return}.}
\label{fenetre_exemple_commande_bind}
\indextkk{Event}
\end{figure}


\begin{xremark}{focus}
L'avant dernière ligne du programme fait intervenir la méthode \codes{focus\_set}. Elle stipule que le bouton doit recevoir le \codes{focus}.\indextk{focus} C'est-à-dire que cet objet est celui qui peut intercepter les événements liés au clavier. Sans cette instruction, cet objet n'y a pas accès, ces événements sont dirigés vers la fenêtre principale qui ne s'en soucie pas.\indextkk{focus\_set}
\end{xremark}



\begin{xremark}{mauvais événement}
Les messages d'erreur liés aux événements ne sont pas forcément très explicites. Ainsi l'instruction suivante adresse un événement inexistant.
\vspaceneg
\begin{verbatimx}
b.bind ("<button-1>", affiche_touche_pressee)
\end{verbatimx}
\vspaceneg
Lors de l'exécution, le programme déclenche la succession d'exceptions suivantes qui signifie que l'événement \texttt{<button-1>} n'existe pas.
\vspaceneg
\begin{verbatimx}
Traceback (most recent call last):
  File "exemple_bind.py", line 17, in ?
    b.bind ("<button-1>", affiche_touche_pressee)
  File "c:\python26\lib\lib-tk\Tkinter.py", line 933, in bind
    return self._bind(('bind', self._w), sequence, func, add)
  File "c:\python26\lib\lib-tk\Tkinter.py", line 888, in _bind
    self.tk.call(what + (sequence, cmd))
_tkinter.TclError: bad event type or keysym "button"
\end{verbatimx}
\end{xremark}
\vspaceneg

\begin{xremark}{associer un événement à tous les objets}
Il arrive parfois qu'un événement ne doive pas être associé à un seul objet mais à tous ceux que la fenêtre contient. C'est l'objectif de la méthode \codes{bind\_all}. Sa syntaxe est exactement la même que la méthode \codes{bind}.\indextkk{bind\_all}
\vspaceneg
\begin{verbatimx}
b.bind_all ("<Button-1>", affiche_touche_pressee)
\end{verbatimx}
\vspaceneg
On utilise peu cette fonction, on préfère construire des objets propres à un programme comme suggéré au paragraphe~\ref{more_than_on_e_window_ref_liste}.
\end{xremark}




\begin{xremark}{désactiver un événement}
De la même manière qu'il est possible d'associer un événement à un objet d'une fenêtre, il est possible d'effectuer l'opération inverse qui consiste à supprimer cette association.\indextk{événement, désactivation}\indextkk{unbind} La méthode \codes{unbind} désactive un événement associé à un objet. La méthode \codes{unbind\_all}\indextkk{unbind\_all} désactive un événement associé pour tous les objets d'une fenêtre.

\begin{xsyntax}{méthode \codes{unbind}}
\begin{verbatimno}

w.unbind (ev)
w.unbind_all (ev)
\end{verbatimno}
\negvspace
\codes{w} est l'identificateur de l'objet interceptant l'événement désigné par la chaîne de 
caractères \codes{ev} (voir table~\ref{table_attribut_event_liste}). Après l'appel à la méthode \codes{unbind},
l'événement n'est plus intercepté par l'objet \codes{w}. Après l'appel à la méthode \codes{unbind\_all},
l'événement n'est plus intercepté par aucun objet. \indextkk{unbind}\indextkk{unbind\_all}
\end{xsyntax}
\end{xremark}

\begin{xremark}{événement spécifique}
Il est possible de définir des événements propres aux programmes. Ceux-ci ne sont générés par aucun périphérique mais explicitement par le programme lui-même. Ce mécanisme est presque toujours couplé à l'utilisation de threads. Le paragraphe \ref{thread_interface_graphique} (page~\pageref{thread_interface_graphique}) illustre ce principe à l'aide d'un exemple à base de thread. Le paragraphe~\ref{resultat_communiquer_message} page~\pageref{resultat_communiquer_message} propose un exemple plus simple.
\end{xremark}





\subsection{Menu}\label{interface_label_menu}
\indextk{menu}\indextkk{Menu}

Les menus fonctionnent de la même manière que les boutons. Chaque intitulé du menu est relié à une fonction qui sera exécutée à la condition que l'utilisateur sélectionne cet intitulé. L'objet \codes{Menu} ne désigne pas le menu dans son ensemble mais seulement un niveau. Par exemple, le menu présenté par la figure~\ref{fenetre_exemple_menu} est en fait un assemblage de trois menus auquel on pourrait ajouter d'autres sous-menus.  

			\begin{figure}[ht]
			\figureoneimage{ 			\caption{La représentation d'un menu tient plus d'un graphe que d'une liste. Chaque intitulé
			           du menu peut être connecté à une fonction ou être le point d'entrée d'un nouveau sous-menu.} }
			{ \includegraphics[width=5cm]{\filextellipse{../python_cours/image/menut}{../python_cours/image_ellipse/menut}} }
			{\label{fenetre_exemple_menu_graphe}}
			\end{figure}

Pour créer un menu ou un sous-menu, il suffit de créer un objet de type \codes{Menu}~: \spaceneg
\indexexemples{\codesindex{Menu}}{}
\begin{verbatimx}
m = Tkinter.Menu ()
\end{verbatimx}
\spaceneg Ce menu peut être le menu principal d'une fenêtre auquel cas, il suffit de préciser à la fenêtre en question que son menu est le suivant~: \indextkk{config}\spaceneg
\begin{verbatimx}
root.config (menu = m)
\end{verbatimx}
\spaceneg \codes{root} est ici la fenêtre principale mais ce pourrait être également une fenêtre de type \codes{TopLevel} (voir paragraphe~\ref{menu_paragraphe_toplevel}). Ce menu peut aussi être le sous-menu associé à un intitulé d'un menu existant. La méthode \codes{add\_cascade} permet d'ajouter un sous-menu associé à un label~: \indextkk{add\_cascade} \spaceneg
\begin{verbatimx}
mainmenu  = Tkinter.Menu ()
msousmenu = Tkinter.Menu ()
mainmenu.add_cascade (label = "sous-menu 1", menu = msousmenu)
\end{verbatimx}
\spaceneg En revanche, si on souhaite affecter une fonction à un menu, on utilisera la méthode \codes{add\_command}~: \spaceneg \indextkk{add\_command}
\begin{verbatimx}
def fonction1 () :
    ....
m = Tkinter.Menu ()
mainmenu.add_command (label = "fonction 1", command = fonction1)
\end{verbatimx}
\spaceneg L'exemple suivant regroupe les fonctionnalités présentées ci-dessus.
%
\vspaceneg
\inputcode{../python_cours/programme/exemple_menu.py}{Tkinter, menu}
\vspaceneg


			\begin{figure}[ht]
			\figureoneimage{ 			\caption{Résultat de l'exemple du paragraphe~\ref{interface_label_menu}, la sélection de différents
			             intitulés du menu permet d'afficher des choses avec l'instruction \codescaption{print} ou 
			             d'ajouter des boutons.} }
			{ 			\includegraphics[width=5cm]{\filextellipse{../python_cours/image/menu}{../python_cours/image_ellipse/menu}} }
			{\label{fenetre_exemple_menu}}
			\end{figure}

Chaque intitulé d'un menu est ajouté en fin de liste, il est possible d'en supprimer certains à partir de leur position avec la méthode \codes{delete}~:
\vspaceneg
\begin{verbatimx}
m = Tkinter.Menu ()
m.add_command (...)
m.delete (1, 2) # supprime le second intitulé
                # supprime les intitulés compris entre 1 et 2 exclu
\end{verbatimx}


\subsection{Fonctions prédéfinies}\label{fonction_predefeinies_toot}

Il est possible de détruire la fenêtre principale, ce qui mettra fin au programme si celui-ci ne prévoit rien après la fonction \codes{mainloop}. La destruction de la fenêtre s'effectue par la méthode \codes{destroy}.\indextkk{destroy} Le programme suivant crée une fenêtre avec un seul bouton qui, s'il est pressé, mettra fin à l'application. \spaceneg
\begin{verbatimx}
import Tkinter
root = Tkinter.Tk ()
Tkinter.Button (text = "fin", command = root.destroy).pack ()
root.mainloop ()
\end{verbatimx}
\spaceneg La table~\ref{table_tople_vel_method} regroupe les fonctions les plus utilisées. Celles-ci s'applique à une fenêtre de type \codes{Toplevel} qui est aussi le type de la fenêtre principale.\indextkk{Toplevel}

\begin{table}[ht]
\begin{center}\begin{tabularx}{\textwidth}{|l|X|} \hline
\codes{destroy()} 				& Détruit la fenêtre. \\ \hline
\codes{deiconify()} 			& La fenêtre reprend une taille normale.\\ \hline
\codes{geometry (s) }			& Modifie la taille de la fenêtre. \codes{s} est une chaîne de caractères de type \codes{"wxh±x±y"}.
														\codes{w} et \codes{h} sont la largeur et la hauteur. \codes{x} et \codes{y} sont la position
													  du coin supérieur haut à l'écran. \\ \hline
\codes{iconify()} 				& La fenêtre se réduit à un icône.\\ \hline
\codes{resizable(w,h) } 	& Spécifie si la fenêtre peut changer de taille. \codes{w} et \codes{h} sont des booléens.\\ \hline
\codes{title(s) } 				& Change le titre de la fenêtre, \codes{s} est une chaîne de caractères. \\ \hline
\codes{withdraw() } 			& Fait disparaître la fenêtre. La fonction inverse est \codes{deiconify}.\\ \hline
\end{tabularx}\end{center}
\caption{Liste non exhaustives des méthodes de la classe \codescaption{Toplevel} qui le type de la fenêtre principale.}
\indextkk{destroy}\indextkk{deiconify}\indextkk{title}\indextkk{iconify}\indextkk{resizable}\indextkk{geometry}\indextkk{withdraw}
\label{table_tople_vel_method}
\end{table}

\section{D'autres fenêtres}


\subsection{Créer une seconde boîte de dialogues}\label{menu_paragraphe_toplevel} 
\indextk{fenêtre}\indextkk{Toplevel}

Lorsqu'un programme doit utiliser plusieurs fenêtres et non pas une seule, l'emploi de l'objet \codes{Toplevel} est inévitable. L'instruction \codes{root = Tkinter.Tk ()} crée la fenêtre principale, l'instruction \codes{win = Tkinter.Toplevel ()} crée une seconde fenêtre qui fonctionne exactement comme la fenêtre principale puisqu'elle dispose elle aussi d'une boucle de messages via la méthode \codes{mainloop}.
\vspaceneg
\begin{verbatimx}
import Tkinter
win = Tkinter.Toplevel ()
win.mainloop ()
\end{verbatimx}
\vspaceneg

Un cas d'utilisation simple est par exemple un bouton pressé qui fait apparaître une fenêtre permettant de sélectionner un fichier, cette seconde fenêtre sera un objet \codes{Toplevel}. Il n'est pas nécessaire de s'étendre plus sur cet objet, son comportement est identique à celui de la fenêtre principale, les fonctions décrites au paragraphe~\ref{fonction_predefeinies_toot} s'appliquent également aux objets \codes{Toplevel}. Il reste néanmoins à préciser un dernier point. Tous les objets précédemment décrits au paragraphe~\ref{interface_graphique_objet_s} doivent inclure un paramètre supplémentaire dans leur constructeur pour signifier qu'ils appartiennent à un objet \codes{Toplevel} et non à la fenêtre principale. Par exemple, pour créer une zone de texte, la syntaxe est la suivante~: \spaceneg
\begin{verbatimx}
# zone_texte appartient à la fenêtre principale
zone_texte = Tkinter.Label (text = "premier texte")
\end{verbatimx}
\spaceneg Pour l'inclure à une fenêtre \codes{Toplevel}, cette syntaxe devient~:\spaceneg
\begin{verbatimx}
# zone_texte appartient à la fenêtre top
top = Tkinter.Toplevel ()
zone_texte = Tkinter.Label (top, text = "premier texte")
\end{verbatimx}
\spaceneg Lors de la définition de chaque objet ou \textit{widget}, si le premier paramètre est de type \codes{Toplevel}, alors ce paramètre sera affecté à la fenêtre passée en premier argument et non à la fenêtre principale. Ce principe est le même que celui de la sous-fenêtre \codes{Frame} (voir paragraphe~\ref{interf_fraph_sous_gene}, page~\pageref{interf_fraph_sous_gene}). La seule différence provient du fait que l'objet \codes{Toplevel} est une fenêtre autonome qui peut attendre un message grâce à la méthode \codes{mainloop}, ce n'est pas le cas de l'objet \codes{Frame}. \indextkk{mainloop}

Toutefois, il est possible d'afficher plusieurs fenêtre \codes{Toplevel} simultanément. Le programme suivant en est un exemple~:
\inputcode{../python_cours/programme/toplevel_ex.py}{plusieurs fenêtre \codesindex{Toplevel}}

\subsection{Fenêtres standard} \label{selection_de_fichier}


\indexmoduleint{Tix}
Le module \codes{Tix} propose une fenêtre de sélection de fichiers identique à celle de la figure~\ref{fenetre_exemple_1}. \codes{Tkinter} a l'avantage d'être simple et ne nécessite pas un long apprentissage pour le maîtriser mais il est limité. Pour ce type de fenêtres qu'on retrouve dans la plupart des programmes, il existe presque toujours des solutions toutes faites, via le module \codes{Tix} par exemple. On trouve également de nombreux programmes sur Internet par le biais de moteurs de recherche. Le programme ci-dessous affiche une fenêtre qui permet de sélectionner un fichier.
%
\vspaceneg
\inputcode{../python_cours/programme/filesel.py}{sélection d'un fichier}

				\begin{figure}[ht]
				\figureoneimage{     		\caption{	Exemple d'une fenêtre graphique. Celle-ci permet de sélectionner un fichier.
    							C'est une fenêtre prédéfinie du module \codescaption{Tix} qui est une extension de \codescaption{Tkinter}.
    							 } }{
    		\includegraphics[width=6cm]{\filextellipse{../python_cours/image/tixfile}
    		{../python_cours/image_ellipse/tixfile}} }
    		{\label{fenetre_exemple_1}}
    		\indexmoduleint{Tix}
    		\end{figure}


\if 0
\subsection{D'autres librairies}\label{autre_libreaire_tkinter}

Les modules \codes{Tix} et \textit{Pmw} proposent la plupart des fenêtres ou composants graphiques standards. \codes{Tix} est un module interne tandis que \codes{Pmw} est un module externe.\indexmoduleint{Tix}\indexmoduleext{Pmw} La documentation qui leur est associée manque de clarté mais ils sont doute un choix judicieux pour de petits programmes.

Des modules tels que \codes{wxPython}, \codes{pyQt} ou \codes{pyGTK} vont plus loin en proposant dans composants capables de sélectionner une imprimante, de visualiser une page HTML, d'afficher un tableau. Mais leur utilisation nécessite quelques heures d'apprentissage et de recherche. Ces modules sont abordés au paragraphe~\ref{par_intro_interface_g} page~\pageref{par_intro_interface_g}. En revanche, ils ne peuvent être utilisés ensemble pour construire la même interface. Il faut choisir entre \codes{Tkinter} et \codes{Tix} ou \codes{wxPython} ou \codes{pyQt} ou...
\fi





\section{Constructions classiques}

L'objectif des paragraphes qui suivent est d'introduire quelques schémas de construction d'interfaces qui reviennent fréquemment. La première règle de programmation qu'il est préférable de suivre est d'isoler la partie interface du reste du programme. La gestion événementielle a pour défaut parfois de disséminer un traitement, un calcul à plusieurs endroits de l'interface. C'est le cas par exemple de longs calculs dont on souhaite connaître l'avancée. Le calcul est lancé par la pression d'un bouton puis son déroulement est "espionné" par un événement régulier comme un compte à rebours.

Le principal problème des interfaces survient lors du traitement d'un événement~: pendant ce temps, l'interface n'est pas réactive et ne réagit plus aux autres événements jusqu'à ce que le traitement de l'événement en cours soit terminé. Pour contourner ce problème, il est possible soit de découper un calcul en petites fonctions chacune très rapide, cela suppose que ce calcul sera mené à bien par une succession d'événements. Il est également possible de lancer un thread, principe décrit au paragraphe~\ref{thread_interface_graphique} (page~\pageref{thread_interface_graphique}).

C'est pourquoi la première règle est de bien scinder interface et calculs scientifiques de façon à pouvoir rendre le programme plus lisible et ainsi être en mesure d'isoler plus rapidement la source d'une erreur. Les paragraphes qui suivent présentent quelques aspects récurrents qu'il est parfois utile d'avoir en tête avant de se lancer.

\subsection{Compte à rebours}
\indextk{compte à rebours}\label{par_compte_a_rebours}

Il est possible de demander à un objet d'appeler une fonction après un certains laps de temps exprimé un millisecondes. Le programme suivant crée un objet de type \codes{Label}. Il contient une fonction qui change son contenu et lui affecte un compte à rebours qui impose à l'objet de rappeler cette fonction 1000 millisecondes plus tard. Le résultat est un programme qui crée la fenêtre~\ref{fenetre_exemple_after} et change son contenu toutes les secondes.

\vspaceneg
\inputcode{../python_cours/programme/after.py}{Tkinter, compte à rebours}

					\begin{figure}[ht]
					\figureoneimage{ 					\caption{Résultat de l'exemple du paragraphe~\ref{par_compte_a_rebours}, l'intitulé de l'objet
														 \codescaption{Label} change toutes les secondes.}}
					{ \includegraphics[width=4cm]{\filextellipse{../python_cours/image/after}{../python_cours/image_ellipse/after}}}
					{\label{fenetre_exemple_after}}
					\end{figure}
\spaceneg

La méthode \codes{after} retourne un entier permettant d'identifier le compte à rebours qu'il est possible d'interrompre en utilisant la méthode \codes{after\_cancel}. Dans l'exemple précédent, il faudrait utiliser l'instruction suivante~:\indextkk{after\_cancel}\indextkk{after}
\vspaceneg
\begin{verbatimx}
    l.after_cancel (id)
\end{verbatimx}


\subsection{Contrôles personnalisés~: utilisation des classes}  \label{more_than_on_e_window_ref_liste} 
\indextkk{Listbox}\indextkk{itemconfigure}\indextkk{nearest}

On peut personnifier un contrôle. Par exemple, on peut mettre en évidence l'intitulé d'une liste sous le curseur de la souris. Le moyen le plus simple est de créer une nouvelle classe qui se substituera au classique \codes{Listbox}. Il suffit que cette nouvelle classe hérite de \codes{Listbox} en prenant soin de lui donner un constructeur reprenant les mêmes paramètres que celui de la classe \codes{Listbox}. De cette façon, il suffit de remplacer \codes{Listbox} par \codes{MaListbox} pour changer l'apparence d'une liste. 
%
\label{more_than_on_e_window_ref_liste_mage}
\vspaceneg
\inputcode{../python_cours/programme/listst.py}{\codesindex{Listbox} réagissant au curseur}
\vspaceneg
%
Dans ce cas précis, on fait en sorte que le contrôle intercepte le mouvement du curseur. Lorsque celui-ci bouge, la méthode \codes{mouvement} est appelée comme le constructeur de \codes{MaListbox} l'a spécifié. La méthode \codes{nearest} permet de définir l'intitulé le plus proche du curseur. La méthode \codes{itemconfigure} permet de changer le fond de cet intitulé en gris après avoir modifié le fond de l'intitulé précédent pour qu'il retrouve sa couleur d'avant. Le résultat est illustré la figure~\ref{listbox_curseur_soiut}.

				\begin{figure}[ht]
				\figureoneimage{ 				\caption{Aspect de la classe \codescaption{MaListbox} définie par le 
														programme~\pageref{more_than_on_e_window_ref_liste_mage}. L'intitulé sous le curseur
														de la souris a un fond gris. }}
				{  \includegraphics[width=3cm]{\filextellipse{../python_cours/image/listboxs}
						{../python_cours/image_ellipse/listboxs}} }
				{\label{listbox_curseur_soiut}}
				\end{figure}


\subsection{Fenêtres personnalisées~: utilisation des classes}  \label{more_than_on_e_window_ref}

Cet exemple prolonge l'idée du paragraphe précédent. Lorsque l'interface devient complexe, il peut être utile de créer ses propres fenêtres. Jusqu'à présent, seules des fonctions ont été attachées à événement comme la pression d'un bouton mais il est possible d'attacher la méthode d'une classe ce que développe l'exemple qui suit.
%
\vspaceneg
\inputcode{../python_cours/programme/classique.py}{Tkinter avec des classes}
\vspaceneg
%
Ce programme crée trois boutons et attache à chacun d'entre eux une méthode de la classe \codes{MaFenetre}. Le constructeur de la classe prend comme unique paramètre un pointeur sur un objet qui peut être la fenêtre principale, un objet de type \codes{Frame} ou \codes{Toplevel}. Cette construction permet de considérer cet ensemble de trois boutons comme un objet à part entière~; de ce fait il peut être inséré plusieurs fois comme le montre l'exemple suivant illustré par la figure~\ref{fenetre_ma_perso_fig}.
%
\vspaceneg
\begin{verbatimx}    
    root = Tk.Tk ()
    f = Tk.Frame ()
    f.pack ()
    MaFenetre (f)      # première instance
    g = Tk.Frame ()
    g.pack ()
    MaFenetre (g)      # seconde instance
    root.mainloop ()
\end{verbatimx}    
\vspaceneg
%
				\begin{figure}[ht]
				\figureoneimage{ 				\caption{Aspect de la classe \codescaption{MaFenetre} définie au 
														paragraphe~\ref{more_than_on_e_window_ref}. La fenêtre est en fait composée de deux
														instances de \codescaption{MaFenetre}. }}
				{  \includegraphics[width=4.5cm]{\filextellipse{../python_cours/image/fenpers}
						{../python_cours/image_ellipse/fenpers}} }
				{\label{fenetre_ma_perso_fig}}
				\end{figure}

\subsection{Séquence d'événements} \label{sequence_evenement_para}

Il est facile de faire réagir le programme en fonction d'un événement, il suffit d'attacher cet événement à une méthode ou une fonction. En revanche, faire réagir le programme en fonction d'une séquence d'événements est plus complexe. En effet, le premier d'événement de la séquence active une fonction, il n'est pas possible d'attendre le second événement dans cette même fonction, ce dernier ne sera observable que si on sort de cette première fonction pour revenir à la fonction \codes{mainloop}, la seule capable de saisir le prochain événement.

La figure~\ref{fenetre_mainloop_fig} précise la gestion des messages. \codes{Tkinter} se charge de la réception des messages puis de l'appel au traitement correspondant indiqué par la méthode ou la fonction attachée à l'événement. Le programmeur peut définir les traitements associés à chaque événement. Ces deux parties sont scindées et à moins de reprogrammer sa boucle de message, il n'est pas évident de consulter les événements intervenus depuis le début du traitement de l'un d'eux.


				\begin{figure}[ht]
				\figureoneimage{ 				\caption{La réception des événements est assurée par la fonction \codescaption{mainloop} 
														qui consiste à attendre le premier événement puis
				           à appeler la fonction ou la méthode qui lui est associée si elle existe.} }
				{  \includegraphics[width=4.2cm]{\filextellipse{../python_cours/image/mainloop}
						{../python_cours/image_ellipse/mainloop}} }
				{\label{fenetre_mainloop_fig}}
				\end{figure}
            
Les classes offrent un moyen simple de gérer les séquences d'événements au sein d'une fenêtre. Celle-ci fera l'objet d'une classe qui mémorise les séquences d'événements. Tous les événements feront appel à des méthodes différentes, chacune d'elles ajoutera l'événement à une liste. Après cette ajout, une autre méthode sera appelée pour rechercher une séquence d'événements particulière. Le résultat est également illustré par la figure~\ref{fenetre_mainloop_fig_seqev}.
%
\vspaceneg
\inputcode{../python_cours/programme/classique_seq.py}{Tkinter, séquence d'événements}


				\begin{figure}[ht]
				\figureoneimage{ 				\caption{Aspect de la classe \codescaption{MaFenetreSeq} définie au 
														paragraphe~\ref{sequence_evenement_para}. } }
				{  \includegraphics[width=4.5cm]{\filextellipse{../python_cours/image/seqev}
						{../python_cours/image_ellipse/seqev}} }
				{\label{fenetre_mainloop_fig_seqev}}
				\end{figure}
				
\subsection{Communiquer un résultat par message} \label{resultat_communiquer_message}

Le module \codes{Tkinter} permet de définir ses propres messages qui peuvent servir à communiquer des informations. Une fonction est par exemple appelée lorsqu'un bouton est pressé. Celle-ci, une fois terminée, retourne son résultat sous forme de message envoyé à l'interface graphique. Ce message sera ensuite traité comme tout autre message et pourra être intercepté ou non. 

Le programme suivant utilise ce concept. La pression d'un bouton appelle une fonction \codes{event\_generate} qui génère un message personnalisé \texttt{<}\texttt{<perso>}\texttt{>} avec comme paramètre \codes{rooty=-5}. A son tour, celui-ci est attrapé et dirigé vers la fonction \codes{perso} qui affiche l'attribut \codes{y\_root} de la classe \codes{Event} qui a reçu la valeur \codes{-5} lors de l'appel de la fonction \codes{event\_generate}. Ce procédé ne permet toutefois que de renvoyer que quelques résultats entiers.\indextkk{Event}\indextkk{event\_generate}\indextkk{bind}
%				
\vspaceneg
\inputcode{../python_cours/programme/exemple_bind_my.py}{utilisation de messages personnalisés}
\vspaceneg
%
Ce principe est plus utilisé lorsque l'interface graphique est couplée avec les threads, l'ensemble est présenté au paragraphe~\ref{thread_interface_graphique}.
            


\firstpassagedo{
    \begin{thebibliography}{99}
    \input{python_cours_biblio.tex}
    \end{thebibliography}
}



\input{../../common/livre_table_end.tex}%
\input{../../common/livre_end.tex}%