\input{exo_begin.tex}%

\huge ENSAE TD noté, mardi 8 novembre 2023 \normalsize

Toutes les questions valent 2 points. Il est conseillé de lire l'intégralité de l'énoncé avant de commencer.

\exosubject{}
\begin{xexercice}\label{td_note_label4_2023}

Une langue étrangère s'écrit avec 10 lettres \codesbf{ABCDEFGHUIJ}. Chacune est représentée par 4 bits :

\begin{verbatimx}
A 0000
B 0001
C 0010
D 0011
E 0100
F 0101
G 0110
H 0111
I 1000
J 1001
\end{verbatimx}

Avec cette représentation, \codesbf{00000110} signifie \codesbf{AG}.

%1
\exequest Ecrire une fonction qui code une séquence de lettres en une séquence de 0 et 1.

\begin{verbatimx}
def code(text):
    # ....
    return ...

assert code("AG") == "00000110"
\end{verbatimx}

%2
\exequest Ecrire une fonction qui reçoit une séquence de 0 et de 1 et retourne la séquence de lettres correspondante.

\begin{verbatimx}
def decode(chaine):
    # ....
    return ...

assert decode("00000110") == "AG"
\end{verbatimx}

%3
\exequest On forme une classe avec les deux fonctions précédentes. Il faut compléter le code suivant.

\begin{verbatimx}
class Codage:
    def __init__(self):
        # ....

    def code(self, text):
        # ...

    def decode(self, chaine):
        # ...

cl = Codage()
assert cl.code("AG") == "00000110"
assert cl.decode("00000110") == "AG"
\end{verbatimx}

%4
\exequest On veut réduire la taille du message codé.
Les lettres de A à G sont maintenant codées sur 3 bits et les suivantes sur 5.

\begin{verbatimx}
A 000
B 001
C 010
D 011
E 100
F 101
G 110
H 11100
I 11101
J 11110
\end{verbatimx}

On crée une nouvelle classe \codesbf{Codage35} qui hérite de la classe \codesbf{Codage}.

\begin{verbatimx}
class Codage35(Codage):
    def __init__(self):
        # ....

cl = Codage35()
assert cl.code ...
assert cl.decode ...s
\end{verbatimx}

Est-il besoin d'implémenter la méthode \codesbf{code} pour cette nouvelle classe ?

%5
\exequest Vérifiez que le méthode \codes{decode} fonctionne toujours dans cette nouvelle classe. Dans le cas contraire,
il vous faudra soit modifier la méthode de la classe initiale, soit la surcharger dans cette nouvelle classe,
puis dire pourquoi vous avez fait ce choix.

%6
\exequest Dans ce langage, les lettres sont toutes équiprobables.
Quel codage est le plus court pour un texte aléatoire très grand et quantifier le gain ?
Que se passe-t-il si la lettre J a une probabilité de 0.3 et toutes les autres lettres ont la même probabilité
d'apparition ? Que suggérez-vous pour optimiser le codage en terme de longueur ?

%7
\exequest On change le codage des lettres A et B : \codesbf{A \, 00} et \codesbf{B \, 01}. Il faut créer une troisième classe
héritant de la première. Que valent \codesbf{c.code("BGBB")} et \codesbf{c.code("DEF")} ?
Que retourne votre méthode \codesbf{decode} ?

\begin{verbatimx}
class Codage235(Codage):
    def __init__(self):
        # ....

c = Codage235(...)
assert c.code("BGBB") == "011100101"
assert c.code("DEF") == ...
\end{verbatimx}

%8
\exequest Dans le cas précédent, la première lettre peut être soit \textbf{B} soit \textbf{D}.
Ecrire une méthode qui retourne toutes les options pour la première lettre d'un message codé.

%9
\exequest On pourrait écrire \codesbf{decode("01110") = "D" + decode("10")} mais
\codesbf{decode("10")} échoue. Qu'est-ce cela signifie ?


%10
\exequest Ecrire une méthode \codesbf{decode} qui retourne toutes les solutions par récurrence.


\end{xexercice}




\input{exo_end.tex}%
